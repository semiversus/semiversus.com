{"pages":[{"url":"https://www.semiversus.com/about.html","text":"Mein Name ist Günther Jena und komme aus Kappl in Österreich. Ich wohne und arbeite in Rankweil. Vor meiner Hochzeit hieß ich noch Günther Jehle und Jena ist nun die Zusammensetzung aus meinem bisherigen Nachnamen \"Jehle\" und dem bisherigen Nachnamen meiner Frau \"Nagel\". Ich beschäftige mich mit Softwareentwicklung und Elektronik, arbeite als Entwickler bei Spectra Physics und als Lehrer an der HTL Rankweil . Auf dieser Seite möchte ich in Zukunft ein paar meiner Projekte vorstellen und den Blog als einen öffentlichen Notizzettel nutzen. Kontakt E-Mail: guenther@jena.at GnuPG Key: ADD6 34D7 ADE7 72D2 B2D1 A3D0 03B8 2F59 6F67 72C2 LinkedIn: Günther Jena Github: Semiversus Stack-Overflow: Günther Jena","tags":"pages","title":"Günther Jena"},{"url":"https://www.semiversus.com/dic/halbleiterelemente/ausgangstreiber.html","text":"Allgemeines Bei logischen Gattern nach Boolescher Logik geht man von Ausgängen aus, die entweder eine logische 0 oder 1 liefern. Für die Praxis haben sich noch weitere Ausgangsstufen entwickelt, um weitere technische Realisierungen zu ermöglichen. Totem-Pole Ausgang Totem-Pole Ausgang bei einem NAND Gatter (Bild: MichaelFrey CC BY-SA 2.0) Der Totem-Pole Ausgang oder auch Gegentakt-Ausgangsstufe wird bei TTL Gattern durch NPN-Transistoren realisiert. Bei CMOS Bauteilen dienen dazu jeweils ein n-Kanal und ein p-Kanal Feldeffekttransistor. Der Name Totem-Pole rührt von der Anordnung der Bauteile der Ausgangsstufe, die ähnlich einem Totempfahl der Indianer aussieht. Typischerweise können Totem-Pole Ausgänge mehr Strom nach Masse ziehen als sie über Versorgung liefern können. Ein Totem-Pole Ausgang kann also die beiden logischen Pegel 0 und 1 ausgeben. Open-Collector Ausgang Open-Collector Ausgang bei einem NAND Gatter (Bild: MichaelFrey CC BY-SA 2.0) Bei Open-Collector Ausgang wird nur ein Transistor verwendet, dessen Kollektor als Ausgang dient. Damit kann das Potential am Ausgang auf Masse gezogen werden, aber es kann kein hohes Potential (logisch 1) ausgegeben werden. Um ein hohes Potential zu erhalten wird ein externer Pull-Up Widerstand verwendet. Dieser verbindet den Ausgang mit der Versorgung. Der Ausgang ist auf logisch 1 wenn der Transistor sperrt und damit der Ausgang über den Pull-Up Widerstand versorgt wird. Eine logische 0 wird ausgegeben indem der Transistor leitet und damit das Potenital auf Masse zieht. Vorteile des Open-Collector Ausganges: Anpassung an verschiedene Betriebsspannungen: Die externe Betriebsspannung kann höher oder niedriger sein als die Betriebsspannung des Bausteils. Zusammenschalten mehrerer Ausgänge: Wenn mehrere Open-Collector Ausgänge zusammengeschaltet werden, setzt sich eine logische 0 durch, da damit das Potential auf Masse geschaltet wird Folgende Punkte sind weiters zu beachten: Wird der Pull-Up zu niederohmig dimensioniert, kann der maximal erlaubte Strom des Ausgangstransistors überschritten werden. Damit wird entweder das Bauteil zerstört oder das Potential kann nicht auf Masse gezogen werden. Wird der Pull-Up zu hochohmig dimensioniert, reicht der Strom nicht mehr aus, das Potential auf logisch 1 zu ziehen. Je größer der Pull-Up Widerstand, desto langsamer der Wechsel von logisch 0 auf logisch 1. Je kleiner der Pull-Up Widerstand, desto mehr Leistung wird verbraucht. Typische Werte für Pull-Ups sind zwischen 1kOhm und 100kOhm. Betrachtet man den Open-Collector Ausgang ohne Pull-Up kann dieser die logische 0 ausgeben oder hochohmig sein. Tri-State Tri-State Ausgang eines Inverters (Bild: Mik81 CC BY 2.0) Bei Tri-State Ausgang wird ein Totem-Pole Ausgang so erweitert, dass keiner der beiden Transistor leitet, d.h. weder logisch 0 noch logisch 1 ausgegeben wird. Dadurch ist der Ausgang hochohmig . Dieser dritte Zustand wird genutzt, um mehrere Ausgänge zusammenzuschalten. Dabei ist nur ein Eingang aktiv auf logisch 0 oder 1 und alle anderen Ausgänge sind hochohmig. Der Tri-State Ausgang kann also logisch 0 und 1 ausgeben oder hochohmig sein.","tags":"halbleiterelemente","title":"Ausgangstreiber"},{"url":"https://www.semiversus.com/dic/grundlagen_der_digitaltechnik/automatentheorie.html","text":"Übungsblatt Zu diesem Teil gibt es Übungsaufgaben Allgemeines Die Automatentheorie beschreibt Modelle, die durch die im Automat vorhanden Zustände, den akzeptierten Eingaben und durch die Ausgaben beschrieben werden können. Wenn ein Automat nur endlich viele Zustände einnehmen kann, spricht man von einem ''endlichen Automaten''. Andere Ausdrücke sind Zustandsmaschine oder der englische Ausdruck ''Finite State Machine''. Mathematische Beschreibung Eingabealphabet Σ Das Eingabealphabet (oder auch Eingabemenge) beschreibt die Menge aller vorkommenden Eingaben, die durch den Automaten bearbeitet werden können und wird durch das Zeichen Σ (großes Sigma) dargestellt. Eine Eingabe kann zum Ändern des Zustands des Automaten und zu einer Ausgabe führen. Ausgabealphabet Γ Analog zum Eingabealphabet beschreibt das Ausgabealphabet Γ (großes Gamma) die Menge aller vorkommenden Ausgaben des Automaten. Man kann zwischen vier Typen unterscheiden, zu welchem Zeitpunkt eine Ausgabe gemacht wird: Eintritt in einen Zustand : Sobald in einen neuen Zustand eingetreten wird, wird die Ausgabe gemacht. Dazu ist für jeden Zustand eine bestimmte Eintrittsaktion definiert. Austritt aus einem Zustand : Sobald aus einem Zustand ausgetreten wird, wird die Ausgabe gemacht. Hier wird auch für jeden Zustand eine bestimmte Austrittsaktion definiert. Eingabe bei einem Zustand : Hier wird je nach Zustand und Eingabe eine entsprechende Ausgabe gemacht. Zustandsübergang : Zu jedem Zustandsübergang wird eine entsprechende Ausgabe definiert. Zustandsmenge S Die Zustände, die ein Automat einnehmen kann wird durch die endliche Menge S beschrieben. Anfangszustand s0 Der Anfangszustand s0 ist ein Zustand aus der Zustandsmenge S und beschreibt den Zustand, den der Automat nach der Inbetriebnahme einnimmt. Zustandsübertragungsfunktion δ Die Zustandsübertragungsfunktion δ (klein Delta) beschreibt den Wechsel in einen neuen Zustand in Abhängigkeit des aktuellen Zustandes und der Eingabe. Die Zustandsübertragungsfunktion kann gut als Tabelle dargestellt werden: δ | E0 | E1 | E2 :-:!|:-:|:-:|:-: Z0 |Z0|Z1|Z2 Z1 |Z2|Z2|Z0 Z2 |Z0|Z0|Z0 Bei diesem Beispiel ist S ={ Z0 , Z1 , Z2 } und Σ ={ E0 , E1 , E2 }. In den Zeilen sind alle Zustände, in den Spalten alle Eingänge dargestellt. Nun kann bei einem bestimmten Zustand und einer bestimmten Eingabe abgelesen werden, in welchen Zustand dadurch gewechselt wird. Als Beispiel wird im Zustand Z0 wird bei der Eingabe E1 in den Zustand Z1 gewechselt. Ausgabefunktion ω Die Ausgabefunktion ω (klein Omega) beschreibt die Ausgabe in Abhängigkeit von Zustand und Eingabe oder auch nur vom Zustand (vergleiche ''Moore''- und ''Mealy''-Automat). Falls die Ausgabefunktion von Zustand und Eingabe abhängig ist, lässt sich die Funktion auch gut als Tabelle darstellen: ω | E0 | E1 | E2 :-:!|:-:|:-:|:-: Z0 |A0|A2|A0 Z1 | A1 |A1|A2 Z2 |A2|A1|A1 In diesem Beispiel ist Γ ={ A0 , A1 , A2 }. Hier wird als Beispiel beim Zustand Z1 und der Eingabe E0 die Ausgabe A1 gemacht. Moore- und Mealy-Automat Bei der Ausgabefunktion gibt es zwei verschiedene Definitionen: Einmal hängt die Ausgabe von Zustand und Eingabe ab und das andere mal nur vom Zustand. Ein Automat, dessen Ausgabe von Zustand und Eingabe abhängt wird ''Mealy''-Automat genannt. Im Gegensatz dazu hängt bei einem ''Moore''-Automat die Ausgabe nur vom aktuellen Zustand ab. Dies kann in folgendem Diagramm zusammengefasst werden: Es ist möglich, einen gegebenen Mealy-Automaten in einen Moore-Automaten umzuwandeln und umgekehrt. Für viele Aufgabenstellungen kommt der Mealy-Automat mit weniger Zuständen aus, da die Eingänge auch direkt die Ausgänge beeinflussen können. Um das selbe zu erreichen, benötigt der Moore-Automat mehr Zustände, da die Ausgänge immer vom aktuellen Zustand abgeleitet werden. Beispiel Getränkeautomat Als Beispiel wird ein Getränkeautomat entworfen, der 50 Cent und 1 Euro Geldstücke akzeptiert. Außerdem gibt es eine Taste für die Getränkeausgabe und die Geldrückgabe. Der Getränkeautomat kann 50 Cent und 1 Euro Stücke zurückgeben, sowie ein Getränk ausgeben. Ein Getränk kostet 1 Euro. Dadurch können wir unsere Ein- und Ausgabemenge definieren: Eingabemenge : Σ ={\"50 Cent\", \"1 Euro\", \"Rückgabetaste\", \"Getränketaste\"} Ausgabemenge : Γ ={\"50 Cent\", \"1 Euro\", \"Getränk\", \"Keine Ausgabe\"}} Als Zustände des Automaten definieren wir das aktuelle Guthaben. Zustandsmenge : S ={\"0 Euro\", \"50 Cent\", \"1 Euro\"} Da beim Start des Automaten noch kein Geld eingeworfen wurde, definieren wir \"0 Euro\" als Startzustand. Startzustand : s0 =\"0 Euro\" Für das Erstellen der Zustandsübertragungsfunktion müssen wir definieren, wie der Automat reagieren soll. Wird mehr als 1 Euro eingeworfen, soll das Geld über einem 1 Euro ausgegeben werden und weiterhin 1 Euro Guthaben behalten werden. Die Taste ''Rückgabe'' soll jederzeit das vorhandene Guthaben ausgeben. Die Taste ''Getränkeausgabe'' soll nur ein Getränk ausgeben, wenn 1 Euro Guthaben vorhanden ist. Zustandsübertragungsfunktion : δ | 50 Cent | 1 Euro | Rückgabetaste | Getränketaste :-:!|:-:|:-:|:-:|:-: 0 Euro | 50 Cent | 1 Euro | 0 Euro | 0 Euro 50 Cent | 1 Euro | 1 Euro | 0 Euro | 50 Cent 1 Euro | 1 Euro | 1 Euro | 0 Euro | 0 Euro Für die volle Funktionsbeschreibung unseres Getränkeautomaten benötigen wir noch die Ausgabefunktion ω . Ausgabefunktion : ω | 50 Cent | 1 Euro | Rückgabetaste | Getränketaste :-:!|:-:|:-:|:-:|:-: 0 Euro | Keine Ausgabe | Keine Ausgabe | Keine Ausgabe | Keine Ausgabe 50 Cent | Keine Ausgabe | 50 Cent | 50 Cent | Keine Ausgabe 1 Euro | 50 Cent | 1 Euro | 1 Euro | Getränk Anhand der Beschreibung der einzelnen Mengen und Funktionen kann man nun die Funktion des Automaten vollständig beschreiben. Interessant bei diesem Beispiel ist die Tatsache, dass der Getränkeautomat \"rechnen\" kann: Bei 50 Cent Guthaben und 1 Euro Einwurf werden 50 Cent zurückgegeben und das Guthaben ist 1 Euro. Genauso wird beim Einwurf von zwei 50 Cent Stücken und dem Drücken der Taste \"Rückgabe\" ein 1 Euro Geldstück zurückgegeben. Die \"Berechnung\" selbst wurde aber nur implizit durch die Zustandsübertragungs- und Ausgabefunktion beschrieben. Graphische Darstellung Bisher kamen wir mit einer rein mathematischen Darstellung aus. In der Praxis ist es aber viel einfacher sich ein Bild von den Zuständen und den Übergängen zu machen. Dazu wird das sogenannte ''Zustandsübertragungsdiagramm'' genutzt. Die Darstellungsform für Mealy- oder Moore-Automat unterscheiden sich: Zustände werden als Kreise dargestellt. Die Bezeichnung des Zustands befindet sich innerhalb des Kreises. Der Startzustand wird mit einem Pfeil markiert, der keinen Zustand als Ursprung hat (hier Z0 ). Die Übergänge werden mittels Pfeilen dargestellt. Der Beschreibung des Pfeils enthält die Eingabe, die für diesen Zustandswechsel notwendig ist. Beim Mealy-Automat sind die Ausgaben vom Zustand und der Eingabe abhängig, deshalb wird die Ausgabe in der Beschreibung des entsprechenden Pfeils hinzugefügt. Beim Moore-Automat ist die Ausgabe nur vom Zustand abhängig, deshalb wird die Ausgabe innerhalb des Kreises hinzugefügt. Anwendung in der Digitaltechnik Bisher gingen wir von allgemeinen Ein- und Ausgaben aus. In der Digitaltechnik sind dies nun Ein- und Ausgänge, die ausschließlich mit den beiden digitalen Zuständen 0 und 1 arbeiten. Die Kennwerte für einen digitalen Automat sind die Anzahl der Ein- und Ausgänge sowie die Anzahl der Flip-Flops. Mit n Flip-Flops lassen sich 2&#94;n Zustände darstellen. Bei den digitalen Automaten kommt neben dem schon bekannten Moore- und Mealy-Automat noch der Medwedew-Automat dazu. Dieser endliche Automat hat keine Ausgabefunktion sondern stellt die Ausgänge der einzelnen Speicherelemente direkt als Ausgänge zur Verfügung. Bei der Erstellung eines Medwedew-Automat müssen daher die Zustände entsprechend der gewünschten Ausgänge gewählt werden. Der Medwedew-Automat ist eine Sonderform des Moore-Automaten.","tags":"grundlagen_der_digitaltechnik","title":"Automatentheorie"},{"url":"https://www.semiversus.com/dic/hardwarenahe_programmierung/avr_adc.html","text":"Diese Seite beschreibt den ADC des ATMega16 Prinzipiell lässt sich diese Information auch auf andere Mikrocontroller der AVR Serie übertragen, es empfiehlt sich aber die Informationen mit dem entsprechenden Datenblatt zu vergleichen! Informationen im Datenblatt Die Informationen dieser Seite entstammen dem originalen Datenblatt (Rev. 2466T–AVR–07/10) des ATMega16 von Atmel. Seite 204-221 : ADC Seite 204-205 : Übersicht und Blockschaltbild Seite 217-221 : Registerbeschreibung Allgemeines Die wichtigsten Eigenschaften des ADC: 10 Bit Auflösung Bis zu 15 Tausend Wandlungen pro Sekunde 8 gemultiplexte Eingänge (in Kombination zu 7 differentiellen Messungen und 2 mit Verstärkung von 10 oder 200) Messungen bis V CC Integrierte 2.56 V Referenzspannung Aufbau Blockschaltbild des ADC (Quelle: Datenblatt ATMega16 © Atmel Corporation) Eingänge Im linken unteren Segment sind die Eingänge, die über Multiplexer zum eigentlichen ADC geführt werden. Der Multiplexer \" Pos. Input Mux \" kann zwischen den 8 Pins ADC0 bis ADC7 sowie Masse und einer Bandgap -Referenz (typ. 1.23 V) wählen. Für differentielle Messungen wird jeweils ein zweiter Kanal benötigt, der über den Multiplexer \" Neg. Input Mux \" ausgewählt wird. Der positive und negative Kanal wird durch eine einstellbare Verstärkung ( Gain Amplifier ) zu einem Multiplexer geführt, der auswählt, ob eine sog. Single Ended oder eine differentielle Messung durchgeführt wird. AD Wandlung Der ADC arbeitet mittels einer 10 Bit sukzessiven Approximation. Dazu wird ein 10 Bit DAC schrittweise auf die zu messende Spannung eingestellt. Mit jedem Bit mehr Auflösung wird über einen Komperator ( Sample & Hold Comperator ) entschieden, ob das nächste Bit 0 oder 1 sein soll. Als Konsequenz dieses Ablaufs benötigt diese Art von ADC mehrere Takte für die Umwandlung. Referenz Als Referenz stehen drei Quellen zur Verfügung: Die analoge Betriebsspannung AVCC Die interne 2.56 Volt Referenzspannung Eine externe Referenzspannung am Pin AREF Register Register ADMUX Das Register ADMUX steuert die Auswahl der Referenzspannung, der Anordnung der Datenbits und die Auswahl des zu messenden Kanals. Wird als Referenzspannung die interne 2.56 Volt Referenz oder die Betriebsspannung AVCC gewählt empfiehlt es sich, an den Pin AREF einen Kondensator zu schalten, um Rauschen zu minimieren und die Referenzspannung möglichst stabil zu halten. In diesen zwei Fällen sollte auf keinen Fall eine externe Spannung am Pin AREF anliegen! Die Anordnung der Datenbits mittels ADLAR kann je nach Anwendung eingestellt werden. Wird der 10 Bit Wert verwendet, kann beim avr-gcc Compiler mittels ADC auf die Kombination von ADCH und ADCL zugegriffen werden. Wenn einzeln auf die Register zugegriffen wird muss ADCL vor ADCH ausgelsen werden. Register ADCSRA ADEN - ADC Enable Schaltet den ADC ein. ADSC - ADC Start Conversion Um eine Wandlung zu starten wird dieses Bit mit 1 beschrieben. Beim Lesen liefert dieses Bit eine 1 solange eine Wandlung läuft. ADATE - ADC Auto Trigger Enable Es gibt zahlreiche Möglichkeiten, eine Wandlung durch Trigger starten zu lassen. Weitere Infos dazu finden sich im Datenblatt. Hier wird ausschließlich das Starten einer Wandlung durch die Firmware selbst beziehungsweise ein erneutes Starten nach einer Wandlung beschrieben. ADIF - ADC Interrupt Flag Wenn eine Wandlung beendet wurde wird dieses Bit auf 1 gesetzt. Eine eventuell aktivierte Interruptroutine des ADCs setzt dieses Bit wieder auf 0 , sobald die entsprechende Interruptroutine aufgerufen wurde. Wird ohne Interrupts gearbeitet kann mittels schreiben einer 1 auf dieses Bit das Bit zurückgesetzt werden. ADIE -ADC Interrupt Enable Aktiviert den ADC Interrupt (siehe Beispiele) ADPS2:0 - ADC Prescaler Select Bits Wählt den Teiler für die Wandlung des ADCs. Der ADC arbeitet mit einer Frequenz zwischen 50kHz und 200kHz. Diese Frequenz wird aus dem Prozessortakt und diesem Teiler erzeugt. %%f_{ADC}=\\frac{f_{CLK}}{Teiler}%% Umrechnung Bei der Umrechnung einer Spannung am Eingang des ADC hin zum Wert als Zahl wird die Eingangsspannung im Verhältnis zur Referenzspannung betrachtet und entsprechend der Auflösung (in Bits} des ADC umgewandelt: %%Wert_{ADC}=\\frac{U_{Eingang}}{U_{Referenz}} \\cdot 2&#94;{Bits}%% Der Umgekehrte Fall ist dann die Umrechnung von einem Wert in die anliegende Spannung: %%U_{Eingang}=\\frac{Wert_{ADC}}{2&#94;{Bits}} \\cdot U_{Referenz}%% Beim ATMega16 ist die Auflösung 10 Bit, d.h. es können %%2&#94;{10}=1024%% verschiedene Spannungen unterschieden werden. Beispiele Im folgenden Beispiel wird an Kanal 5 (Port A5) die Spannung gemessen. Als Referenz dient die Spannung am Pin AREF. Vom 10 Bit Ergebnis werden die oberen 8 Bit auf dem Port C ausgegeben. Ohne Interrupt #include <avr/io.h> int main ( void ) { DDRC = 0xFF ; // Port C.0-7 = Ausgang PORTC = 0x00 ; // LEDs loeschen ADMUX = 0x05 ; // Eingang 5 festlegen ADCSRA = ( 1 << ADEN ) | ( 1 << ADPS2 ) | ( 1 << ADPS1 ); // ADC enable, Teiler auf 64 while ( 1 ) { ADCSRA |= ( 1 << ADSC ); // ADC Wandlung starten while ( ! ( ADCSRA & ( 1 << ADIF ))); // Auf Abschluss der Konvertierung warten (ADIF-bit) PORTC = ADC >> 2 ; // Ausgabe der oberen 8 Bit auf PORTC } return 0 ; } Mit Interrupt Bei jedem Aufruf der Interruptservice Routine ADC_vect wird das Ergebnis der AD Wandlung ausgewertet (mittels ADC ) und eine neue Wandlung gestartet. #include <avr/io.h> #include <avr/interrupt.h> ISR ( ADC_vect ) { PORTC = ADC >> 2 ; // Ausgabe der oberen 8 Bit auf PORTC ADCSRA |= ( 1 << ADSC ); // ADC Wandlung starten } int main ( void ) { DDRC = 0xFF ; // Port C.0-7 = Ausgang PORTC = 0x00 ; // LEDs loeschen ADMUX = 0x05 ; // Eingang 5 festlegen ADCSRA = ( 1 << ADEN ) | ( 1 << ADSC ) | ( 1 << ADIE ) | ( 1 << ADPS2 ) | ( 1 << ADPS1 ); // ADC enable, //Wandlung starten, Interrupt enable, Teiler auf 64 sei (); while ( 1 ) { // main loop } return 0 ; }","tags":"hardwarenahe_programmierung","title":"Analog-Digital Konverter beim Atmel AVR"},{"url":"https://www.semiversus.com/dic/hardwarenahe_programmierung/avr_allgemein.html","text":"Allgemeines Datenblatt Atmel ATMega16 ( Download über Atmel.com ) Sämtliche Seitenangaben beziehen sich auf dieses Datenblatt (Rev. 2466T–AVR–07/10). Fuse und Lock Bits ( Seite 259-261 ) Bei den Fuse Bits handelt es sich um Bits, die während einem Programmiervorgang verändert werden können. Mit den Fuse Bits wird z.B. die Wahl der Taktquelle (intern oder extern, ...) ausgewählt. Der Name Fuse Bit kann hier etwas verwirren, da sie nicht wie Sicherungen wirken, die nur einmal programmiert werden können. Bei den Lock Bits handelt es sich um einen Auslese Schutz. Wird ein Mikrocontroller in einem Produkt verwendet, kann es sinnvoll sein, den Programmspeicher-Inhalt vor einem Auslesen zu schützen. Es gibt drei verschiedene Modi dieses Schutzes: Programmieren und Auslesen des Programmspeichers erlaubt Programmieren erlaubt, aber nicht das Auslesen Weder Programmieren noch Auslesen erlaubt. Diese Lockbits können nur einmal gesetzt werden und dann nicht wieder zurückgesetzt werden. Versorgung Die Versorgungspannung ist abhängig vom verwendeten Typ. Beim ATMega16 gibt es zwei verschiedene Ausführungen (siehe Seite 336): Takt Versorgung ATMega16 bis 16Mhz 4.5V bis 5.5V ATMega16L bis 8Mhz 2.7V bis 5.5V Die Stromaufnahme ist abhängig von der Betriebsspannung, der Betriebsart und der Taktfrequenz (siehe Seite 299-311). Generell kann gesagt werden, dass je kleiner die Betriebsspannung und die Taktfrequenz ist, desto kleiner ist der Stromverbrauch. Die verschiedenen Betriebsmodie helfen, den Stromverbrauch zu reduzieren, indem der Microcontroller seinen Betrieb einstellt und in verschiedene Stromsparmodis wechselt. Bei der Versorgung wird zwischen der digitalen Versorgung für den eigentlichen Mikroprozessorkern und der analogen Versorgung für den ADC unterschieden. Reset ( Seite 37-41 ) Während dem Reset werden alle Register auf ihren Anfangszustand zurückgesetzt. Die Programmausführung startet beim Reset Vektor. Es gibt verschiedene Möglichkeiten, einen Reset durchzuführen: Power-On Reset : Ein Reset wird durchgeführt, wenn sich die Betriebsspannung unter der Power-on-Reset Spannungsgrenze befindet. External Reset : Wenn am RESET Pin ein Low-Pegel anliegt, wird ein Reset durchgeführt. Watchdog Reset : Beim Watchdog des Atmel AVR handelt es sich um einen sogenannten Time-Out Watchdog. Zur Verwendung wird der Watchdog aktiviert. Die Applikation muss in regelmäßigen Zeitintervallen den Watchdog zurücksetzen. Wenn dieses Zeitintervall zu groß ist (z.B. weil die Applikation sich in einer Endlosschleife gefangen hat) wird der Watchdog aktiv und löst einen Reset aus. Brown-Out Reset : Die Brown-Out Detektion erkennt einen Abfall der Versorgungsspannung. Beim Atmel AVR können über Fuse Bits verschiedene Pegel eingestellt werden (beim ATMega16 2.7V und 4V). Ein Reset wird ausgelöst, wenn die Versorgungsspannung diesen Pegel unterschreitet und die Brown-Out Detektion generell aktiviert ist. JTAG AVR Reset : Die JTAG Schnittstelle dient dem direkten Zugriff auf die Register des Mikrocontrollers z.B. für Debugging Zwecke. Über diese Schnittstelle kann auch ein Reset ausgelöst werden. Takt ( Seite 24-31 ) Für den ATMega16 Mikrocontroller gibt es verschiedene Taktquellen auf der einen und Komponenten, die einen Takt benötigen, auf der anderen Seite. Komponenten die mit einem Takt versorgt werden sind dabei: %%clk_{CPU}%%: Dieser Takt steuert die Abläufe innerhalb des Prozessorkerns und dem SRAM Speicher. %%clk_{I/O}%%: Die meisten Peripheriebausteine innerhalb des ATMega16 werden mittels diesem Takt gesteuert. Dazu zählen etwa die USART und der Timer/Counter. %%clk_{ADC}%%: Der ADC hat eine eigene Taktversorgung. Dies erlaubt das Anhalten des Prozessor und I/O Taktes, um eine möglichst störungsfreie Analogumsetzung zu ermöglichen. %%clk_{ASY}%%: Dieser Takt kann von einem externen 32kHz Quarzoszillator erzeugt werden. Dadurch wird es möglich, eine Echtzeitmessung auch innerhalb eines Stromspar Modus durchzuführen. Der Watchdog Timer wird von einem eigenen Oszillator betrieben. Die Frequenz ist abhängig von Temperatur und Versorgungsspannung (Seite 321). Als Taktquellen gibt es verschiedene Möglichkeiten, die per Fuse Bits ausgewählt werden: Externer Quarz (hoch und niederfrequent) Externer RC Oszillator Interner RC Oszillator (Kalibrierung über das OSCCAL Register). Externes Taktsignal Zusätzlich zu den Taktquellen sind noch Startzeiten für die einzelnen Taktquellen über die Fuse Bits einstellbar. Diese Startzeiten werden benötigt, da die einzelnen Taktquellen eine bestimmte Zeit benötigen, bis sie auf ihrer Frequenz schwingen. Erst wenn diese Startzeit (Anzahl an definierten Taktzyklen und zusätzliche Verzögerung) vergangen ist, wird der Prozessorkern mit dem Takt versorgt. In der Praxis reicht es meist aus, einfach das Maximum an Startverzögerung einzustellen, da die daraus resultierende Zeit immer unter 100 Millisekunden ist. Sleep Modes ( Seite 32-36 ) Der Stromverbrauch jeder Komponente eines Mikrocontrollers besteht aus einem statischen Grundverbrauch (Leckströme, usw.) und einem dynamischen Verbrauch, der durch die Umschaltvorgänge, die vom Taktsignal ausgelöst werden, bestimmt wird. Der dynamische Verbrauch macht den größten Teil aus. Dadurch ist bei niedriger Taktfrequenz auch der Stromverbrauch niedriger. Wird für einen bestimmten Zeitraum der Prozessorkern nicht benötigt, kann dieser durch Abschalten des Prozessortaktes in einen sogenannten Schlafmodus gebracht werden und der Stromverbrauch reduziert sich. Es stehen verschiedene Stromsparmodi zur Verfügung: Idle : Prozessor hält, bis ein Interrupt auftritt ADC Noise Reduction : Solange eine Analogwandlung läuft und kein Interrupt eintritt, wird der Takt des Prozessors und der IO Komponenten gestoppt. Dies verbessert die Messungen, indem Störungen minimiert werden. Standby : Deaktiviert zusätzlich den ADC Takt, sowie Interrupts für EEPROM/Flash. Power Down bzw. Power Save : In diesem Zustand wird der externe Oszillator gestoppt. Dies ermöglicht eine weitere Stromreduzierung. Tritt ein Interrupt auf, kommt es zu einer Verzögerung, da der Oszillator erst anlaufen muss. Dazu wird die durch die Fuse Bits eingestellte Verzögerung verwendet.","tags":"hardwarenahe_programmierung","title":"Allgemeines zur Atmel AVR Architektur"},{"url":"https://www.semiversus.com/dic/rechnerarchitektur/avr_assembler.html","text":"Übungsblatt Zu diesem Teil gibt es Übungsaufgaben Allgemeines Der Befehlssatz des Atmel AVR ist ein typischer RISC -Befehlssatz. Bei der Entwicklung der AVR Reihe stand vor allem eine möglichst effiziente Nutzung durch C-Compiler im Vordergrund. Komplette Übersicht über den Befehlssatz von Atmel Auszug der wichtigsten Befehle Blockschaltbild Blockschaltbild des AVR (Quelle: Datenblatt ATMega16 © Atmel Corporation) Im Blockschaltbild des Atmel AVR ATMega16 erkennt man am oberen und unteren Ende die vier IO-Ports. Rund um den Prozessorkern ( AVR CPU ) befindet sich folgende Peripheriebausteine: ADC, mit Multiplexer auf die Pins von Port A I²C Schnittstelle (TWI - Two Wire Interface) auf Port C Timer/Counter Watchdogtimer mit dem internen Oszillator MCU Ctrl. & Timing - zuständig für den Prozessortakt und Reset Interrupt Einheit EEPROM USART auf Port D SPI auf Port B Komperator Diese Peripheriebausteine sind über einen Adress/Datenbus mit dem Prozessorkern verbunden. Der Prozessorkern besteht aus dem Flash Speicher für das eigentliche Programm und dem SRAM für die Laufzeitvariablen. Der Programmzeiger ( Program Counter ) zeigt auf den aktuellen Befehl der vom Instruction Register zwischengespeichert wird und durch den Instruction Decoder dekodiert wird. Der Stack Pointer dient zum Ablegen von Werten und Rücksprungadressen im SRAM. Für Berechnungen mit der ALU werden die Register R0 bis R31 genutzt. 3 16Bit Indexregister (X, Y und Z) dienen der indirekten Adressierung des SRAMs. Das Statusregister ist unter anderem für die Flags der ALU zuständig ( Carry , Overflow , usw.). Im Prozessorkern sieht man auch die Harvardarchitektur, da der SRAM Speicher und der Flash Speicher durch getrennte Adress/Datenbusse angesteuert werden. Registersatz Die AVR Serie besitzt 32 allgemein verwendbare Register( R0 bis R31 ). Die Register R0 bis R15 sind nicht verfügbar für Befehle mit unmittelbaren Konstanten (z.B. ldi -load immediate). Die Register R27:R26 bilden gemeinsam das 16 Bit X-Register, wobei R27 das höherwertige Byte darstellt und R26 das niederwertige. Neben dem X-Register gibt es analog das Y und Z Register: R27:R26 : X-Register R29:R28 : Y-Register R31:R30 : Z-Register Diese Register können für die indirekte Adressierung genutzt werden. Stack Pointer Der Stack Pointer ist eine 16 Bit Adresse und zeigt auf die aktuelle Position im Stack. Auf dem Stack werden die Rücksprungadressen bei einem call -Befehl und bei einem Interruptaufruf gespeichert. Zusätzlich kann der Stack genutzt werden, um Register zu sichern oder Zwischenergebnisse zu speichern. Der Stackpointer muss vor dem ersten Zugriff initialisiert werden. Dazu wird er an das Ende des Datenspeichers gesetzt. Der AVR Assembler unterstützt das Symbol RAMEND , das die letzte Adresse des Datenspeichers darstellt. Die Makros HIGH und LOW liefern die oberen bzw. unteren 8 Bit eines 16 Bit Wertes. ldi R16, HIGH(RAMEND) out SPH, R16 ldi R16, LOW(RAMEND) out SPL, R16 Adressräume Bedingt durch die Harvard-Architektur der AVR Serie gibt es eine Trennung der Adressräume für den Befehlsspeicher (Flash), den Datenspeicher (SRAM) und dem EEPROM. Befehlsspeicher Der Adressraum im Befehlsspeicher wird in folgende Bereiche unterteilt: Interruptvektoren : Sprungmarken für Reset und die Interruptquellen Programmspeicher : Nach den Interruptvektoren befindet sich das eigentliche Programm Optionaler Bootloader : Ein Teil des Befehlsspeichers kann geschützt und als Bootloader verwendet werden Datenspeicher Adresse Beschreibung 0x00-0x1F Register R0 bis R31 0x20-0x5F I/O Register 0x00 bis 0x3F 0x60 -Ende des internen SRAM als Datenspeicher verwendbar EEPROM Das EEPROM wird mittels I/O Register angesprochen. Befehlsübersicht Transferbefehle Kopieren von Registern mittels mov Kopiert den Inhalt des Registers Rr in das Register Rd. mov r0, r16 ; Kopiert den Inhalt von R16 nach R0 Eine spezielle Variante ist movw . Hier werden zwei Register gleichzeitig kopiert, wobei als Basisregister nur geradzahlige Register möglich sind. movw r17:r16, r1:r0 ; Kopiert Register R1 nach R17 und Register R0 nach R16 Laden von Registern mittels ld Beim Laden gibt es mehrere Möglichkeiten der Adressierung der Quelle. Soll ein Konstante geladen werden, wird ldi verwendet. ldi R16, 0x20 ; Lädt den Wert 0x20 in das Register R16 Soll von einer bestimmten Speicheradresse geladen werden, wird lds verwendet. lds R0, 0x60 ; Lädt den Wert an der Adresse 0x60 ins Register R0 Die Register X,Y und Z können zum indirekten Laden von Werten verwendet werden. Dabei wird der Inhalt der Register als Adresse verwendet und an der Wert von der entsprechenden Adresse im Speicher geladen. Weiters ist es möglich, die Adresse nach dem Zugriff um 1 zu erhöhen (Post-Inkrement) oder vor dem Zugriff um 1 zu erniedrigen (Pre-Dekrement). ld r0, X ; Lädt den Wert an der durch das Register X dargestellten Adresse ld r1, Y+ ; Erhöht nach dem Laden das Y Register um 1 ld r3, -Y; Erniedrigt vor dem Laden das Y Register um 1 Für den Zugriff auf Tabellen oder auf den Stack Frame eignet sich das Laden mittels Displacment. Dabei wird das Y oder Z Register verwendet und ein Offset hinzugerechnet. ldd r4, Y+20 ; Lädt den Wert an der durch Y+20 dargestellten Adresse Speichern von Werten im SRAM Beim Speichern auf eine bestimmte Speicheradresse wird der Befehl sts benutzt. sts 0x60, R0 ; Speichert den Wert des Registers R0 an der Adresse 0x60 Ähnlich zu den Load Befehlen kann auch die indirekte Adressierung über X,Y und Z Register verwendet werden. st X, r0 ; Speichert das Register an der durch das Register X dargestellten Adresse st Y+, r1 ; Erhöht nach dem Speichern das Y Register um 1 st -Y, r1; Erniedrigt vor dem Speichern das Y Register um 1 Zugriff auf I/O Register Der Zugriff auf I/O Register erfolgt mittels in und out . out PORTD, R0 ; Kopiere den Wert von R0 ins IO Register PORTD in R29, PINA ; Kopiere den Wert des IO Registers PINA ins Register R29 Arbeiten mit dem Stack Der Stackpointer wird in den beiden Register SPH und SPL gespeichert. Mittels push und pop können Werte auf den Stack gelegt bzw. wieder vom Stack geholt werden. Der Stack wird außerdem genutzt, um die Rücksprungadresse bei Subroutinen-Aufrüfen mittels call bzw. rcall zu speichern. Arithmetische Befehle Arthmetische Befehle verknüpfen üblicherweise entweder zwei Register miteinander oder ein Register mit einer Konstante. Als Operationen stehen die Addtion ( add ) und Subtraktion ( sub ) zur Verfügung. Es gibt auch jeweils eine Veriante, in der das Übertragsbit aus einer vorhergehenden Operation verwendet wird ( adc bzw. sbc ). Für die Addition der Konstante 1 stehen die Befehle inc (Inkrement) bzw. dec (Dekrement) zur Verfügung. Logische Befehle Zu den logischen Befehlen gehört die AND Verknüpfung ( and bzw. andi ), die ODER Verknüpfung ( or bzw. ori ), die Exclusive-ODER Verknüpfung ( eor ) und die Invertierung aller Bits ( com ). Sprünge Unbedingte Sprünge Bei unbedingten Sprüngen ist der Sprung nicht von einer Bedingung abhängig. Es gibt relative Sprünge ( rjmp ) und absolute Sprünge ( jmp ). Die relativen Sprünge können den Befehlszähler um +/-2048 verändern. Dies benötigt zwar eine entsprechende Berücksichtigung vom Assembler bzw. Compiler aus, stellt aber durch die kompaktere Ausführung (ein Befehlswort statt zwei) eine Optimierung dar. Bedingte Sprünge Die bedingten Sprünge bedienen sich der Überprüfung von Flags aus dem Statusregister und entscheiden anhand deren Zustandes, ob der Sprung genommen wird oder nicht. Häufig genutzt werden hier breq (branch if equal), brne (branch if not equal), brlo (branch if lower) und brsh (branch if same or higher). Die Statusflags müssen durch einen vorhergehenden Befehl entsprechend gesetzt werden. Will man kein Register für einen Vergleich ändern, sondern nur die Statusflags, so eignet sich der cp (compare) Befehl. Dieser Vergleicht zwei Register mittels Subtraktion und setzt die Flags entsprechend.","tags":"rechnerarchitektur","title":"AVR Assembler"},{"url":"https://www.semiversus.com/dic/hardwarenahe_programmierung/avr_externer_interrupt.html","text":"Diese Seite beschreibt die externen Interrupts des ATMega16 Prinzipiell lässt sich diese Information auch auf andere Mikrocontroller der AVR Serie übertragen, es empfiehlt sich aber die Informationen mit dem entsprechenden Datenblatt zu vergleichen! Informationen im Datenblatt Die Informationen dieser Seite entstammen dem originalen Datenblatt (Rev. 2466T–AVR–07/10) des ATMega16 von Atmel. Seite 68-70 : Externe Interrupts Allgemeines Der ATMega16 hat drei Pins, die einen externen Interrupt auslösen können. Extern bedeuted in diesem Fall, dass die eigentliche Interruptquelle nicht innerhalb des Mikrocontrollers ist, sondern eben extern. Pinbelegung Die drei Pins sind in der folgenden Pinbelegung markiert. Externe Interrup Pins beim AVR (Quelle: Datenblatt ATMega16 © Atmel Corporation) INT0 - PORT D - Bit 2 INT1 - PORT D - Bit 3 INT2 - PORT B - Bit 2 (zusätzliche Mehrfachbelegung mit dem analogen Komperator) Bei entsprechender Konfiguration kann ein Interrupt ausgelöst werden, wenn sich der Pegel am entsprechenden Pin ändert. Register zur Konfiguration MCUCR Der Grund für das Auslösen eines Interrupts bei den beiden externen Interrupts INT0 und INT1 wird über das Register MCUCR (MCU Control Register) gesteuert. Bit|7|6|5|4| 3 | 2 | 1 | 0 :-:!|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-: Name|SM2|SE|SM1|SM0| ISC11 | ISC10 | ISC01 | ISC00 Read/Write|R/W|R/W|R/W|R/W| R/W | R/W | R/W | R/W Init|0|0|0|0| 0 | 0 | 0 | 0 Dazu haben wir vier verschiedene Konfigurationsmöglichkeiten für INT0 und INT1: ISCx1 ISCx0 Beschreibung 0 0 Löst bei logisch 0 Pegel aus 0 1 Löst bei deiner Pegeländerung aus (steigende oder fallende Flanke) 1 0 Löst bei fallende Flanke (Pegeländerung von logisch '1' auf '0') 1 1 Löst bei steigender Flanke (Pegeländerung von logisch '0' auf '1') MCUCSR Der externe Interrupt für INT2 wird über das Register MCUCSR (MCU Control and Status Register) gesteuert. Bit|7| 6 |5|4|3|2|1|0 :-:!|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-: Name|JTD| ICS2 |-|JTRF|WDRF|BORF|EXTRF|PORF Read/Write|R/W| R/W |R|R/W|R/W|R/W|R/W|R/W Init|0|0|0|-|-|-|-|- Ist ISC2 auf logisch 0 wird der Interrupt bei einer fallenden Flanke ausgelöst. Bei logisch 1 wird entsprechend bei einer steigenden Flanke ausgelöst. GICR Die Freigabe der Interrupts erfolgt über das Register GICR (General Interrupt Control Register). Bit| 7 | 6 | 5 |4|3|2|1|0 :-:!|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-: Name| INT1 | INT0 | INT2 |-|-|-|IVSEL|IVCE Read/Write| R/W | R/W | R/W |R|R|R|R/W|R/W Init| 0 | 0 | 0 |0|0|0|0|0 Die Bits INT0, INT1 und INT2 aktivieren die Interruptfreigabe. Für den Aufruf der entsprechenden Interruptrountine sind nun folgende Punkte notwendig: Das entsprechende Bit bei GICR ist gesetzt, damit der Interrupt freigegeben ist Über sei() wurde die globale Interruptfreigabe aktiviert (siehe Interrupts im Skriptum) Eine Pegeländerung entsprechend der Konfiguration unter MCUCR bzw. MCUCSR tritt beim entsprechenden Pin auf GIFR Über dieses Register kann das Statusflag beim entsprechenden Interrupt abgefragt werden. Dies ist notwendig, wenn die Detektion einer Pegeländerung genutzt werden soll, aber keine Interrupt Service Routine aufgerufen werden soll. Bit| 7 | 6 | 5 |4|3|2|1|0 :-:!|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-: Name| INTF1 | INTF0 | INTF2 |-|-|-|-|- Read/Write| R/W | R/W | R/W |R|R|R|R|R Init| 0 | 0 | 0 |0|0|0|0|0 Tritt die konfigurierte Pegeländerung auf wird das entsprechende INTFx Flag gesetzt. Zurückgesetzt wird das Flag, indem entwededer die Interrupt Service Routine aufgerufen wurde oder indem man eine logische 1 an das entsprechende Bit schreibt. Beispiel In diesem Beispiel wird folgendes konfiguriert: INT0 reagiert auf eine fallende Flanke und nutzt die entsprechende Interrupt Service Routine INT1 reagiert auf jeden Pegelwechsel und fragt den Zustand per Polling über das GIFR Register ab INT2 wird nicht genutzt Umsetzung: #include <avr/interrupt.h> ISR ( INT0_vect ) { // Interrupt Service Routine für INT0 // ... } int main ( void ) { MCUCR = 0x06 ; // entspricht 0b0000 01 10 -> INT0 löst bei fallender Flanke aus, INT1 bei jedem Pegelwechsel MCUCSR = 0x00 ; // entspricht 0b0 0 000000 -> INT2 löst bei fallender Flanke aus (wird aber nicht genutzt) GICR = 0x40 ; entspricht 0 b010 00000 -> INT0 Interrupt ist freigegeben , INT1 und INT2 nicht sei (); // globale Interruptfreigabe while ( 1 ) { // Hauptschleife if ( GIFR & 0x80 ) { // überprüfe Zustand von INT1 GIFR |= 0x80 ; // setze Flag für INT1 zurück // ... } // ... } return 0 ; }","tags":"hardwarenahe_programmierung","title":"Externe Interrupts beim Atmel AVR"},{"url":"https://www.semiversus.com/dic/hardwarenahe_programmierung/avr_interrupts.html","text":"Diese Seite beschreibt die Interrupts des ATMega16 Prinzipiell lässt sich diese Information auch auf andere Mikrocontroller der AVR Serie übertragen, es empfiehlt sich aber die Informationen mit dem entsprechenden Datenblatt zu vergleichen! Allgemeines Interrupts ermöglichen eine Unterbrechung des \"normalen\" Programmablaufs, um auf Änderungen zu reagieren. Polling Überlegen wir uns folgende Situation: Es ist 23 Uhr und wir müssen um 6:15 Uhr aufstehen. Neben unserem Bett steht eine Uhr. Wir haben nun die Möglichkeit einfach immer wieder auf diese Uhr zu schauen, um zu überprüfen, ob es mittlerweile 6:15 Uhr ist. Dies ist eine sehr stupide Herangehensweise und wir können nicht einfach einschlafen, da wir den Zeitpunkt nicht verpassen sollen. Wir können sehr wohl etwas anderes nebenbei machen, z.B. Lesen. Wir müssen aber immer wieder auf die Uhr schauen. Dieser Vorgang nennt sich Polling . Ein Mikrocontrollerprogramm prüft in jedem Hauptschleifendurchlauf, ob es zu einer Zustandsänderung gekommen ist. Dieses System hat einige Nachteile: Die Überprüfung benötigt Zeit und diese Zeit wird bei jedem Hauptschleifendurchlauf \"verbraucht\" Die Schlafmodies des Mikrocontrollers können nicht benutzt werden, um Strom zu sparen Zwischen zwei Überprüfungen benötigt die Hauptschleife Zeit für den Rest und es ist nur in diesen Abständen möglich zu prüfen Es gibt auch Vorteile: Es kann zu keinem Ressourcenkonflikt zwischen Interrupt und Hauptprogramm kommen Ein Interruptaufruf benötigt auch Zeit. Bei sehr kurzen Hauptschleifen kann Polling durchaus eine kürzere Reaktionszeit haben Es steht auch auf Systemen ohne Interrupts zur Verfügung Interrupts Im oben beschriebenen Beispiel mit der Uhr wäre ein Interrupt vergleichbar mit dem Alarm eines Weckers. Der Wecker kann auf 6:15 Uhr gestellt werden und wir können uns auf andere Tätigkeiten konzentrieren oder auch komplett Schlafen. Die Konfiguration des Weckers ist gut vergleichbar mit der Konfiguration von Interrupts. In einem Mikrocontroller gibt es fest vorgegebene Quellen für Interrupts. Der ATMega16 unterstützt etwa folgende Interrupts: INT0_vect - Externer Interrupt 0 INT1_vect - Externer Interrupt 1 INT2_vect - Externer Interrupt 2 TIMER2_COMP_vect - Timer/Counter 2 Compare Match TIMER2_OVF_vect - Timer/Counter 2 Overflow TIMER1_CAPT_vect - Timer/Counter 1 Capture Event TIMER1_COMPA_vect - Timer/Counter 1 Compare Match A TIMER1_COMPB_vect - Timer/Counter 1 Compare Match B TIMER1_OVF_vect - Timer/Counter 1 Overflow TIMER0_COMP_vect - Timer/Counter 0 Compare Match TIMER0_OVF_vect - Timer/Counter 0 Overflow SPI_STC_vect - Serial Transfer Complete USART_RXC_vect - USART Receive Complete USART_UDRE_vect - USART Data Register Empty USART_TXC_vect - USART Transmit Complete ADC_vect - ADC Conversion Complete EE_RDY_vect - EEPROM Ready ANA_COMP_vect - Analog Comparator TWI_vect - Two-Wire Interface (bzw. I²C) SPM_RDY_vect - Store Program Memory Ready Interrupt Service Routinen Eine Interrupt Service Routine ist der Programmcode der ausgeführt wird, wenn der Interrupt ausgelöst wurde. Diese wird im Sourcecode über das ISR() Makro definiert. Um auf dieses Makro und andere Interruptfunktionalitäten zuzugreifen, muss avr/interrupt.h inkludiert werden. Beispiel: #include <avr/interrupt.h> ISR ( ADC_vect ) { // Interrupt Service Routine für den Analog/Digitalwandler // Dieser Code wird beim Auslösen des Interrupts ausgeführt // ... } Einrichten eines Interrupts Damit ein Interrupt zur Ausführung kommt, werden folgende Punkte benötigt: Implementierung der Interrupt Service Routine Konfiguration der entsprechenden Register, um einen Interrupt für die entsprechende Komponente zu ermöglichen Aufruf von sei() im Hauptprogramm, um die globale Interruptfreigabe zu aktivieren Die Komponente kommt in einen Zustand, der den Interrupt auslöst (meist über ein Interrupt Flag ) Als Beispiel für einen einfachen Interrupt wird auf externe Interrupts verwiesen. Interrupt ohne Service Routine Wird eine Komponente so konfiguriert, dass sie einen Interrupt auslösen kann, die entsprechende Interruptroutine aber nicht vorhanden ist kommt es zu einem unerwarteten Ereignis: Der Mikrocontroller führt einen Neustart (Reset) durch. Interrupts, die keine eigene Service Routine haben führen die Serviceroutine BADISR_vect aus. Diese Routine führt einen Reset aus. Es ist möglich eine eigene Funktion für BADISR_vect zu definieren. Für große Projekte empfiehlt sich dies auch, da es schnell bei der Fehlersuche passieren kann, dass eine Service Routine gelöscht oder fälschlicherweise ein Interrupt freigegeben wird. Die Implementierung ist wie folgt möglich: ISR ( BADISR_vect ) { // Interrupt Service Routine für alle nicht definierten Interrupt Routinen // ... dies Funktion kann auch einfach leer bleiben }","tags":"hardwarenahe_programmierung","title":"Interrupts bei Atmel AVR"},{"url":"https://www.semiversus.com/dic/hardwarenahe_programmierung/avr_port_io.html","text":"Allgemeines Die interne Beschaltung jedes IO Port Pins beinhaltet folgende Komponenten: Schutzdioden gegenüber Masse und Versorgungsspannung (Überspannung bzw. ESD) Aktivierbarer Pull-Up Widerstand Aktivierbare Ausgangsstufe Eingänge besitzen Schmitt-Trigger und Synchronisierung AVR IO Pin (Quelle: Datenblatt ATMega16 © Atmel Corporation) Um von der Firmware aus auf einen IO Port Pin zuzugreifen, werden drei Register benötigt. Diese drei Register fassen jeweils 8 IO Pins zusammen. Die Gruppierung von 8 IO Pins wird auch Port genannt. Der ATMega16 hat 4 solcher Ports: Port A , B , C und D . Im folgenden wird statt des Portnamens ein x verwendet. PINx - das Eingangsregister Das Eingangsregister zeigt den aktuellen Zustand der Pins an. Der aktuelle Zustand wird auch eingelesen, wenn der Pin als Ausgang beschalten ist. Die notwendigen Pegel zur Detektion einer 0 oder 1 ist abhängig von Versorgungsspannung und Temperatur. DDRx - das Richtungsregister Das Data Direction Register legt fest, ob die jeweiligen Ausgangstreiber aktiv sind oder nicht. Bei aktivem Ausgangstreiber ( DDR -Bit auf 1 ) wird der Pegel des entsprechenden PORTx Registerbits auf den Ausgang gelegt. PORTx - das Ausgangsregister Bei aktivem Ausgangstreiber wird der Ausgang entsprechend diesem Bit gesteuert. Ist der Ausgangstreiber nicht aktiv, so wird mit diesem Register der Pull-Up aktiviert. Pin Konfiguration Mittels der Register DDRx und PORTx können folgende Konfigurationen eingestellt werden: DDRxn | PORTxn | I/O | Pull-Up | Kommentar -|-!|-|-|- 0 | 0 | Eingang | Nein | Hochohmiger Eingang (Tri-State) 0 | 1 | Eingang | Ja | Eingang mit Pull Up 1 | 0 | Ausgang | Nein | Ausgang Low 1 | 1 | Ausgang | Nein | Ausgang High","tags":"hardwarenahe_programmierung","title":"IO mittels AVR Portpins"},{"url":"https://www.semiversus.com/dic/hardwarenahe_programmierung/avr_pwm.html","text":"Inhalt folgt","tags":"hardwarenahe_programmierung","title":"Erzeugung einer PWM beim Atmel AVR"},{"url":"https://www.semiversus.com/dic/hardwarenahe_programmierung/avr_timer.html","text":"Diese Seite beschreibt die Timer des ATMega16 Prinzipiell lässt sich diese Information auch auf andere Mikrocontroller der AVR Serie übertragen, es empfiehlt sich aber die Informationen mit dem entsprechenden Datenblatt zu vergleichen! Informationen im Datenblatt Die Informationen dieser Seite entstammen dem originalen Datenblatt (Rev. 2466T–AVR–07/10) des ATMega16 von Atmel. Seite 71-86 : Timer0 (8 Bit) Seite 71 : Übersicht und Blockschaltbild Seite 76-80 : Betriebsmodi Seite 83-86 : Registerbeschreibung Seite 89-116 : Timer1 (16 Bit) Seite 89 : Übersicht und Blockschaltbild Seite 101-107 : Betriebsmodi Seite 110-116 : Registerbeschreibung Seite 117-134 : Timer2 (8 Bit) Seite 117 : Übersicht und Blockschaltbild Seite 122-125 : Betriebsmodi Seite 128-130 : Registerbeschreibung Anwendungen Je nach Anwendung liefert die folgende Übersicht eine Hilfestellung beim Einstellen der Register: Timer0 : PWM , Periodische Events , Zählen Timer1 : PWM , Periodische Events , Zählen , Zeiten messen Allgemeines Ein Timer ist ein spezieller Zähler, der Ereignisse zählt. Diese Ereignisse können sich auch vom Prozessortakt ableiten und von daher kommt die Bezeichnung Timer . Prinzipiell ist ein Timer für folgende Aufgaben geeignet: Zeiten zwischen zwei Ereignissen messen Nach einer bestimmten Zeit ein Ereignis auslösen Periodische Ereignisse auslösen Ereignisse zählen Erzeugung von PWM Signalen Diese Funktionalitäten werden in der Praxis sehr oft benötigt. Die universellen Einsatzmöglichkeiten haben allerdings den Nachteil, dass der Timer teilweise recht komplex in der Anwendung sein kann. Der ATMega16 enthält drei Timer. Timer 0 und 2 sind 8 Bit Timer, Time 1 ist ein 16 Bit Timer. Timer 0 (8 Bit Timer) Blockschaltbild des Timer 0 (Quelle: Datenblatt ATMega16 © Atmel Corporation) Das Blockschaltbild des Timer 0 zeigt den prinzipiellen Aufbau des Timers welcher im folgenden beschrieben wird. Interrupts Der Timer 0 nutzt zwei Interruptquellen: TIMER0_OVF_vect (im Blockschaltbild TOV0) - Löst aus, sobald es zu einem Überlauf des Timer Registers TCNT0 kommt TIMER0_COMP_vect (im Blockschaltbild OC0) - Löst aus, sobald das Timer Register TCNT0 gleich OCR0 ist TCNT0 - Timer Counter Register Dieses Register ist der Kern des Timers. Beim Timer 0 ist dieses Register 8 Bit groß, d.h. es kann von 0 bis 255 zählen. TCNT0 kann direkt gelesen und geschrieben werden. Die Steuerung (Control Logic) hat die Möglichkeit, dieses Register auf 0 zu setzen oder das Register um eins zu erhöhen oder zu erniedrigen. Die Steuerung ist abhängig von der Konfiguration über TCCR0 und dem Status der Vergleiche mit 0, mit 0xFF und dem Vergleich mit OCR0 . OCR0 - Vergleichsregister Das Register OCR0 ist ein 8 Bit Register das für den Vergleich mit TCNT0 genutzt wird. Der Vergleich kann für drei Funktionen benutzt werden: Die Generierung eines PWM Signals mittels Waveform Generetion am Pin OC0 Das Auslösen des Interrupts TIMER0_COMP_vect bei Äquvivalenz mit TCNT0 Die Auswertung mittels der Steuerung des Timer 0 TCCR0 - Timer Counter Control Register Bit|7|6|5|4|3|2|1|0 :-:!|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-: Name|FOC0|WGM00|COM01|COM00|WGM01|CS02|CS01|CS00 Read/Write|W|R/W|R/W|R/W|R/W|R/W|R/W|R/W Init|0|0|0|0|0|0|0|0 FOC Spezielles Bit zur Ausführung eines Compare Match in nicht PWM Modi. Für weitere Informationen dazu ist im Datenblatt nachzulesen. WGM01 und WGM00 - Betriebsmodi Diese beiden Bits beschreiben die Betriebsmodi des Timers: Modus|WGM01|WGM00|Bezeichnung -!|-|-!|- 0|0|0|Normaler Modus 1|0|1|PWM, Phasenkorrekt 2|1|0|CTC 3|1|1|Fast PWM Die verschiedenen Modi sind unter \" Betriebsmodi \" ausführlich beschrieben. COM01 und COM00 - Funktion des OC0 Pins Beschreibt die Funktionsweise des Pins OC0 . Sind beide Bits auf 0 wird der Pin als normaler Portpin verwendet (Port B Bit 3). Bei anderen Kombinationen ist der Compare Match Output Mode aktiv und die normale Portfunktion wird überschrieben. Weitere Informationen finden sich unter PWM Erzeugung . CS02, CS01 und CS00 - Clock Select CS02|CS01|CS00|Bezeichnung -|-|-!|- 0|0|0|Kein Takt (Timer ist quasi abgeschaltet) 0|0|1|Prozessortakt 0|1|0|Prozessortakt / 8 0|1|1|Prozessortakt / 64 1|0|0|Prozessortakt / 256 1|0|1|Prozessortakt / 1024 1|1|0|Fallende Flanke an Pin T0 1|1|1|Steigende Flanke an Pin T1 TIMSK - Timer Interrupt Mask Register Über das Timer Interrupt Mask Register werden die Interruptfreigaben für alle drei Timer gesetzt. Für den Timer0 gibt es wie bereits beschrieben die beiden Interrupts TOIE0 (Timer Overflow) und OCIE0 (Output Compare Match). Um den jeweiligen Interrupt zu aktivieren muss eine logische 1 an die entsprechende Stelle geschrieben werden. Bit|7|6|5|4|3|2| 1 | 0 :-:!|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-: Name|OCIE2|TOIE2|TICIE1|OCIE1A|OCIE1B|TOIE1| OCIE0 | TOIE0 Read/Write|R/W|R/W|R/W|R/W|R/W|R/W| R/W | R/W Init|0|0|0|0|0|0| 0 | 0 Betriebsmodi Normaler Modus Bei diesem Modus zählt der Timer bis zum Maximum seines Zählbereiches (255 bzw. 65535). Der Timer kann so konfiguriert werden, dass beim Erreichen dieses Maximums der TIMERn_OVF_vect ausgelöst wird. Die Frequenz, mit der ein Overflow bei Verwendung des Prozessortakts als Taktquelle auftritt ergibt sich mit: %%f_{TOVF}=\\frac{f_{CLK}}{Prescaler\\cdot N_{max}}%% Als Prescaler stehen dabei 1, 8, 64, 256 und 1024 zur Verfügung. %%N_{max}%% ist dabei 256 für 8 Bit Timer und 65536 für 16 Bit Timer. Der Interrupt TIMERn_COMPx_vect kann aktiviert werden und wird ausgelöst, sobald das Timerregister TCNTn den Vergleichswert OCRn erreicht. CTC - Clear Timer on Compare Hier zählt der Timer nach oben bis zum Erreichen des OCRn Registers. Das Register TCNTn wird beim Erreichen zurückgesetzt. Der Timer kann so konfiguriert werden, dass beim Erreichen des OCRn Wertes der TIMERn_COMPx_vect ausgelöst wird. Die Frequenz, mit der ein Compare Match bei Verwendung des Prozessortakts als Taktquelle auftritt ergibt sich mit: %%f_{COMP}=\\frac{f_{CLK}}{Prescaler\\cdot (OCRn + 1)}%% Fast PWM Beim Fast PWM zählt der Timer bis zum Maximum seines Zählberreichs. Das Register OCRn dient als Vergleich und abhängig davon, ob TCNTn kleiner oder größer OCRn ist, kann der OCn Pin auf logisch 0 oder 1 gesetzt werden. Mehr dazu im Kapitel PWM Erzeugung . PWM, Phasenkorrekt Siehe auch hier im Kapitel PWM Erzeugung . Pins Pins mit Timerfunktionalität (Quelle: Datenblatt ATMega16 © Atmel Corporation)","tags":"hardwarenahe_programmierung","title":"Timer beim Atmel AVR"},{"url":"https://www.semiversus.com/dic/hardwarenahe_programmierung/avr_uart.html","text":"Diese Seite beschreibt die UART des ATMega16 Prinzipiell lässt sich diese Information auch auf andere Mikrocontroller der AVR Serie übertragen, es empfiehlt sich aber die Informationen mit dem entsprechenden Datenblatt zu vergleichen! Informationen im Datenblatt Die Informationen dieser Seite entstammen dem originalen Datenblatt (Rev. 2466T–AVR–07/10) des ATMega16 von Atmel. Seite 144-145 : Blockschaltbild und allgemeine Information Seite 163-167 : Registerbeschreibung Seite 167-171 : UART Baudrateregister und Beispiele für Baudrates Allgemeines Um eine serielle Schnittstelle (siehe RS232 ) zu realisieren stellt der Atmel AVR eine USART (engl. für Universal Synchronous and Asynchrouns Serial Receiver and Transmitter ) zur Verfügung. Zur Arbeit mit dem USART werden fünf Register genutzt: Drei Konfigurations und Statusregister UCSRA , UCSRB und UCSRC (für UART Control and Status Register A, B und C) Das Baudrateregister UBRR für die Erzeugung des Übertragungstaktes Das Datenregister UDR (engl. für UART Data Register ) zum Senden und Empfangen der einzelnen Bytes Außerdem stehen drei mögliche Interrupts für die UART zur Verfügung: Receive Complete ( USART_RX_vect ) - signalisiert ein empfangenes Byte empfangen wurde Transmit Complete ( USART_TX_vect ) - signalisiert ein vollständig gesendetes Byte (inklusive Stopbit) UART Data Register Empty ( USART_UDRE_vect ) - signalisert einenen freien Sendebuffer Die Konfigurations- und Statusregister sowie die Interrupts werden im folgenden näher erläutert. AVR UART (Quelle: Datenblatt ATMega16 © Atmel Corporation) Konfigurations- und Statusregister USARTA Bit|7|6|5|4|3|2|1|0 :-:!|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-: Name|RXC|TXC|UDRE|FE|DOR|PE|U2X|MPCM Read/Write|R|R/W|R|R|R|R|R/W|R/W Init|0|0|1|0|0|0|0|0 RXC - Receive Complete Dieses Flag wird auf 1 gesetzt, wenn ein neues Byte im UDR zur Verfügung steht (empfangen wurde). Sobald UDR gelesen wird, wird das Flag auf 0 gesetzt. Dieses Flag löst den Receive Complete Interrupt aus, sofern dieser aktiviert ist. TXC - Transmit Complete Das Flag wird auf 1 gesetzt, wenn ein komplettes Frame (inklusive Stopbit) gesendet wurde. Dieses Flag wird gelöscht, wenn der Transmit Complete Interrupt aufgerufen wird oder kann direkt gelöscht werden, indem das Flag mit einer 1 geschrieben wird. Dieses Flags löste den Transmit Complete Interrupt aus, sofern dieser aktiviert ist. UDRE - USART Date Register Empty Dieses Flag ist auf 1 , wenn das Senderegister (wieder) leer ist. Dieses Flag löst den USART Date Register Empty Interrupt aus, sogern dieser aktiviert ist. Das Flag liefert 0 , sobald auf UDR geschrieben wird. Nach dem Reset ist dieses Flag 1 , um das leere UDR zu signalisieren. FE - Frame Error Wurde beim Empfang das Stopbit falsch empfangen (sollte logisch 1 entsprechen) wird dieses Flag gesetzt. Das Flag wird zurückgesetzt sobald UDR gelesen wird. DOR - Data OverRun Ein Data OverRun tritt auf, wenn ein Byte empfangen wurde, der Empfangsbuffer aber vollgelaufen ist ( UDR wurde nicht ausgelesen). Sobald dies eintritt, wird das Flag auf 1 gesetzt. Zurückgesetzt wird es mit dem Lesen von UDR . PE - Parity Error Wenn der Paritätscheck eingeschalten ist und das Paritätsbit der Übertragung nicht mit der Berechnung über die Datenbits zusammen stimmt wird dieses Flag auf 1 gesetzt. Zurückgesetzt wird es mit dem Lesen von UDR . U2X - USART Double Speed Bestimmt den Teiler für die Baudrategenerierung. 0 für Teiler 16 und 1 für Teiler 8. Näheres dazu unter Baudrate Generierung . MPCM - Multiprocessor Communication Mode Spezieller Modus um eine Filterung von Frames mit Adressinformationen vorzunehmen. Wird in der Praxis äußerst selten benutzt. Für weitere Informationen dazu ist im Datenblatt nachzulesen. USARTB Bit 7 6 5 4 3 2 1 0 Name RXCIE TXCIE UDRIE RXEN TXEN UCSZ2 RXB8 TXB8 Read/Write R/W R/W R/W R/W R/W R/W R R/W Init 0 0 0 0 0 0 0 0 RXCIE - Receive Complete Interrupt Enable Um den Interruptvektor zu aktivieren, muss dieses Flag auf 1 sein. Der entsprechende Interruptvektor heißt USART_RX_vect . TXCIE - Transmit Complete Interrupt Enable Um den Interruptvektor zu aktivieren, muss dieses Flag auf 1 sein. Der entsprechende Interruptvektor heißt USART_TX_vect . UDRIE - UART Data Register Empty Interrupt Enable Um den Interruptvektor zu aktivieren, muss dieses Flag auf 1 sein. Der entsprechende Interruptvektor heißt USART_UDRE_vect . RXEN - Receive Enable Dieses Flag muss auf 1 sein, um den Empfänger der UART einzuschalten. RXEN - Transmit Enable Dieses Flag muss auf 1 sein, um den Sender der UART einzuschalten. USARTC Bit 7 6 5 4 3 2 1 0 Name URSEL UMSEL UPM1 UPM0 USBS UCSZ1 UCSZ0 UCPOL Read/Write R/W R/W R/W R/W R/W R/W R R/W Init 1 0 0 0 0 1 1 0 Baudrate Generierung Zur Generierung der Baudrate gilt folgende Formel: %%f_{Baudrate}=\\frac{f_{CLK}}{16\\cdot(UBRR+1)} \\Leftrightarrow UBRR=\\frac{f_{CLK}}{16\\cdot f_{Baudrate}}-1%% Diese Formel gilt wenn das U2X in UCSRA gleich 0 ist. Für U2X gleich 1 gilt folgende Formel: %%f_{Baudrate}=\\frac{f_{CLK}}{8\\cdot(UBRR+1)} \\Leftrightarrow UBRR=\\frac{f_{CLK}}{8\\cdot f_{Baudrate}}-1%%","tags":"hardwarenahe_programmierung","title":"Die UART des Atmel AVR"},{"url":"https://www.semiversus.com/dic/robotik/python/beispiele.html","text":"Beispiel 1 Starten wir direkt mit einem Beispiel, welches über Hello, World! hinausgeht. Was macht das folgende Programm? Was fällt auf im Vergleich zu anderen Programmiersprachen? word_list = [ 'Warthog' , 'Hedgehog' , 'Badger' , 'Drake' , 'Eft' , 'Fawn' , 'Gibbon' ] VOWELS = 'aeiou' result_string = '' result_number = 0 for word in word_list : vowels_number = 0 for letter in word : if letter in VOWELS : vowels_number += 1 if vowels_number > result_number : result_number = vowels_number result_string = word print ( result_string ) Beispiel als Download Das Programm iteriert über eine Liste mit Wörtern und findet das Wort mit den meisten Selbstlauten. Was fällt im Vergleich zu anderen Programmiersprachen auf? Python nutzt dynamische Typisierung (d.h. beim Einführen von Variablen muss kein Datentyp angegeben werden) Es werden keine Klammern für Blöcke benötigt. Sie werden durch Einrückungen definiert Beispiel2 Zum Ausprobieren gibt es das Beispiel auch hier: Online Python Beispiel from random import randint UPPER_NUMBER_LIMIT = 100 number_to_guess = randint ( 1 , UPPER_NUMBER_LIMIT ) guessed_number = None print ( 'I will choose a number between 1 and ' + str ( UPPER_NUMBER_LIMIT ) + '.' ) while number_to_guess != guessed_number : user_input = input ( 'What number are you guessing? number: ' ) guessed_number = int ( user_input ) if guessed_number > number_to_guess : print ( 'Your guessed number is too high!' ) elif guessed_number < number_to_guess : print ( 'Your guessed number is too low!' ) print ( 'You guess was correct!' ) Aufgaben Füge eine Anzeige hinzu, wieviele Versuche notwendig waren. Dies sollte dann in etwa so aussehen: You guess was correct! It took 3 attempts. Füge eine Abfrage des oberen Limits ein. Dazu sollte folgende Abfrage am Anfang erscheinen: What should be the upper limit? number:","tags":"python","title":"Erstes Beispiel"},{"url":"https://www.semiversus.com/dic/halbleiterelemente/bipolarer_transistor.html","text":"Allgemeines Bei einem Bipolartransistor (engl. bipolar junction transistor oder kurz BJT ) werden negativ geladene Elektronen sowie positiv geladene Defektelektronen zum Ladungsträgertransport durch den Transistor genutzt. Dies steht im Gegensatz zum unipolaren Transistor (auch Feldeffekttransistor), bei dem immer nur eine Ladungsträgerart am Ladungsträgertransport durch den Transistor beteiligt ist. Auch wenn der Feldeffekttransistor wesentlich früher theoretisch beschrieben wurde, war es der Bipolartransistor, der ab den 50er Jahren zu einer Revolution der Miniaturisierung geführt hat. Ein wichtiges Grundkonzept bei der Arbeit mit Transistoren ist der Umgang mit Modellen. Je nach verwendetem Modell lassen sich bestimmte Vorgänge einfach erklären, andere wiederum nicht. Dazu ist es erforderlich die Modelle zu verstehen und auch zu wissen, für welche Anwendung man welches Modell heranzieht. Im folgenden lernen wir die wesentlichen Modelle kennen: Das Halbleitermodell, das vereinfachte Ersatzschaltbild, das statische Kleinsignal Ersatzschaltbild sowie die Arbeit mit dem Kennlinienfeld. Halbleitermodell Der Bipolartransistor besteht aus drei abwechselnden Schichten aus p- und n-dotierten Halbleiterschichten. Daher spricht man auch von NPN- und PNP-Transistoren. Die drei Bereiche werden Kollektor (C), Basis (B) und Emitter (E) genannt. Die Basis ist besonders dünn und liegt zwischen Emitter und Kollektor. Kollektor und Emitter sind unterschiedlich stark dotiert. Dieser asymmetrische Aufbau bewirkt ein unterschiedliches Verhalten im Normal- und Inversbetrieb. Die beiden pn-Übergänge lassen sich auch als Dioden darstellen, wobei sich aus diesem Dioden Modell nicht die Funktionsweise ableiten lässt. Im folgenden Bild sieht man die Schaltsymbole und den Aufbau symbolisiert durch zwei Dioden. Schaltbilder (Bild: Biezl Gemeinfrei) Aufbau Aufgrund von Optimierungen sind Bipolartransistoren heutzutage aus mehr als drei Schichten aufgebaut, die zusätzlichen Schichten sind nicht in Form von weiteren p-n-Übergängen zusammengesetzt, sondern die drei Hauptschichten sind in Zonen unterschiedlicher Dotierungsdichte gegliedert. Die Kollektorzone besteht hierbei immer aus mindestens zwei unterschiedlich stark dotierten Zonen. Die Bezeichnungen npn und pnp beziehen sich nur auf den aktiven inneren Bereich, jedoch nicht den tatsächlichen Aufbau. Schematischer Aufbau eines NPN Transistors (Bild: Inductiveload Gemeinfrei) Paare von npn- und pnp-Transistoren nennt man komplementär, wenn deren elektrische Daten bis auf das Vorzeichen ähnlich sind. Solche auf gute Übereinstimmung der Parameter selektierte „Transistorpärchen\" (entscheidend sind Stromverstärkung sowie Basis-Emitterspannung) werden z. B. in sogenannten Gegentaktschaltungen wie Verstärker-Endstufen eingesetzt, um Verzerrungen niedrig zu halten. Sind große Ströme gefordert, können mehrere Transistoren parallelgeschaltet werden. Die Übereinstimmung deren Parameter ist hier ebenfalls wichtig, dennoch muss durch Emitterwiderstände dafür gesorgt werden, dass sich die Ströme gleichmäßig auf alle parallelen Transistoren aufteilen. Funktionsweise NPN Halbleitermodell (Bild: Inductiveload Gemeinfrei) Beim Bipolartransistor im analogen / linearen Betrieb wird durch einen elektrischen Strom %%I_{B}%% zwischen Basis und Emitter ein stärkerer Strom %%I_{C}%% zwischen Kollektor und Emitter gesteuert. Das Verhältnis der beiden Ströme, das im Bereich von etwa 4 bis 1000 liegt, ist vom Transistortyp und vom Absolutbetrag des Kollektorstromes abhängig und wird als statischer Stromverstärkungsfaktor %%B%% bezeichnet. Dieses Verhalten ist vergleichbar mit einem flussabhängigen Ventil bei einem Wasserkanal-Modell. Dieses Modell ist stark vereinfacht und dient nur zur generellen Veranschaulichung der fließenden Ströme, da für die Erklärung der realen Verhältnisse und der Funktionsweise des Bipolartransistors sowohl Elektronen als auch Defektelektronen (Löcher) verantwortlich sind. Ein Bipolartransistor wird durch drei Schichten unterschiedlicher Dotierung gebildet, die zwei p-n-Übergänge bilden. Die in der Mitte befindliche Basiszone ist die dünnste Schicht. Im Folgenden wird am Beispiel eines npn-Transistors die generelle Funktionsweise eines Bipolartransistors im Vorwärtsbetrieb (%%U_{BE}>0%%, %%U_{CB}>0%%) dargestellt. Werden nur Kollektor und Emitter angeschlossen (Spannung %%U_{CE}>0%%), entspricht dies schaltungstechnisch zwei entgegengesetzt geschalteten Dioden, von denen eine (die Basis-Kollektor-Diode) immer gesperrt ist. Es fließt nur ein kleiner Strom, der betragsgleich mit dem Sperrstrom der Basis-Kollektor-Diode ist. Die angelegte Spannung verkleinert zwar die Basis-Emitter-Sperrschicht, die Raumladungszone (RLZ) zwischen Basis und Emitter, vergrößert jedoch die Basis-Kollektor-Sperrschicht. Durch Schließen des Basis-Emitter-Stromkreises (Spannung %%U_{BE}>U_{D}%% (%%U_{D}%% entspricht der Diffusionsspannung), für Silizium %%U_{BE}>0,7V%%) wird die Basis-Emitter-Diode leitend. Wie bei der einfachen pn-Diode werden Defektelektronen aus der Basis (p-dotiert) in den Emitter (n-dotiert) injiziert (engl. inject). Es fließt ein kleiner Basisstrom %%I_{BE1}%%. Im Emittergebiet klingt der Minoritätsladungsträgerüberschuss, in diesem Fall Defektelektronen, mit der Diffusionslänge ab, die Defektelektronen rekombinieren mit den Elektronen. Analog dazu werden Elektronen aus dem Emitter (lat. emittere = aussenden) in die Basis injiziert. Aufgrund der geringen Weite der Basis, die kleiner als die Diffusionslänge der Ladungsträger sein muss, rekombinieren jedoch nur wenige der Elektronen mit den Defektelektronen. Die meisten Elektronen (ca. 99 %) diffundieren durch die Basis in die Kollektor-Basis-Sperrschicht, der Basis-Kollektor-Übergang wird in Sperrrichtung betrieben. Dort driften sie wegen des großen Potentialabfalls (%%U_{CB}>0%%) in den Kollektor (lat. colligere = sammeln). In Form des Kollektorstroms IC fließen somit Elektronen vom Emitter in den Kollektor. Die Anzahl der in das Basisgebiet injizierten Elektronen bzw. der in den Emitter injizierten Defektelektronen ändert sich mit der Flussspannung UBE der Basis-Emitter-Diode. Obwohl nur eine verhältnismäßig kleine Anzahl an Elektronen in der Basis rekombinieren, ist dieser Teil für die Funktion des Bipolartransistors wesentlich. Eine große Anzahl von Elektronen erhöht die Wahrscheinlichkeit, dass ein Elektron auf ein Loch trifft und rekombiniert. Die rekombinierenden Defektelektronen werden über den Basiskontakt in Form eines Teils des Basisstroms nachgeliefert. Durch Ändern des Basisstromes %%I_{B}%% kann demzufolge der Kollektoremitterstrom %%I_{C}%% gesteuert werden. Es wird durch den kleinen Basisstrom, verursacht durch die Defektelektronen, ein viel größerer Kollektorstrom (Elektronenstrom) gesteuert. Spannungen und Ströme am NPN Transistor (Bild: Cepheiden GNU FDL 1.0) Die Wirkungsweise eines pnp-Transistors ist dazu analog, jedoch sind die Vorzeichen umzudrehen, um der entgegengesetzten Dotierung der beiden Sperrschichten Rechnung zu tragen. Vereinfachtes Ersatzschaltbild Vereinfachtes Ersatzschaltbild (Bild: Biezl Gemeinfrei) Das einfachste Modell besteht aus der Basis-Emitter-Diode und der durch den Basisstrom %%I_{B}%% gesteuerten Stromquelle (genauer gesagt einer Stromsenke, da keine Energieerzeugung erfolgt) hin zum Kollektor %%I_{C}%%. Der Transistor verstärkt den Basisstrom um den Faktor %%B%%. Voraussetzungen für die Gültigkeit des Modells sind: Die Basis-Emitter-Diode muss in Durchlassrichtung gepolt sein und die Basis-Kollektor-Diode in Sperrrichtung. Dieses vereinfachte Modell leitet sich aus dem Ebers-Moll-Modell ab und vereinfacht dieses durch Vernachlässigung von Sperrströmen und dynamischen Effekten. Die grundlegensde Eigenschaft der Verstärkung ergibt sich in diesem Modell durch %%I_{C}=I_{B} \\cdot B_{N}%%, wobei %%B_{N}%% die Verstärkung im Normalbetrieb ist. Eine Anwendung des vereinfachten Ersatzschaltbildes ist zum Beispiel der Betrieb des Transistors als Schalter (wobei hier nicht das dynamische Verhalten beschrieben werden kann). Statisches Kleinsignal Ersatzschaltbild Kleinsignal Ersatzschaltbild (Bild: Biezl Gemeinfrei) Das statische Kleinsignalmodell beschreibt das Kleinsignalverhalten bei niedrigen Frequenzen und wird deshalb auch als Gleichstrom-Kleinsignalersatzschaltbild (oder kurz GS-KSESB ) bezeichnet. Die Ermittlung der Parameter erfolgt im Arbeitspunkt also unter definierten Randbedingungen. Der differentielle Widerstand der Basis-Emitter-Strecke %%r_{BE}%% entspricht der Tangente zur Diodenkennlinie für den Arbeitspunkt. Der differentielle Kollektor-Emitter-Widerstand %%r_{CE}%% entspricht der Steigung der Ausgangskennlinie bedingt durch den Early-Effekt. Der differentielle Stromverstärkungsfaktor β vervollständigt die Beschreibung des elektrischen Verhaltens. (Der Datenblattwert %%h_{FE}%% entspricht dabei β.) Unmittelbar mit dem Kleinsignalmodell verwandt sind die Vierpolparameter des Transistors. Das Großsignalmodell umfasst den gesamten Spannungsbereich, der für das betrachtete Bauteil zulässig ist. Das Kleinsignalmodell gilt nur in einem eng begrenzten Bereich um den Arbeitspunkt. Eine weitere Unterteilung erfolgt in statische und dynamische Modelle. Letztere sind komplexer, denn sie berücksichtigen die kapazitiven Eigenschaften der Sperrschichten und eignen sich daher für mittlere bis hohe Frequenzen. Für das Kleinsignalersatzschaltbild gilt: %%u_{BE} = i_{B} \\cdot r_{BE}%% %%i_{C} = \\beta \\cdot i_{B} + \\frac{1}{r_{CE}} \\cdot u_{CE}%% Um die differentiellen Werte %%r_{BE}%%, %%r_{CE}%% und %%\\beta%% zu erhalten bedient man sich dem Kennlinienfeld des Transistors. Kennlinienfeld Kennlinienfelder dienen der grafischen Darstellung zweier oder mehrerer voneinander abhängiger physikalischen Größen. Sie dienen zur Charakterisierung und Veranschaulichung der elektrischen Eigenschaften/Verhalten des Bauelements. Für die Beschreibung eines Bipolartransistors (als elektrischen Schalter oder in Verstärkerschaltungen) reichen vier grundlegende Kennlinien aus: das Eingangs-, das Ausgangs-, das Stromsteuer- und das Spannungsrückwirkungskennlinienfeld. Werden die Kennlinien gemeinsam dargestellt spricht man auch von Vierquadrantenkennlinienfeld. Kennlinienfeld (Bild: Biezl Gemeinfrei) Beim Eingangskennlinienfeld wird der Basisstrom %%I_{B}%% gegen die Basisspannung %%U_{BE}%% aufgetragen. Da es sich hierbei nur um den Basis-Emitter-pn-Übergang handelt, entspricht die Kennlinie der einer pn-Diode. Das Ausgangkennlinienfeld stellt die Abhängigkeit des Kollektorstroms %%I_{C}%% von der Kollektor-Emitterspannung %%U_{CE}%% bei ausgewählten Basissteuerströmen %%I_{B}%% dar. Beim Stromsteuerkennlinienfeld (auch Übertragungskennlinienfeld) wird die Abhängigkeit des Kollektorstroms %%I_{C}%% vom ansteuernden Basisstrom %%I_{B}%% bei konstanter Kollektor-Emitterspannung %%U_{CE}%% dargestellt. In der Regel hat sie den Verlauf einer Geraden (annähernd linear) durch den Ursprung, wobei die Steigung dem Stromverstärkungsfaktor %%\\beta%% entspricht. Das Spannungsrückwirkungskennlinienfeld (auch Rückwirkungskennlinienfeld genannt) stellt die Rückwirkung der Ausgangsspannung %%U_{CE}%% auf den Eingang (Basis bzw. Basisspannung %%U_{BE}%%) dar. Arbeitsbereiche Der Bipolartransistor besteht aus zwei pn-Übergängen. Indem man entsprechende Spannungen anlegt, kann man beide Übergänge unabhängig voneinander sperren oder durchschalten. Dadurch ergeben sich vier mögliche Arbeitsbereiche, in denen der Transistor ein je eigenes Verhalten zeigt. Sperrbereich Im Sperrbereich (engl. cut-off region) oder Sperrbetrieb sperren beide Übergänge, d. h. die Kollektor- und die Emitterdiode. In diesem Betriebszustand leitet der Transistor theoretisch keinen Strom. Der Transistor entspricht damit einem geöffneten Schalter. Praktisch fließt auch im Sperrbetrieb ein geringer Strom, der Transistor im Sperrbetrieb stellt also einen nichtidealen Schalter dar. Verstärkungsbereich Der Verstärkungsbereich (engl. forward region) tritt im sogenannten Normalbetrieb auf. Hierbei wird die Emitterdiode in Flussrichtung und die Kollektordiode in Sperrrichtung betrieben. Im Verstärkungsbereich gilt näherungsweise die Formel %%I_{C}=\\beta \\cdot I_{B}%%. Da %%\\beta%% relativ groß ist, führen hier kleine Änderungen des Basisstroms %%I_{B}%% zu großen Änderungen des Kollektorstroms %%I_{C}%%. Transistoren werden in diesem Bereich betrieben, um Signale zu verstärken. Im Normalbetrieb wird der Transistor üblicherweise nur in dem Bereich betrieben, in dem die Verstärkung näherungsweise linear gemäß obiger Formel verläuft. Sättigungsbereich Der Sättigungsbereich wird auch Sättigungsbetrieb oder Sättigung genannt. Beide pn-Übergänge leiten, in der Basiszone befinden sich jedoch mehr Ladungsträger als für den Kollektorstrom benötigt werden. Der Kollektorstrom %%I_{C}%% ist unabhängig vom Basisstrom %%I_{B}%%. Der Transistor entspricht einem geschlossenen Schalter mit konstantem Durchgangswiderstand (Linker Bereich im Ausgangskennlinienfeld). Sofern sich der Arbeitspunkt eines Linearverstärkers nicht weit genug entfernt vom Sättigungsbereich befindet oder die Amplitude des Signals zu hoch ist, tritt Übersteuerung ein, der Verstärker begrenzt das Signal und es treten Verzerrungen auf. Das Sperren der Basis-Kollektor-Strecke verzögert sich, da erst alle überschüssigen Ladungsträger aus der Basiszone abfließen müssen. Quasi-Sättigungsbereich Dieser Bereich liegt zwischen Verstärkungsbereich und Sättigungsbereich. Der Transistor wird nicht gesättigt betrieben, wodurch sich Ausschaltzeit und damit die Ausschaltverlustleistung gegenüber dem Betrieb in vollständiger Sättigung deutlich vermindern, was für Schalt-Anwendungen wichtig ist. Erkauft wird dieser Vorteil jedoch durch höhere Durchlassverluste, da die Durchlassspannung um ca. 0,4 V höher liegt. Inverser Verstärkungsbereich Der inverse Verstärkungsbereich (engl. reverse region) wird auch Inversbetrieb genannt. Dabei werden der Basis-Kollektor-Übergang in Durchlassrichtung und der Basis-Emitter-Übergang in Sperrrichtung betrieben. Dieser Bereich funktioniert ähnlich wie der normale Verstärkungsbereich, jedoch mit umgekehrten Vorzeichen der Spannungen. Der Stromverstärkungsfaktor ist deutlich kleiner. Die maximale Sperrspannung der Basis-Emitterdiode beträgt nur einige Volt.","tags":"halbleiterelemente","title":"Bipolarer Transistor"},{"url":"https://www.semiversus.com/dic/halbleiterelemente/bipolarer_transistor_schalter.html","text":"Allgemeines Eine typische Anwendung für Transistoren ist das Schalten von Lastströmen. Der einfachste Fall ist eine Last, die keinen Bezug zum Massepontential braucht. Dies nennt man Low-Side schalten. Low-Side Schalter Für dieses Beispiel wird ein TIP31A (NPN Transistor %%I_{C Max}%%=3A, %%U_{CE Max}%%=60V) verwendet. Für die Auswahl des Transistors und der Berechnung von %%R_B%% müssen zwei Fälle betrachtet werden. Der ausgeschaltete und der eingeschaltete Zustand. Ausgeschalteter Zustand Bei der Auswahl des Transistors ist es wichtig, dass die im ausgeschalteten Zustand anliegende Spannung %%V+%% an Kollektor und Emitter nicht zu einer Beschädigung führt. Im Datenblatt ist diese Maximale Spannung von %%U_{CE}%% meist mit %%U_{CE0}%% bzw. %%V_{CE0}%% beschrieben. Für den gegebenen Transistor ist diese Spannung 60V, d.h. die Betriebsspannung darf nicht höher 60 Volt sein. Ein zweiter Punkt der meist kein Problem darstellt ist der Abschaltstrom des Transistors. Wenn durch die Basis kein Strom fließt, aber eine Spannung %%U_{CE}%% anliegt so ist der Strom %%I_C%% nicht 0 sondern es fließt ein sehr kleiner Abschaltstrom . Dieser findet sich im Datenblatt meist unter %%I_{CE0}%% bzw. Collector Cutoff Current . Eingeschalteter Zustand Im eingeschaltenen Zustand ist die Spannung %%U_{CE}%% am Transistor sehr klein. Der ausgewählte Transistor muss hier zwei Eigenschaften besitzen: Der Strom durch den Kollektor muss kleiner %%I_{C Max}%% sein Die abfallende Leistung am Transistor muss kleiner %%P_{D}%% ( Power Dissipation , je nach Kühlung) sein Wird der Transistor voll durchgesteuert entspricht die Spannung %%U_{CE}%% der Sättigungsspannung %%U_{CE Sat}%%. Die Sättigungspsannung ist stark abhängig von Temperatur, Übersteuerungsfaktor und dem Strom %%I_C%%. Sie wird über Kennlinien im Datenblatt ermittelt. Für kleine Ströme %%I_C%% (<100mA) wird sie oft mit 0.1 Volt angenommen. Die Verlustleistung am Transistor besteht aus zwei Komponenten: Über die Basis fließt der Basisstrom, wobei die Basisspannung %%U_{BE}%% abfällt Über den Kollektor fließt der Kollektorstrom, wobei die Sättingungsspannung abfällt Daraus ergibt sich für die Gesamtleistung %%P_{Transistor}=I_B \\cdot U_{BE} + I_C \\cdot U_{CE Sat}%%. Da der Anteil über die Basisdiode viel kleiner ist gilt %%P_{Transistor} \\approx I_C \\cdot U_{CE Sat}%%. Berechnung des Basiswiderstand Vereinfachtes Ersatzschaltbild (Bild: Biezl Gemeinfrei) Um den Basiswiderstand zu berechnen hilft das vereinfachte Ersatzschaltbild des Transistors. Dieses zeigt für die Basis einen Spannungsabfall über eine Diode. Der Kollektorstrom %%I_C%% wird durch eine Stromquelle dargestellt, welche mittels %%I_C=B_N \\cdot I_B%% gesteuert wird. Würde man nun %%I_B%% mittels %%I_C/B%% berechnen, würde der Transistor gerade so durchgeschaltet, dass der Kollektorstrom fließen kann. Bauteilstreuungen und ein großer Umgebungstemperaturbereich führen dazu, dass der Transistor in vielen Fällen nicht durchgesteuert sein wird. Um dies sicherzustellen wird ein Übersteuerungsfaktor genutzt. Dabei wird der berechnete Basisstrom einfach um einen Faktor höher angenommen als er idealerweise sein müsste. Für die Berechnung wird zuerst der Basisstrom ausgerechnet, um dann den Widerstand %%R_B%% ermitteln zu können: %%I_B=\\frac{I_C}{B} \\cdot \\textrm{\\\"u}%% mit %%\\textrm{\\\"u}=2 \\ldots 5%% %%R_B=\\frac{U_E-U_{BE}}{I_B}%%","tags":"halbleiterelemente","title":"Bipolarer Transistor als Schalter"},{"url":"https://www.semiversus.com/dic/mikrocontroller/bitmanipulation.html","text":"Allgemeines Übungsblatt Zu diesem Teil gibt es ein Übungsblatt Um bitweise Verknüpfungen zu machen gibt es unter C im wesentlichen vier Operatoren: & (für bitweises AND ), | (für bitweises OR ), &#94; (für bitweises XOR ) und ~ (für bitweise NOT ). Die ersten drei Operatoren benötigen immer zwei Operanden, z.B. var_a = var_a & var_b; . Die bitweise Invertierung kann nur auf einen Operanden angewendet werden, z.B. vara = ~varb; . Für Zuweisungen gibt es eine Kurzschreibweise, die den Operator vor das Gleichheitszeichen setzt. So bedeutet var_a &= 0x03; das gleiche wie var_a = var_a & 0x03; . C versteht Zahlen in dezimaler Schreibweise (z.B. 1203 ) und hexadezimaler Schreibweise (z.B. 0xB2F ). Die Oktale Schreibweise (zur Basis 8) wird sehr selten benutzt (durch führende Null gekennzeichnet z.B. 0433 ). Die binäre Schreibweise wird nur von bestimmten Compilern unterstützt, z.B. 0b01010011 . Bits auf 1 setzen Mittels ver ODER ung: A OR 0=A (Neutralitätsgesetz) A OR 1=1 (Extremalgesetz) Beispiel Im Register PORTB sollen die unteren zwei Bits auf eins gesetzt werden, die anderen sollen ihren Zustand behalten: PORTB |= 0x03 ; // 0x03->0b00000011 Bits auf 0 setzen Mittels ver UND ung: A AND 0=0 (Extremalgesetz) A AND 1=A (Neutralistätsgesetz) Das Bitmuster, welches vorgibt, welche Bits auf 0 gesetzt werden und welche auf ihrem ursprünglichen Wert bleiben wird auch Maske genannt. Diese Maskierung wird sehr oft bei Abfragen verwendet, weil man nur den Zustand bestimmter Bits kennen möchte. Beispiel 1 Im Register PORTC soll das Bit 5 auf 0 gesetzet werden, die anderen sollen ihren Zustand behalten: PORTC &= 0xDF ; // 0xDF->0b11011111 Hilfreich bzw. übersichtlicher ist auch manchmal die Invertierung der Maske. PORTC &= ~ 0x20 ; // 0x20->0b00100000 Weiters kann der Schiebeoperator genutzt werden, um eine 1 auf die richtige Position zu schieben. Der Wert 0x20 lässt sich damit so darstellen: 1<<5 (1 um 5 stellen nach links geschoben, also auf Position von Bit 5). PORTC &=~ ( 1 << 5 ); Beispiel 2 Eine Anweisung soll nur ausführt werden, wenn Bit 1 im Register PINA auf 1 ist. Bei if wird immer der True Zweig ausgeführt wenn die Bedingung ungleich 0 ist. if ( PINA & 0x02 ) { // 0x02->0b00000010 // Answeisung } Bits invertieren Mittels ver XOR ung: A XOR 0=A (Neutralitätsgesetz) A XOR 1=NOT A Beispiel Die unteren 4 Bits von PORTA sollen invertiert werden, die anderen Bits sollen ihren Zustand behalten PORTA &#94;= 0x0F ; // 0x0F->0b00001111","tags":"mikrocontroller","title":"Bitmanipulation mit C"},{"url":"https://www.semiversus.com/dic/bussysteme/bussysteme.html","text":"Allgemeines Busse dienen zur Übertragung von Daten zwischen Komponenten, stellen also ein gemeinsames Medium dar. Werden exakt zwei Komponenten miteinander verbunden, spricht man typischerweise von einer Punkt-zu-Punkt Verbindung, bei mehr als zwei Komponenten spricht man von einem Bus . An Busse gibt es je nach Einsatzzweck verschiedene Anforderungen: Geringer Verkabelungsaufwand Datenübertragungsrate niedrige Latzenzzeit Deterministisches Zeitverhalten galvanische Trennung An- und Abkoppeln während dem Betrieb sichere Datenübertragung Parallel und serielle Verbindung Parallele Busse werden typischerweise bei lokalen Verbindungen innerhalb eines Systems genutzt, bei der sehr viele Daten übertragen Werden müssen (z.B. zwischen Prozessor und Speicher). Dabei kommen meist Bitbreiten von 8 Bit bis 128 Bit zum Einsatz. Durch Hinzufügen von zusätzlichen Verbindungen können Funktionen zur Kontrolle und Steuerung realisiert werden. Der Hauptvorteil von seriellen Verbindungen ist die vereinfachte Verkabelung. Dadurch sind Systeme flexibler und die Entfernung zwischen den einzelnen Komponenten kann wesentlich größer sein. Heute wird oft der Begriff Feldbus verwendet. Die erste Generation von Feldbussen hat Busse mit der bis dahin gängigen Parallelverdrahtung zur Datenübertragung und Systeme mit analoger Singalübertragung ersetzt. ISO-OSI 7-Schichten Modell Um die Kommunikationsprotokolle zu entwickeln und beschreiben wurde durch die ISO ein 7-Schichten Modell standartisiert. Jede Schicht stellt dabei eine Aufgabe dar und die einzelnen Schichten setzen dabei aufeinander auf. Schicht 7 – Anwendungsschicht : In dieser Schicht wird die eigentliche Aufgabe beschrieben (z.B. EMail-Kommunikation, CANOpen, usw.). Schicht 6 – Darstellungsschicht : Beschreibt die Darstellung der Daten. Auch Komprimierung oder Verschlüsselung werden in dieser Schicht durchgeführt. Schicht 5 – Sitzungsschicht : Beschreibt die Prozesskommunikation zwischen zwei Systemen. Schicht 4 – Transportschicht : Diese Schicht ist für die Transport-Kontrolle zuständig. Weiters wird das Segmentieren eines Datenstroms in einzelne Pakete gesteuert. In typisches Beispiel ist hier TCP bzw. UDP. Schicht 3 – Vermittlungsschicht : In dieser Schicht werden die einzelnen Pakete zwischen verschiedenen Stationen vermittelt und übertragen. Typischer Vertreter ist das Internet Protocol ( IP ). Schicht 2 – Sicherungsschicht : Sorgt für eine fehlerfreie Punkt-zu-Punkt Übertragung. Hier wird der Buszugriff und die Datensicherung gesteuert. Schicht 1 – Bitübertragungsschicht : Diese Schicht stellt die physikalische Datenübertragung dar. Hier werden elektrische Pegel und Kodierungen definiert. Weiters werden durch diese Schicht die Stecker definiert. Für Feldbusse sind nicht alle Schichten gleich wichtig. Die meisten Feldbusse kommen durch die Definition der Schichten 1 und 2 aus. Teilweise sind auch die Schichten 3 und 7 definiert. Buszugriff Da mehrere Komponenten auf ein gemeinsames Medium zugreifen, muss sichergestellt werden, dass zu jedem Zeitpunkt nur eine Komponente aktiv auf den Bus zugreift (sprich sendet ). Der Buszugriff wird durch die ISO-OSI Schicht 2 definiert. Kontrollierter Buszugriff Beim kontrollierten Buszugriff ist der Sender eindeutig bestimmt. Dazu gibt es zwei Verfahren: Master/Slave : Es gibt einen Master, der Daten an Slaves schickt oder abfragt. Jede Kommunikation wird durch den Master initiiert und der (angesprochene) Slave antwortet auf diese Anfrage. Token-Passing : Bei diesem Verfahren wird der Bus meist als logischer Ring realisiert. Jeder Teilnehmer kann auf dem Bus senden, wenn er im Besitz des Tokens ist. Dieser Token existiert genau einmal. Wenn ein Teilnehmer einen Token empfängt, kann er entweder auf den Bus zugreifen und nach Abschluss den Token weiterschicken oder wenn er keinen Buszugriff initiieren möchte, den Token gleich weiterschicken. Summenrahmen-Verfahren : Dieses Verfahren nutzt einen ringförmigen Bus, wobei die einzelnen Teilnehmer intern Schieberegister nutzen. Jeder Teilnehmer gibt die Bits an seinen nächsten Nachbar weiter, bis die Daten wieder beim Master landen. Vor dem Zugriff auf den Bus schreiben die Teilnehmer ihre Daten in das Schieberegister. Der Master liest sämtliche Schieberegister aus und schreibt gleichzeitig neue Daten an die Teilnehmer hinaus. Zufälliger Buszugriff Wenn in einem System mehrere Master bzw. Sender je nach Bedarf auf den Bus zugreifen, benötigt es eine Regelung des Zugriffs ( Arbitrierung ). Mittels Bus-Arbiter : Der Arbiter entscheidet, wer den Zugriff auf den Bus erhält. Dazu werden teilweise einzelne Steuerleitungen zwischen den Mastern und dem Arbiter benötigt. CSMA : Bei Carrier Sense Multiple Access schaut jeder Master, ob der Bus verfügbar ist, bevor eine einen Buszugriff initiiert. Wenn dies der Fall ist, greift er auf den Bus zu. Hier kann es zu einem Problem kommen, wenn zwei Master gleichzeitig einen Buszugriff initiieren wollen, da beide Master einen freien Bus feststellen und die Übertragung beginnen. CSMA/CD : Bei der Erweiterung mittels Collision Detection erkennen die sendenden Teilnehmer, dass es zu einer Kollision gekommen ist. Wird eine Kollision erkannt, beenden alle Teilnehmer die Aussendung und startet sie nach einer zufälligen Zeit erneut. Da es sich hier um einen stochastischen Prozess handelt, ist ein solcher Bus niemals Echtzeitfähig. Diese Buszugriffsregelung wird von Ethernet verwendet. CSMA/CR : Bei der Erweiterung mittels Collision Resolution kann es zu Kollisionen kommen, diese werden aber während dem Senden beseitigt. Dies geschieht meist, indem eine Identifikation bitweise übertragen wird und ein Bitzustand dominant gegenüber dem anderen ist, sich also durchsetzt. Der überstimmte Sender stellt seine Übertragung ein. Dieses Verfahren wird bei CAN verwendet.","tags":"bussysteme","title":"Bussysteme Übersicht"},{"url":"https://www.semiversus.com/dic/bussysteme/can.html","text":"Allgemeines CAN steht für Controller Area Network und ist ein serielles Feldbussystem. Die Entwicklung von CAN startete 1983 bei Bosch mit dem Ziel die Vernetzung der Steuergeräte in Fahrzeugen zu vereinfachen. CAN ist ein ISO Standard (11898) und findet weite Verwendung im Automobil sowie Automatisierungsbereich. Der CAN Standard definiert die beiden Schichten 1 und 2 des ISO/OSI Schichtenmodels (Bitübertragungsschicht und Sicherungsschicht). Bitübertragungsschicht Für die Übertragung wird neben der gemeinsamen Masse ein differentielles Signal verwendet, welches über die beiden Signalpfade CAN+ und CAN- (oft auch CAN_HIGH und CAN_LOW genannt). Der Bus arbeitet nach dem Multi-Master Prinzip, d.h. jede Komponente kann aktiv auf den Bus zugreifen. Ein CSMA/CR -Verfahren stellt sicher, dass Nachrichten mit höher Priorität nicht durch gleichzeitig startende Nachrichten mit niedriger Prioriät beschädigt werden (siehe Arbitrierung ). Die beiden logischen Wert 0 und 1 werden mittels zweier Zustände übermittelt. Die logische 1 wird dabei rezessiv übertragen, die logische 0 wird dominant übertragen. Durch diese zwei Zustände setzt sich am Bus eine logische 0 gegenüber einer gleichzeitig anliegender logischen 1 durch. Ein wichtiges Grundprinzip von CAN ist, dass jeder aktive Sender während der Übertragung den Zustand des Busses überwacht. Wenn der Bus einen anderen Zustand hat als der Sender selbst auf den Bus legt wird die Übertragung abgebrochen. Je nach Leitungslänge des Busses gibt es Limitierungen für die Datenrate: 1MBit/s bis 40 Meter 500kBit/s bis 100 Meter 125kBits/s bis 500 Meter Als Busmedium wird meist ein Twister-Pair Kabel mit einem Wellenwiderstand von ungefähr 110 Ohm verwendet. Arbitrierung Jedes Datentelegramm enthält am Anfang des Packets eine 11 Bit Identifikationsnummer (direkt hinter einem Start of Frame Bit). Im CAN 2.0 B Standard wird darüber hinaus auch eine 29 Bit lange Identifikationsnummer definiert. Sobald ein Packet erfolgreich übertragen wurde und der Bus damit frei ist hat jeder Sender die Möglichkeit ein Datentelegram zu schicken. Übertragen mehrere Sender zeitgleich ein Packet wird mittels der Arbitrierung das Packet mit der höchsten Priorität ermittelt. Dazu übertragen die Teilnehmer Bit für Bit der Identifikationsnummer, startend mit dem höchstwertigsten. Wird ein logische 1 ausgesendet, eine logische 0 aber vom Bus zurückgelesen beendet der Teilnehmer die Übertragung. Je niedriger die Identifikationsnummer, desto höher die Priorität. Ein Packet mit der ID 0 hat alle Bits auf logisch 0 und diese wird sich gegen alle anderen IDs durchsetzen. Eindeutigkeit der ID Identifikationsnummern identifizieren das Datentelegramm, nicht den Teilnehmer selbst! Für ein CAN System muss sichergestellt werden, dass Identifikationsnummern eindeutig sind. Beispiel Im folgenden Beispiel senden drei Teilnehmer ein Packet. Die Identifikationsnummern der Datentelegramme ist dabei: 0x125 - Binär 001 0010 0101 0x12A - Binär 001 0010 1010 0x147 - Binär 001 0100 0111 Als erstes scheidet ID 0x147 aus. Bei Bit ID6 wird vom Teilnehmer eine logische 1 gesendet, am Bus hat sich aber die logische 0 der beiden anderen Teilnehmer durchgesetzt. Gleiches passiert bei ID 0x12A bei Bit ID3 . Sicherungsschicht Aufbau eines CAN Telegramms im Base Frame Format (Bild: Endres~commonswiki CC BY-SA 3.0) Ein Datentelegramm beteht aus folgenden Feldern: Start of Frame - markiert den Start eines Frames und ist logisch 0 Arbitration Field - überträgt die 11 Bit Identifikation und ein Remote Transmission Request Flag Control ID Extension Bit - muss logisch 0 für eine 11 Bit Identifikation sein (logisch 1 bei 29 Bit) Data Length - Anzahl an Datenbytes (0 bis 8) Data - Datenbytes (im Bild wird ein Datenbyte übertragen) CRC Field - CRC Prüfsumme ACK Slot - wird vom Sender mit logisch 1 gesendet, ein Empfänger sendet bei Erfolg logisch 0 End of Frame - 7 rezessive Bits Der Remote Transmission Request (kurz RTR) ist eine Möglichkeit, von einem Teilnehmer Daten anzufordern. Dazu wird ein Telegramm mit der gewünschten Identifikationsnummer und dem RTR Bit auf logisch 1 gesendet.","tags":"bussysteme","title":"CAN Bus"},{"url":"https://www.semiversus.com/dic/bussysteme/datenintegritaet.html","text":"Allgemeines Um eine sichere Datenübertragung gewährleisten zu können ist es notwendig, dass der Empfänger eine fehlerhafte Übertragung als solche erkennen kann ( Fehlererkennungsverfahren ). Es wird von einem Fehlerkorrekturverfahren gesprochen, wenn darüber hinaus so viel Information zur Verfügung steht, dass aufgetretene Fehler korrigiert werden können. Um dies zu ermöglichen, müssen neben den Nutzdaten noch weitere Informationen vom Sender hinzugefügt werden, um eine Fehlererkennung bzw. -korrektur zu ermöglichen. Diese weitere Information nennt sich Redundanz . Bei jeder Datenübertragung kann es zu Fehlern kommen, d.h. es können einzelne oder mehrere Bits umkippen . Die Bitfehlerrate ist ein statistisches Maß für die Qualtität der Datenübertragung. Je kleiner die Bitfehlerrate ist, desto besser ist die Qualität. Eine Bitfehlerrate von 0.000 001 bedeutet, dass die Wahrscheinlichkeit der Fehlübertragung eines Bits gleich 1 zu einer Million ist oder anders ausgedrückt: Im Mittel wird jedes Millionste Bit falsch übertragen. Fehlerarten Einzelfehler - Es ist ein einzelnes Bit umgekippt Bündelfehler - Mehrere Bits hintereinander sind gekippt Prüfsummen Beispiel EAN13 Die European Article Number (EAN) stellt ein System zur Produktkennzeichnung dar. Hier wird eine Prüfsumme verwendet, um mögliche Lese- oder Tippfehler zu erkennen. Die letzt Ziffer stellt die Prüfziffer dar. Diese wird berechnet, indem die einzelnen Ziffern abwechselnd mit 3 und 1 multipliziert und anschließend addiert werden. Angefangen wird bei der Ziffer neben der eigentlichen Prüfziffer. Die Prüfziffer ist dann die Differenz zum nächsten Vielfachen von 10. Für das obige Beispiel bedeutet dies: 5 3 + 4 1 + 3 3 + 2 1 + 1 3 + 4 1 + 3 3 + 2 1 + 1 3 + 0 1 + 9 3 + 5 1=83 Die Differenz zum nächsten Vielfachen von 10 (83 -> 90) ist 7 . Als Prüfsumme hätte man auch eine einfache Quersumme verwenden können. Dies hätte aber den Nachteil, dass die in der Praxis häufig auftretenden Zahlendreher (Vertauschung zweier Ziffern) nicht erkannt werden können. Einfache Prüfsummen Bei einfachen Prüfsummen werden alle Datenbytes über einen Rechenoperator verknüpft. Dies kann zum Beispiel die Summe aller Bytes sein. Da die Summe Werte über 255 annehmen kann, werden nur die unteren 8 Bit der Summe verwendet. Diese einfachen Prüfsummen haben meist den Nachteil, dass schon Zweibitfehler nicht erkannt werden können. Paritätsbit Bei der Prüfung der Datenintegrität mittels Paritätsbit wird einem Datenwort ein zusätzliches Paritätsbit hinzugefügt. Man unterscheided hierbei zwei Arten: gerade (engl. even) Parität: Das Paritätsbit erweitert das Datenwort so, dass die Gesamtzahl aller Einsen gerade ist. ungerade (engl. odd) Parität: Das Paritätsbit erweitert das Datenwort so, dass die Gesamtzahl aller Einsen ungerade ist. Beispiel für gerade Parität: Das Datenwort ist 0xA7 (binär 1010 0111). Die Anzahl der Einsen im Datenwort ist 5 und damit ungerade. Für eine gerade Anzahl an Einsen muss das Paritätsbit auch eine 1 sein. Das Ergebnis ist somit 1010 0111 1 . Durch das Paritätsbit können Einzelbitfehler erkannt werden. Wenn in einem Datenwort zwei Bits umkippen, kann der Fehler nicht entdeckt werden. Blockparität Bei der Blockparität (auch Kreuzsicherung genannt) werden die einzelnen Bits in einer Matrix angeordnet und dann jeweils über die Zeilen und Spalten die Parität erweitert. Es ergibt sich auch eine Kreuzparität über die Spalten- und Zeilen-Paritätsbits. In den Beispielen wird die gerade Parität verwendet. Die Paritätsbits werden vom Sender beim Senden entsprechend erweitert und anschließend vom Empfänger kontrolliert. Bei einem Einzelbitfehler kann die Position ermittelt werden, egal um welches Bit es sich handelt (Datenbereich, Paritätsbereich oder das Kreuzparitätsbit). Einzelbitfehler können somit erkannt und sogar korrigiert werden. Zweibitfehler können erkannt werden, aber nicht korrigiert werden. Das gleiche gilt für Dreibitfehler. Bei Dreibitfehler kann es zu ungünstigen Konstellationen kommen, so dass es wie ein Einbitfehler aussieht. Bei Vierbitfehlern kann es zu Konstellationen kommen, in denen alle Paritätsbits wieder stimmen, obwohl insgesamt vier Bits umgefallen sind (siehe oberes Beispiel).","tags":"bussysteme","title":"Datenintegrität und Prüfsummen"},{"url":"https://www.semiversus.com/dic/halbleiterelemente/datenspeicher.html","text":"Allgemeines Speicher haben die Aufgabe Information zu speichern. Bei digitalen Speichern ist diese Information ein diskreter Zustand, in den meisten Fällen die Speicherung einer logisch 0 oder 1. Von Informationsverlust spricht man, wenn eine gepeicherte Information nicht mehr richtig wieder gelesen werden kann, bzw. der Zustand einer Speicherzelle sich ungewollt verändert hat. Historische Speicher Zu den ersten digitalen und von einer Maschine verarbeitbaren Speicher zählt die Lochkarte , die 1890 zur Volkszählung in der USA von Herman Hollerith eingeführt wurde und bis in die 1970er verwendet wurde. Lochkarte(Bild: Hannes Grobe/AWI CC BY 3.0) Unterteilung Die Unterteilung von Speicher kann durch verschiedene Eigenschaften erfolgen. Die wichtigsten Merkmale sind in den folgenden Abschnitten aufgeführt. Flüchtig oder Nicht-Flüchtig Bei einem flüchtigen Speicher (englisch volatile memory) ist eine Betriebsspannung und teilweise eine zusätzliche Ansteuerung notwendig, um die Information speichern zu können. Fehlen diese Grundvoraussetzungen (z.B. Betriebsspannung fällt aus) geht die Information verloren. Bei einem nicht-flüchtigen Speicher (non-volatile memory) wird keine Betriebsspannung benötigt. Die Information wird hier entweder magnetisch (z.B. Festplatte), optisch (z.B. DVD) oder durch eine elektrische Ladung in einem isolierten Bereich (z.B. EPROM). Im Detail betrachtet sind einige Verfahren für eine Zeitdauer von mehreren Jahren nicht flüchtig, durch Einflüße aus der Umgebung oder vom Verfahren selbst bedingt kann es aber zu einem Verlust der Information kommen. Speichermedium Informationen können auf viele verschiedene Arten gespeichert werden. Die historisch älteste Art ist die Speicherung mittels mechanischer Veränderung eines Materials (z.B. Lochkarte). Die Information kann aber auch über einen Schaltungszustand gespeichert werden (z.B. Relais oder Flip-Flop). Weitere Möglichkeiten sind die magnetische und optische Speicherung. Beschreibbarkeit Hier unterscheidet man in Nur-Lese Speicher, der in der Anwendung nur gelesen werden kann und Schreib-Lese Speicher, der in der Anwendung sowohl beschrieben als auch gelesen werden kann. Eine Sonderform ist der sogenannte Einmal-Schreiben-Mehrfach-Lesen Speicher (englisch Write Once Read Many oder WORM). Hier kann der Speicher einmal beschrieben und dann mehrfach gelesen werden. Zugriffsart Bei historischen Bandlaufwerken wird die Information auf einem magnetischen Band gespeichert, welches auf einer Rolle aufgerollt wird. Hier kann die Information nur sequentiell (also nacheinander) eingelesen werden. Das Gegenteil ist bei einem Speicher der Fall, der in einer zufälligen Reihenfolge adressiert werden kann, d.h. es kann wahlfrei darauf zugegriffen werden. Viele Speicher können wahlfrei adressiert werden, haben aber einen deutlich höheren Datendurchsatz, wenn sie sequentiell gelesen bzw. geschrieben werden. Eine Sonderform sind sogenannte First-In-First-Out Speicher (oder kurz FIFO). Diese Speicher besitzen ein Port, über welches Daten geschrieben werden und ein Port, über welches die Daten ausgelesen werden. Die Daten kommen in der Reihenfolge aus dem Speicher heraus, in der sie in den Speicher geschrieben wurden. Zusätzlich gibt es eine Signalisierung, ob Daten zum Lesen vorhanden sind und ob noch Platz vorhanden ist um Daten in den Speicher hineinzuschreiben. Betriebsart der Speicherzelle Je nachdem wie eine Speicherzelle aufgebaut ist, kann es vorkommen, dass die Information zyklisch aufgefrischt werden muss. Man spricht dann von einer dynamischen Speichererhaltung. Dies ist typischerweise bei Speichern mit einem Kondensator als Speicherelement der Fall, da hier die Ladung über ein nicht ideales Dielektrikum abfließen. Bei Flip-Flops wird die Information ohne Auffrischung erhalten, daher spricht man von einer statischen Speichererhaltung. Bei einem Nur-Lese Speicher spricht man von einer festen Speichererhaltung. Speicherkapazität Die Speicherkapazität ist die Anzahl der Bits, die gespeichert werden können. Dabei ist es in erster Linie unabhängig davon, in welcher Speicherorganisation diese gespeichert werden. Die Speicherkapazität wird meistens in Byte angegeben und ein Präfix wie Kilo oder Mega vorangestellt. Die Bedeutung laut IEC 80000-13:2008 der Präfixe entspricht dem SI System und sind dabei Zehnerpotenzen, d.h. Kilo entspricht 1.000 und Mega entspricht 1.000.000 . Da die Speicher aber binär adressiert werden, hat sich für die Präfixe der Faktor 1.024 angeboten. Um nun eine Verwechslung zu verhindern schlägt die Norm die Verwendung der Prefäxe Kibi , Mebi usw. vor, um einen Faktor von 1.024 zu beschreiben. Speicherorganisation Die Speicherorganisation beschreibt die Anordnung der Speicherzellen bzw. die Breite eines Datenwortes. Ein speicher mit 1024 Bit kann z.B. als ein Speicher mit 1024 Speicherplätzen und einem Bit als Datenwort organisiert sein. Dies beschreibt man mittels der Bezeichnung 1024x1 . Der 1024 Bit Speicher kann aber auch ein Datenwort von einem Byte bzw. einem Oktett nutzen und hätte dann eine 64x8 Organisation, d.h. es gibt 64 Speicherplätze mit je 8 Bit Datenwortbreite. Zugriffsgeschwindigkeit Die Zugriffsgeschwindigkeit ist abhängig vom Aufbau einer Speicherzelle bzw. dem Verfahren das genutzt wird, um eine Information zu Schreiben und zu Lesen. Bei der Zugriffsgeschwindigkeit wird zwischen Datenrate und Zugriffszeit. Bei der Datenrate geht es um die Geschwindigkeit, in der Daten sequentiell ausgelesen werden können. Die Zugriffszeit beschreibt die Dauer für einen wahlfreien Zugriff. : Maximale Anzahl der Schreibzyklen Teilweise sind Schreib bzw. Löschvorgänge nicht ohne Degeneration des Materials möglich. So kommt es beim Löschvorgang von Flash-Speichern zu einer allmählichen Zerstörung der Oxidschicht. Resistenz gegen Umwelteinflüsse Je nach Aufbau der Speicherzelle können verschiedene Umwelteinflüsse die Information im Speicher beeinflussen. Ein magnetischer Speicher ist empfindlich gegenüber magnetischen Feldern. Bei Halbleiterspeicher können auch elektromagnetische Felder die Information verfälschen. Halbleiterspeicher Ansteuerung mittels Adress-/Datenbus Halbleiterspeicher haben im Allgemeinen über sogenannte Busse angesprochen. Die Adresse wird über den Adressbus übermittelt und beschreibt die Stelle im Speicher auf die zugegriffen wird. Die Daten werden über den Datenbus gelesen bzw. wenn möglich geschrieben. Der Zugriff wird über einen Kontrollbus gesteuert, welcher Steuer- und Statussignale zusammenfasst.","tags":"halbleiterelemente","title":"Datenspeicher Übersicht"},{"url":"https://www.semiversus.com/dic/robotik/python/datentypen.html","text":"Zahlen Übersicht auf Python.org Ergebnis von 5 + 3 - 10 ? Ergebnis von 8 / 2 ? Was ist der Unterschied zu 8 // 2 ? Wie groß kann ein Integer maximal sein? Strings Übersicht auf Python.org Was liefert 'Abra' + \"kadabra\" ? Wie zählt man die Anzahl an 'a' s in 'Ananas' ? Wie gibt man eine Variable count=5 mittels print aus (z.B. It took 5 elements )? Wie ermittelt man die Länge eines Strings? Listen Übersicht auf Python.org Was liefert [1, 2, 3] + [4, 5] ? Wie erhält man das erste Element einer Liste? Wie erhält man das letzte Element einer Liste? Wie erhält man eine Liste mit jedem zweiten Element? Wie fügt man ein Element hinten an? Wie fügt man ein Element vorne an? Wie ändert man das 2. Element? Was unterscheidet Listen von Tuples ? Zuordnungen ( dict ) Übersicht auf Python.org Wie fügt man einen Wert ein? Wie fragt man den Key ab? Was passiert, wenn der Key schon existiert?","tags":"python","title":"Datentypen"},{"url":"https://www.semiversus.com/dic/mikrocontroller/datentypen.html","text":"Übersicht","tags":"mikrocontroller","title":"Datentypen unter C"},{"url":"https://www.semiversus.com/dic/komplexe_digitale_systeme/dicbian.html","text":"Allgemeines Die Übungen werden mittels VirtualBox und DICbian durchgeführt. Steht ein Linux bereits zur Verfügung kann dies selbstverständlich auch genutzt werden. Installation von Virtualbox Für Windows das Installationspaket herunterladen und installieren. Für andere Betriebssysteme unter Downloadseite das entsprechende Installationspaket auswählen. Das Virtualbox Image von DICbian herunterladen Durch Öffnen der Datei DICbian.ova wird das Image importiert. Im Dialog \"Appliance importieren\" auf \"Importieren\" klicken. In Virtualbox \"DICbian\" auswählen und mittels Doppelklick starten Nach dem Bootvorgang wartet der Login Benutzername ist dic , Passwort ist dic (das root-Passwort ist htl )","tags":"komplexe_digitale_systeme","title":"DICbian"},{"url":"https://www.semiversus.com/dic/halbleiterelemente/dynamische_datenspeicher.html","text":"Allgemeines Speicher mit einer Speicherzelle, die die Information in kurzer Zeit verliert und daher im Betrieb aufgefrischt werden muss, nennt man dynamische Speicher. Dynamische Speicher sind daher auch immer flüchtige Speicher, den sobald die Betriebsspannung fehlt, kann die Information nicht mehr aktualisiert werden. Als Speicherelement dient fast ausschließlich ein Kondensator. Aufbau Bei der Realisierung von DRAM Speichern sind die Kondensatoren für die Speicherung im Bereich kleiner 50 Femtofarad. Die Bitleitung, die alle Speicherzellen einer Spalte verbindet hat durch ihre Ausdehnung eine Kapazität, die üblicherweise um den Faktor 5 größer ist. 3T1C Speicherzelle 3T1C Speicherzelle (Bild: Chrihern CC BY-SA 3.0) Um die Information, die im Kondensator gespeichert ist nun schreiben und lesen zu können wurden anfangs 3 Transistoren pro Kondensator verwendet (deswegen 3T1C). Mittels Q3 wird die Speicherzelle zum Schreiben ausgewählt. Nun kann Ladung von der Leitung Data In zum Kondensator fließen (Schreiben einer logischen 1), oder der Kondensator entladen werden (Schreiben einer logischen 0). Über Q2 kann die Information ausgelesen werden. Q1 dient als Verstärker, der den aktuellen Zustand verstärkt und damit die Kapazität der Leitung Data Out umladen kann. Im Laufe der Zeit wurde diese 3T1C Zelle durch die 1T1C Zelle abgelöst, die wesentlich kleiner gebaut werden kann. 1T1C Speicherzelle 1T1C Speicherzelle (Bild: Tosaka CC BY 3.0) Zum Schreiben wird die Datenleitung (Bit Line) auf den gewünschten Pegel gebracht und anschließend wird der Transistor durchgeschaltet. Dadurch wird die Kapazität entsprechend dem Pegel der Datenleitung geladen bzw. entladen. Um die Information auszulesen wird die Datenleitung auf die Hälfte der Versorgungsspannung vorgeladen. Anschließend wird die Speicherzelle über den durchgeschaltenen Transistor mit der Datenleitung verbunden. Die Ladungen verteilen sich auf der Datenleitungs- und Speicherzellenkapazität. Wenn die Kapazität der Speicherzelle keine Ladungen gespeichert hatte, wird die Spannung leicht sinken. War die Kapazität voll geladen, wird die Spannung leicht steigen. Da nach dem Durchschalten des Transistors die Information verloren geht wird direkt nach dem Auslesen die Information neu in die Speicherzelle geschrieben.","tags":"halbleiterelemente","title":"Dynamische Datenspeicher"},{"url":"https://www.semiversus.com/dic/komplexe_digitale_systeme/echtzeitbetriebssysteme.html","text":"Allgemeines Ein Echtzeitbetriebssystem ist ein Betriebssystem, dass speziell für \"Echtzeit\"-Anwendungen entwickelt und verwendet wird. Der Schlüsselkriterium eines Echtzeitbetriebssystems (engl. RTOS für Real Time Operating System) ist die Einhaltung der Zeitbedingungen und die Vorhersagbarkeit des Prozessverhaltens. Begriffe Echtzeit Abhängig von den Folgen wird manchmal zwischen harter Echtzeit (engl. hard real-time), weicher Echtzeit (engl. soft real-time) und fester Echtzeit unterschieden. Hierfür gelten jeweils unterschiedliche Echtzeitanforderungen. Harte Echtzeitanforderungen : Eine Überschreitung der Antwortzeit wird als ein Fehler gewertet. Echtzeitsysteme (sollten) das korrekte Ergebnis immer innerhalb der vorgegebenen Zeitschranken liefern. Um diese Bedingungen einhalten zu können sind genaue Kenntnisse der Resourcenverteilung während des Betriebs schon in der Entwicklungsphase notwendig, um die entsprechenden Vorkehrungen zu treffen. Weiche Echtzeitanforderungen : Solche Systeme arbeiten typischerweise alle ankommenden Eingaben schnell genug ab. Die Antwortzeit erreicht beispielsweise einen akzeptablen Mittelwert oder ein anderes statistisches Kriterium. Die Zeitanforderungen sind hier als Richtlinien zu sehen. Ein Überschreiten der Zeitanforderung muss nicht als Fehler gewertet werden. Zum einen kann die Zeit häufig überschritten werden, solange sie sich noch in einem Toleranzbereich befindet. Feste Echtzeitanforderungen : Bei festen Echtzeitanforderungen droht kein unmittelbarer Schaden. Nach Ablauf der Zeitanforderungen ist das Ergebnis der Berechnung jedoch nutzlos und kann verworfen werden. Die DIN-Norm 44300 definiert unter Echtzeitbetrieb (dort Realzeitbetrieb genannt) den Betrieb eines Rechnersystems, bei dem Programme zur Verarbeitung anfallender Daten ständig betriebsbereit sind, derart, dass die Verarbeitungsergebnisse innerhalb einer vorgegebenen Zeitspanne verfügbar sind. Diese Begriffsnorm hat sich in der Praxis als alleinig akzeptierte Definition nicht durchsetzen können, es dominieren die Begriffe aus dem englischen Sprachraum. Prozess Ein Prozess beschreibt ein für sich lauffähiges Programm (bei Desktopsystemen) oder vereinfacht einer Funktion. Einem Prozess wird durch den Prozesskontext beschrieben. Dieser wird vom Betriebssystem verwaltet und beinhaltet vom Prozess belegte Ressourcen (Speicher, usw.). Vom Betriebssystem zur Verfügung gestellte Ressourcen stehen ausschließlich diesem Prozess zur verfügung. Der Prozesskontext beinhaltet meist auch, welchem Prozess dieser Prozess zugeordnet ist (sprich, welcher Prozess diesen Prozess gestartet hat). Durch diese Abhängigkeiten ergibt sich eine Prozesshierarchie. Prozesszustände Da ein Prozessor immer nur einen Prozess pro Zeiteinheit bearbeiten kann, werden verschiedene Prozesszustände verwendet, um die Bearbeitung zu ermöglichen: Erzeugt - Wurde vom Betriebssystem erzeugt, aber steht noch nicht zur Ausführung bereit Bereit - Besitzt alle Ressourcen und wartet auf die Zuteilung von Prozessorzeit Laufend - Wird aktuell durch den Prozessor bearbeitet Blockiert - Wartet auf die Zuteilung einer Ressource Beendet - Wurde beendet und Ressourcen können freigegeben werden Die Transitionen A bis F werden wie folgt durchlaufen: A - Nachdem alle Ressourcen des Prozesses geladen wurden wird der Prozess in den Zustand Bereit versetzt B - Der Scheduler wählt den Prozess aus und dadurch wechselt er in den Zustand Laufend C - Je nach Scheduling Strategie ist entweder die vorgesehene Zeitscheibe ausgelaufen oder der Prozess hat von sich aus die Kontrolle zurückgegeben D - Der Prozess will auf eine Ressource zugreifen die entweder gerade nicht verfügbar oder vorbereitet werden muss E - Die Ressource steht nun zur Verfügung, dadurch wird der Prozess in den Zustand Bereit versetzt F - Der Prozess beendet sich Nebenläufigkeit Nebenläufigkeit (engl. concurrency) liegt vor, wenn mehrere Ereignisse in keiner kausalen Beziehung zueinander stehen, sich also nicht beeinflussen. Bei einem Betriebssystem will man diese Nebenläufigkeit für die Abarbeitung der Prozesse erreichen. Aus der Sicht eines Prozesses sollte es im Idealfall keinen Rolle spielen, ob es der einzige Prozess im System ist oder ob am System mehrere Prozesse laufen.","tags":"komplexe_digitale_systeme","title":"Echtzeitbetriebsssysteme Übersicht"},{"url":"https://www.semiversus.com/dic/digitale_signalverarbeitung/faltung.html","text":"Allgemeines Um die Antwort eines LTI Systems auf eine beliebige Eingangsfolge zu bekommen nutzt man die Eigenschaften der Linearität und der Zeitinvarianz. Da sich jedes Eingangssignal %%x[t]%% als Linearkombination von Einheitspulsen darstellen lässt, kann für das Ausgangssignal eine Linearkombination der entsprechenden Impulsantworten verwendet werden. Berechnung Ein beliebiges Eingangssignal %%x[n]%% lässt sich wie folgt darstellen: %%x[n]=\\ldots + x[-1]\\cdot\\delta[n+1] + x[0]\\cdot\\delta[n] + x[1]\\cdot\\delta[n-1] + \\ldots=\\sum\\limits_{k=-\\infty}&#94;{\\infty} x[k]\\cdot \\delta[n-k]%% Durch die Impulsantwort wird vollständig festgelegt, wie die Reaktion eines LTI Systems auf ein beliebiges Eingangssignal ist. Die Gleichung zur Berechnung des Ausgangssignals ausgehend von einem Eingangssignal wird als diskrete Faltung des Eingangssignals mit der Impulsantwort bezeichnet. Der Operator der Faltung heißt Faltungsstern (%%\\ast%%): %%x[n]\\ast h[n]=\\sum\\limits_{k=-\\infty}&#94;{\\infty}x[k]\\cdot h[n-k]%% Visuelle Darstellung Faltung eines Rechtecksignals mit einem Rechteck (Bild: Brian Amberg CC BY-SA 3.0) Das zweite Beispiel zeigt ein System mit Tiefpasseigenschaft. Die Impulsantwort eines Tiefpasssystems ist %%e&#94;{-t}%% für %%t\\geq 0%%. Faltung eines Rechtecksignals mit einer Exponentialfunktion (Bild: Brian Amberg/Tinos CC BY-SA 3.0) Berechnung nach Wozny Eine einfache Art zur Durchführung der diskreten Faltung ist die Berechnung nach Wozny. Im folgenden Youtube Video findet sich eine Anleitung .","tags":"digitale_signalverarbeitung","title":"Faltung"},{"url":"https://www.semiversus.com/dic/digitale_signalverarbeitung/filter.html","text":"","tags":"digitale_signalverarbeitung","title":"Filter"},{"url":"https://www.semiversus.com/dic/programmierbare_logik/flankenerkennung.html","text":"","tags":"programmierbare_logik","title":"Synchrone Flankenerkennung"},{"url":"https://www.semiversus.com/dic/mikrocontroller/floatingpoint.html","text":"Allgemeines Im Vergleich zu einer Zahl ohne Nachkommastellen ( Integer -Zahl bzw. Ganzzahl) benötigt man für die Speicherung und Verarbeitung von Zahlen mit Nachkommastellen eigene Zahlenformate. Festkomma Zahlen Die Anzahl der Nachkommastellen ist hier fix. Bei der Angabe des Formats gibt man oft die Anzahl der Vorkommastellen (bezeichnet mittels I ) und die Anzahl der Nachkommastellen an (bezeichnet mittels Q ). Das I.Q Format 32.0 beschreibt dabei eine 32 Bit Integerzahl. Bei einem I.Q Format von 1.31 hat die Zahl ein Bit als Vorkommastelle und 31 Bit als Nachkommastelle. Beispiel 3.5 Format und der Binärzahl 01101011 : 0 1 1 , 0 1 0 1 1 %%2&#94;{2}%% %%2&#94;{1}%% %%2&#94;{0}%% %%2&#94;{-1}%% %%2&#94;{-2}%% %%2&#94;{-3}%% %%2&#94;{-4}%% %%2&#94;{-5}%% 4 2 1 0.5 0.25 0.125 0.0625 0.03125 Die oben dargestellte Zahl hat den Wert ( 0 * 4) + ( 1 * 2) + ( 1 * 1) + ( 0 * 0.5) + ( 1 * 0.25) + ( 0 * 0.125) + ( 1 * 0.0625) + ( 1 * 0.03125) = 3.34375 Bei der Addition und Subtraktion können die Zahlen als reine Integer betrachtet werden. Bei Multiplikation und Division muss eine Anpassung der Kommastelle durchgeführt werden. Gleitkomma Zahlen Bei der Gleitkommazahl (auch Fließkommazahl genannt) wird die Darstellung mittels Mantisse ( M ) und Exponent ( E ) genutzt. Das Vorzeichen wird durch die Variable S beschrieben. Bei S =0 ist die Zahl Positiv, bei S =1 negativ. %%x=-1&#94;{S} \\cdot M \\cdot B&#94;{E}%% In der Digitaltechnik wird durchwegs 2 als Basis( B ) verwendet. Um mit Gleitkommazahlen zu Rechnen sind genau Vorgaben zum Zahlenformat und zur Durchführung mathematischer Operationen, insbesondere für Rundungen, notwendig. Die Norm IEEE 754 stellt eine solche Beschreibung dar. In der IEEE 754 wird die Anzahl und Position der Bits für Mantisse und Exponent definiert: Floating Point Darstellung mittels IEEE 754 (Bild: RokerHRO Public Domain) Umrechnung Zur Berechnung des Wertes aus einer IEEE 754 Darstellung wird folgende Methode verwendet. Beispiel: 0 10000011 00100110011001100110011 (aus Wikipedia ). Der Exponent als Dezimalzahl ist hier 10000011 ->131. Der Exponent wird als Zahl +127 gespeichert, um negative Zahlen darstellen zu können (sogenanntes Biasing ). Der Exponent ist also 131-127=4. Die Mantisse einer Gleitkommazahl wird immer Normalisiert gespeichert. Die Normalisierung schiebt das Komma in die Position, dass die Zahl einem I.Q Format von 1.23 entspricht und das MSB eine 1 ist. Da nun vor dem Komma immer eine 1 ist, muss diese nicht mehr gesondert abgespeichert werden. Um nun die Mantisse aus der Gleitkommadarstellung zu bekommen wird eine 1 vor das Komma gestellt. Die Mantisse ist also 1, 00100110011001100110011 . Da der Exponent 4 ist, müssen wir das Komma um 4 Stellen nach rechts verschieben: 10010,0110011001100110011 . Als Dezimalzahl hat die Zahl den Wert 18,39999961853. Das Vorzeichen ist Positiv, da das Vorzeichenbit 0 ist. Das Ergebnis ist also +18,39999961853 . Besondere Werte Der Wert 0 kann auf Grund der Normalisierung nicht gespeichert werden. Um eine 0 als Gleitkommazahl zu repräsentieren wird Exponent und Mantisse auf 0 gesetzt. Es gibt weiters besondere Darstellungen für positiv und negativ Unendlich sowie eine Darstellung für NaN (not a number bzw. keine Zahl).","tags":"mikrocontroller","title":"Fest- und Gleitkommazahlen"},{"url":"https://www.semiversus.com/dic/rechnerarchitektur/funktionale_einheiten.html","text":"Allgemeines Ein Rechner besteht aus verschiedenen Komponenten, die je nach Rechnerarchitektur unterschiedlich aufgebaut sind. Allgemein kann man aber folgende Komponenten Unterscheiden: Prozessorkern Programm- und Datenspeicher Peripherie Einheiten Man spricht von einer Von-Neumann Architektur wenn Programme- und Datenspeicher in einem gemeinsamen Adressraum liegen. Da bei einem Befehl, der auf den Datenspeicher zugreift, insgesamt zwei Speicherzugriffe notwendig sind (Befehl selbst aus dem Speicher holen, Zugriff auf Daten), ergibt sich die Notwendigkeit, dass der Befehl mindesten zwei Takte benötigt. Dies wird auch als Von-Neumann Flaschenhals bezeichnet. Da historisch die Geschwindigkeit der Prozessoren wesentlich schneller stieg als die Geschwindigkeit der Speicherzugriffe wurde dieser Flaschenhals immer relevanter. Ein Verbesserung bringt die Aufteilung in einen Programmspeicher und einen Datenspeicher, die unabhängig voneinander arbeiten können. Dies ist die Harvard -Architektur. Der Programmspeicher kann als Nur-Lese Speicher realisiert werden. Datenpfad Der Prozessorkern besteht aus einem Datenpfad und einem Steuerwerk. Der Datenpfad enthält die Register und Datenspeicher, das Rechenwerk und die Busse zwischen den einzelnen Komponenten. Register Bei Registern unterscheidet man zwischen Registern für einen speziellen Zweck oder sogenannten Registern zur allgemeinen Verwendung ( GPR für engl. General Purpose Register ). Register mit speziellem Zweck sind unter anderem: Akkumulator - enthält die Ergebnisse des Rechenwerks Stackpointer - wird als Adresse auf den aktuellen Wert im Stack verwendet Indexregister - ein Register, welches generell zur Adressierung verwendet wird Befehlszähler - Adresse des aktuellen (bzw. meist nächsten) Befehls Befehlsregister - nimmt den aktuellen Befehl auf Rechenwerk Das Rechenwerk dient der Manipulation von Daten. Dazu steht eine arithmetisch-logische Einheit ( ALU für engl. Arithmetic Logic Unit ) zur Verfügung. Diese ALU unterstützt verschiedene Rechenoperationen. Zusätzlich ist ein Register mit Statusflags vorhanden, die abhängig vom letzten Ergebnis der ALU gesetzt werden (Überlauf, Null, ...). Typische Operationen die eine ALU durchführen kann: Addition Subtraktion Zweierkomplement Logische AND, OR, XOR Vernüpfung Invertierung Schiebeoperationen Typische Statusflags sind: Übertrag ( C für engl. Carry ): Kommt es bei einer Operation zu einem Übertrag, wird das Übertragsbit in diesem Flag gespeichert Überlauf ( V für engl. oVerflow ): Stellt die Zahlenbereichsüberschreitung für Zweier-Komplement Operanden dar Null ( Z für engl. Zero ): Dieses Flag wird gesetzt, wenn das Ergebnis gleich 0 ist Negativ ( N für engl. Negative ): Bei der Zweierkomplement-Darstellung stellt das MSB das Vorzeichen dar (0: positiv, 1: negativ) Datenspeicher Der Datenspeicher ist meist so ausgelegt, dass während einem Takt ein Lese- oder Schreibzugriff durchgeführt werden kann. Dazu legt der Prozessor eine Adresse an und leitet einen Lese- oder Schreibzugriff ein. Busse Die Register und Funktionseinheiten sind über Busse miteinander verbunden. Ein Bus kann entweder als Punkt-zu-Punkt Verbindung implementiert werden. Dabei dienen Multiplexer als Schalter zwischen zwei verschiedenen Eingaben. Es gibt aber auch die Realisierung von Bussen, auf die mehrere Teilnehmer mittels Tri-State Ausgangstreiber zugreifen können. Steuerwerk Das Steuerwerk steuert den Ablauf im Datenpfad. Um einen Befehl Abzuarbeiten nimmt man typischerweise einen Von-Neumann-Zyklus an. Je nach Prozessorarchitektur können die 5 Teilschritte zusammengefasst werden oder auch ein Teilschritt auf mehrere Takte ausgeweitet werden. Fetch Instruction (1) Der aktuell vom Befehlszähler adressierte Befehl wird aus dem Befehlsspeicher in das Befehlsregister geladen. Der Befehlszähler wird erhöht, um auf den nächsten Befehl zu zeigen. Decode (2) Der Befehl wird durch den Instruktionsdekoder ausgewertet. Die entsprechenden Steuersignale für den Datenpfad werden gesetzt. Fetch Operands (3) Die Operanden für die Berechnung werden aus den Registern bzw. aus dem Speicher geholt. Execute (4) Die Operation wird vom Rechenwerk durchgeführt. Wenn der aktuelle Befehl ein Sprungbefehl ist, wird der Befehlszähler mit der Sprungadresse geladen. Write Back (5) Die Ergebnisse werden in die Register bzw. den Speicher zurückgeschrieben (sofern notwendig). Die einzelnen Teilschritte können durch Pipelining parallelisiert werden. Dazu ist es notwendig, den einzelnen Teile im Datenpfad unabhängig zu realisieren. Realisierung Das Steuerwerk kann auf zwei verschiedene Arten realisiert werden: Fest verdrahtet : Die Logik für die einzelnen Befehle ist beim Design mittels konkreter Logik realisiert Mikrocode : Das Steuerwerk ist selbst ein kleiner Prozessor, der für jeden Befehl einen sogenannten Mikrocode hinterlegt hat, der ausgeführt wird. Die Realisierung mittels Mikrocode ist sehr flexibel und es besteht die Möglichkeit, bei schon ausgelieferten Prozessoren nachträglich die Mikrokodierung zu verändern. Der Nachteil ist der langsamer Ablauf im Vergleich zur fest verdrahteten Logik.","tags":"rechnerarchitektur","title":"Funktionale Einheiten eines Prozessors"},{"url":"https://www.semiversus.com/dic/programmierbare_logik/grundlagen.html","text":"Allgemeines Mittels VHDL kann eine digitale Schaltung beschrieben werden. VHDL steht für V ery High Speed Integrated Cricuit H ardware D escription L anguage. Die wichtigste Beschreibunssprache neben VHDL ist Verilog , welche in der USA weite Verbreitung findet. Beschreibungssprache Da mittels VHDL eine digitale Schaltung beschrieben wird, ist VHDL eine Beschreibungssprache . Sehr oft wird es mit einer Programmiersprache verwechselt! Aufbau einer VHDL Datei Eine Komponente, die mittels VHDL beschrieben wird besteht aus den folgenden beiden Bestandteilen: entity - Definiert die Schnittstelle der Komponente architecture - Beschreibt die Funktion der Komponente In einer VHDL Datei können mehrere Komponenten beschrieben werden, es ist allerdings üblich pro Komponente eine Datei zu nutzen. Groß- und Kleinschreibung Bei VHDL spielt die Groß- und Kleinschreibung keine Rolle. Dies gilt für Schlüsselwörter wie entity (kann auch Entity , ENTITY oder auch eNTity heißen), sowie für Signalnamen. In diesem Skriptum werden sämtliche Schlüsselwörter und Signale kleingeschreiben. Generics werden großgeschrieben. Am Begin einer Datei werden die benötigten Bibliotheken deklariert. Ein Beispiel: library ieee ; use ieee.std_logic_1164. all ; entity dff is port ( data_i : in std_ulogic ; clk : in std_ulogic ; data_o : out std_ulogic ); end entity ; architecture behave of dff is begin process ( clk ) begin if rising_edge ( clk ) then data_o <= data_i ; end if ; end process ; end architecture ; Diese VHDL Datei beschreibt ein D FlipFlop, dessen Eingang data_i bei einer steigenden Flanke von clk gespeichert wird. Das Signal data_o gibt den aktuellen zustand des FlipFlops wieder und ist gleichzeitig der Ausgang. Der Zustand beim Start (nach dem Reset) ist nicht definiert.","tags":"programmierbare_logik","title":"VHDL Grundbegriffe"},{"url":"https://www.semiversus.com/dic/mikrocontroller/hal.html","text":"Allgemeines Der erste naive Ansatz Firmware für Mikrocontroller zu entwickeln wird nach den ersten Erfolgen schnell durch die wachsende Komplexität gebremst. Man kann den Quellcode in mehrere Dateien (bzw. C Module) unterteilen. Hängen diese aber zu stark von einander ab steigt die Komplexität durch diese Aufteilung weiter an. Ein erster wichtiger Schritt hin zu strukturierten Softwareentwicklung ist die Einführung von Abstraktionen. Definition Abstraktion (Informatik) durch Wikipedia Der Begriff Abstraktion wird in der Informatik sehr häufig eingesetzt und beschreibt die Trennung zwischen Konzept und Umsetzung. Strukturen werden dabei über ihre Bedeutung definiert, während die detaillierten Informationen über die Funktionsweise verborgen bleiben. Abstraktion zielt darauf ab, die Details der Implementierung nicht zu berücksichtigen und daraus ein allgemeines Schema zur Lösung des Problems abzuleiten. Ein Computerprogramm kann so unterschiedliche Abstraktionsebenen aufweisen, wobei auf jeder Ebene ein anderer Grad des Informationsgehaltes dem Programmierer preisgegeben wird. Eine Abstraktion auf niedriger Stufe beinhaltet Details zur Hardware, auf der das Programm läuft. Höher liegende Abstraktionsebenen beschäftigen sich dagegen mit der Geschäftslogik der Software.","tags":"mikrocontroller","title":"Hardwareabstraktion"},{"url":"https://www.semiversus.com/dic/mikrocontroller/hal_megacard.html","text":"Allgemeines Download des Megacard Templates Die Verwendung der Hardwareabstraktion (kurz HAL für engl. Hardware Abstraction Layer ) wird im folgenden erläutert. Folgende Hardwareeinheiten werden von der HAL angesteuert: LEDs (Port C) Taster S0-S3 (Port A0..3) Lautsprecher (Port A4) Timer0 für 800 Mikrosekunden Basis Timer1 für Soundausgabe LCD (Port A und Port B) Die globale Interruptfreigabe wird durch bei der Initialisierung gesetzt (mittels sei() ). Ansteuerung der LEDs Zur Ansteuerung der LEDs gibt es zwei Funktionen. Einzelne LED steuern void hal_led_set ( uint8_t index , uint8_t value ); index wählt die gewünschte LED aus (zwischen 0 und 7 ) Ist index größer 7 wird der Zustand der LEDs nicht verändert value schaltet bei dem Wert 0 die LED aus, bei jedem anderen Wert ein Alle LEDs steuern void hal_leds_set ( uint8_t value ); Der 8 Bit Wert value gibt das Muster vor, mit dem die LEDs leuchten sollen (z.B. 0xFF für alle ein) Auswerten der Tasten Die Tasten S0 bis S3 werden durch die Hardwareabstraktion automatisch entprellt. uint8_t hal_key_get (); Diese Funktion gibt 0 zurück, wenn keine Taste gedrückt wurde Der Rückgabewert ungleich 0 beschreibt die Taste, die gedrückt (genauer losgelassen) wurde Wurden mehrere Tasten gleichzeitig losgelassen, wird beim ersten Aufruf die niedrigste Nummer zurückgeben, danach die nächsthöhere usw. Ausgabe von Tönen Zur Ausgabe von Tönen wird innerhalb der HAL der Timer 1 verwendet. void hal_sound_play ( uint16_t frequency ); Die Frequenz wird über frequency in Hertz angegeben Um die Ausgabe abzuschalten wird als Argument für frequency 0 verwendet Tonausgabe und Ansteuerung des LC Displays ist nicht gemeinsam möglich Es ist leider nicht möglich diese beiden Komponenten gleichzeitig zu verwenden, da sie einen gemeinsamen Pin des Mikrocontrollers benutzen. Timerabstraktion Allgemeines Ein großer Teil an Funktionen innerhalb einer Anwendung sind durch Zeiten definiert. Da die Anzahl an hardwarebasierten Timern begrenzt ist müssen Timer mehrfachverwendet werden. Innerhalb der Hardwareabstraktion wird ein Timer verwendet, um für die Applikation beliebig viele abstrahierte Timervariablen zur Verfügung zu stellen. Alle verwendeten Timervariablen werden in einem Array über Zeiger registriert. Die Timervariablen werden durch die Applikation auf eine gewünschte Zeit gesetzt (in Mikrosekunden). Die Hardwareabstraktion zählt diese Timervariablen entsprechend der vergangen Zeit herunter, bis sie schlussendlich auf 0 angekommen sind. Verwendung Die Applikation kann die Timervariable auswerten, um zu uberprüfen, ob die gewünschte Zeit bereits vergangen ist. Ist der Wert ungleich 0 ist die Zeit noch nicht vergangen. Es gibt drei Makros, um das Setzen der Variable auf die gewünschte Zeitdauer lesbarer zu machen: TIMER_MSEC(val) multipliziert den Wert mit Tausend (entspricht dann Millisekunden) TIMER_SEC(val) multipliziert den Wert mit einer Million (entspricht dann Sekunden) TIMER_MINUTE(val) multipliziert den Wert mit einer sechzig Million (entspricht dann Minuten) Das folgende Beispiel zeigt die Verwendung: #include \"hal.h\" timer_var_t timer_app = TIMER_SEC ( 3 ); void app_process ( void ) { if ( timer_app ) { return ; // Zeit ist noch nicht abgelaufen } // ... } Wird ein Timer nicht verwendet, gibt es den speziellen Wert TIMER_DISABLED (entspricht dem Wert -1 ). Damit wird signalisiert, dass die Timervariable im Moment nicht genutzt wird. Registrierung Um die Timer in der Applikation zu registrieren wird das Makro TIMERS verwenden. Es ist im Template bereits in der Datei main.c vorbereitet. Angenommen es gibt zwei Timer: timer_led und timer_off . Dann werden diese wie folgt registriert: TIMERS ( & timer_led , & timer_off ); LC Display Löschen der Anzeige Beim Löschen der Anzeige werden alle Zeichen des 8x2 Displays gelöscht (genauer gesagt wird überall ein Leerzeichen ausgegeben). void hal_lcd_clear ( void ); Ausgabe eines Textes void hal_lcd_printf ( uint8_t line , uint8_t pos , char * fmt , ...); line gibt die gewünschte Zeile an (0 oder 1) pos gibt die gewünschte Position an (zwischen 0 oder 7) Sind line oder pos außerhalb des Bereichs wird am Displayinhalt nicht verändert fmt und falls erforderlich die nachfolgenden Argumente entsprechen der Verwendung von printf Folgende Platzhalter sind definiert: %d gibt einen (16Bit) Integer mit Vorzeichen als Dezimalzahl aus %u gibt einen (16Bit) Integer ohne Vorzeichen als Dezimalzahl aus %x und %X geben einen (16Bit) Integer als Hexadezimalzahl aus ( %x gibt Buchstaben als Kleinbuchstaben aus) %c gibt ein einzelnes Zeichen aus %s gibt einen String aus %% gibt das Prozentzeichen aus Es kann auch eine fixe Breite definiert werden, so werden bei %4d vier Stellen reserviert. Ist die auszugebende Zahl von der Breite her kleiner werden links Leerzeichen eingefügt. Um 0 einzufügen wird eine 0 beim Platzhalter eingefügt: %04d . Beispiele hal_lcd_printf ( 0 , 0 , \"Test\" ); // gibt \"Test\" aus hal_lcd_printf ( 0 , 0 , \"%d\" , - 117 ); // gibt \"-117\" aus hal_lcd_printf ( 0 , 0 , \"%3dX%3d\" , 2 , 17 ); // gibt \" 2X 17\" aus Die Ausgabe von Floatzahlen wird nicht direkt unterstützt, es kann aber emuliert werden: float temperature = 27.82 ; hal_lcd_printf ( 0 , 0 , \"%d.%02d\" , ( int16_t ) temperature , ( int16_t )(( temperature * 100 ) % 100 )); // gibt \"27.82\" aus Alternativ kann in solchen Fällen auch ganz auf Float verzichtet werden, indem man einfach mit Integer in entsprechender Dezimaldarstellung rechnet. In diesem Beispiel wird statt in Grad Celsius in 1/100 Grad Celsius gerechnet int16 temperature = 2782 ; // entspricht 27.82 Grad Celsius hal_lcd_printf ( 0 , 0 , \"%d.%02d\" , temperature / 100 , temperature % 100 ); // gibt \"27.82\" aus","tags":"mikrocontroller","title":"Hardwareabstraktion für die Megacard"},{"url":"https://www.semiversus.com/dic/robotik/python/homework1.html","text":"Installation von VSCode und Python Statistikübung In der Statistikübung soll der Nutzer nach Ganzzahlen gefragt werden. Der Nutzer kann dabei entweder eine Zahl eintippen oder zum Beenden der Abfrage einfach Enter drücken (dies resultiert in einem leeren String). Nach der Abfrage soll folgende Ausgabe am Bildschirm erscheinen (Beispiel): Minimum: 3, Maximum: 17, Average: 6 Stichworte: while Schleife, break Abgabe unter abgabe@jena.at .","tags":"python","title":"Python Hausübung 1"},{"url":"https://www.semiversus.com/dic/robotik/python/homework2.html","text":"TODO App (3 Punkte) Verwende folgendes Template um mit der Übung zu starten: Download Erstellt wird eine TODO App. Die Verwendung sieht hier als Beispiel so aus: > add WDIC Hausübung > add Äpfel einkaufen > list 1. WDIC Hausübung 2. Äpfel einkaufen > add \"Krieg und Frieden\" lesen > remove 2 > list 1. WDIC Hausübung 2. \"Krieg und Frieden\" lesen > exit Im Beispiel enthalten sind auch Unittests, die die vorhandene Spezifikation testen. Erstellen der virtuellen Umgebung Ordner aus todo.zip entpacken Mittels Visual Studio Code den Ordner öffnen Im Terminal mittels python.exe -m venv .venv den Ordner für die virtuelle Umgebung erstellen Mittels .venv/Scripts/activate.bat die virtuelle Umgebung starten Die erforderlichen Packete mittels pip.exe install -r requirements.txt Spezifikation Die Applikation soll folgende Befehle unterstützen: add Text - fügt ein Element zur Todo Liste hinzu remove Index - Index (als Zahl) entfernt den entsprechenden Eintrag aus der Todo Liste list - Listet alle Elemente der Todo Liste auf help - Gibt einen Hilfetext aus, der kurz jeden Befehl beschreibt exit - Beendet die Applikation (verläßt die input_loop Funktion und liefert die Liste als Rückgabewert) Weitere Spezifikationspunkte: Wenn remove mit einem ungültigen Wert aufgerufen wird, soll die Liste nicht verändert werden (aber auch sonst keine Ausgabe gemacht werden) list , help und exit sollen zusätzliche Argumente ignorieren Wenn ein ungültiger Befehl eingegeben wird (z.B. att statt add ) soll der Ausgabetext von help ausgegeben werden Test mittels pytest Ihr könnt eure Applikation mittels ` testen. Richtet dafür einfach die virtuelle Umgebung ein und startet im Terminal von Visual Studio Code ` . Zusatzpunkt (1 Punkt) Schreibe eine Funktion build_hashtag_dict , die eine Liste mit Strings als Argument nimmt und eine Liste der Hashtags zusammenstellt. Hier ein Beispiel: >>> items = [ '#Hausübung WDIC' , 'Matheübung #korrigieren' , '#Hausübung Deutsch #korrigieren' , 'Ausschlafen' ] >>> build_hashtag_dict ( items ) { 'Hausübung' : [ '#Hausübung WDIC' , '#Hausübung Deutsch #korrigieren' ], 'korrigieren' : [ 'Matheübung korrigieren' , '#Hausübung Deutsch #korrigieren' ]}","tags":"python","title":"Python Hausübung 2"},{"url":"https://www.semiversus.com/dic/bussysteme/i2c.html","text":"Übungsblatt Zu diesem Teil gibt es Übungsaufgaben Allgemeines","tags":"bussysteme","title":"I²C Bus"},{"url":"https://www.semiversus.com/dic/robotik/python/installation.html","text":"Vorbereitungen fürs Tutorial Für das Tutorial ist es egal, unter welcher Plattform gearbeitet wird (Windows/Linux/MacOS/...). Um eine gemeinsame Basis für die Entwicklungsumgebung zu bieten, möchte ich euch Visual Studio Code (nicht zu verwechseln mit Visual Studio !) empfehlen. Installation Visual Studio Code Hier geht's zum Download: Visual Studio Code Download . Wählt die für euch passende Plattform aus und führt die Installation durch. Installation Python Wir benötigen eine Python Installation mit Version >= 3.6. Es gibt viele Möglichkeiten Python zu installieren und manche Plattformen liefern Python direkt mit (MacOS/Linux). Sollte dies nicht der Fall sein oder nur eine alte Version vorhanden sein, gibt es eine Downloadmöglichkeit hier: Python Download Wichtig : Unter Windows sollte der Pfad zu Python in der PATH Umgebungsvariable sein. Dazu bei der Installation folgende Option setzen: Visual Studio Code Erweiterung für Python Nach dem Start von Visual Studio Code gibt es auf der linken Seite eine Toolbar. Dort \"Extensions\" auswählen und nach \"python\" suchen und installieren. Test der Installation Erstelle eine neue Datei ( Ctrl + n ) Schreibe folgendes in diese Datei: print('Hello world!') Speichern dieser Datei ( Ctrl + s ) unter test.py Ausführen dieser Datei mittels Ctrl + F5 Unten sollte im Terminal (neben anderen Meldungen) Hello world! erscheinen","tags":"python","title":"Installation"},{"url":"https://www.semiversus.com/dic/bussysteme/kanalkodierung.html","text":"Allgemeines Um Information in digitaler Form zu Übertragen muss es über ein physkalisches Medium transportiert werden. Die Kanalkodierung bzw. genauer der Leitungskode beschreibt die Pegelfolgen, in der die Daten auf der Leitung liegen. Dies kann in elektrischer Form aber auch in optischer oder elektro-magnetischer Form beschrieben werden. Synchrone und Asynchrone Übertragung Bei der synchronen Übertragung wird ein Taktsignal mitgeschickt. Der Empfänger kann sich dadurch mit dem Sender synchronisieren und die Daten empfangen. Bei der asynchronen Übertragung laufen Sender und Empfänger jeweils mit einer eigenen Taktfrequenz. Die Übertragung der einzelnen Symbole muss entweder mit einer genau definierten Symbolrate übertragen werden oder die einzelnen Symbole ermöglichen die Rückgewinnung des Taktes. Zur Rückgewinnung des Taktes werden die Taktflanken genutzt. Gleichspannungsfreiheit In bestimmten Anwendung ist die Übertragung von Gleichspannungsanteilen nicht möglich. Dies ist z.B. der Fall, wenn das Signal zwecks galvanischer Trennung über einen Impulstransformator geführt wird. Das Potential sollte also im Mittel idealerweise bei 0 liegen. Kodes die dies ermöglichen werden als gleichspannungsfrei bezeichnet. Binäre Leitungskodes NRZ (Non Return to Zero) Im einfachsten Fall wird den logischen Zustände 0 und 1 ein Logikpegel auf der physischen Leitung zugeordnet. Bei der RS232 Schnittstelle steht (nicht wie im obigen Beispiel) eine negative Spannung für logisch 1 und eine positive Spannung für logisch 0. Bitstuffing Ein Nachteil bei der NRZ Kodierung sind die fehlenden Flanken bei der Übertragung von vielen gleichen Symbolen (viele logische 0 oder 1). Um für solche Fälle zusätzliche Taktflanken zu erzeugen, kann durch Bitstuffing (oder deutsch Bitstopfen) ein zusätzliches invertiertes Bit eingefügt werden. Mit Bitweite beschreibt man dabei die Anzahl der Bits mit gleichem Pegel die zum Einfügen eines Stopfbits führt. Der Empfänger muss nach dem gleichen Prinzip dieses Stopfbit wieder entfernen. Bitstopfen mit Weite 5 (Bild: Mik81 Public Domain) Am obigen Beispiel sieht man das Einfügen eines Stopfbits bei Bitweite 5. NRZI Die Non Return to Zero Invert Kodierung ordnet einem der beiden Bit-Werte den bereits anliegenden Leitungszustand zu, dem anderen Bit-Wert einen Zustandswechsel (Invert). Daraus ergibt sich unmittelbar die Polaritätsfreiheit bei differentieller Übertragung: Ein Verpolen der Übertragungsleitung ändert nicht die Bitfolge. Wenn der Zustand, der keine Leitungszustandsänderung bringt, zu oft übertragen wird, kann auch durch die fehlenden Flanken die Synchronisation verloren gehen. Eine Lösung ist hier ebenfalls das Bitstuffing. Bei diesem Beispiel wird bei logisch 1 der Pegel geändert, bei logisch 0 beibehalten. Manchester Kodierung Bei der Manchesterkodierung entspricht eine Null-Eins-Folge einer logischen Null (steigende Flanke), eine Eins-Null-Folge (fallende Flanke) einer logischen Eins: Hierdurch wird erreicht, dass stets Pegelwechsel zur Taktrückgewinnung vorhanden sind der Gleichanteil im Mittel immer gleich Null ist Ein Nachteil dabei ist, dass sich die erforderliche Symbolrate am Übertragungskanal verdoppelt. Beim differentiellen Manchestercode steht ein Polaritätswechsel am Taktanfang für eine logische Null (zwei Flankenwechsel pro Bit), bei einer logischen Eins erfolgt kein Polaritätswechsel am Taktanfang (ein Flankenwechsel pro Bit). Blockcodes Bei Blockcodes werden verschiedene Symbole zusammengefasst und durch eine alternative Symbolgruppe übertragen. 4B5B ist ein Code, der jeweils 4 Bits auf 5 Bits abbildet, also 16 Block-Codes auf 32 Leitungscodes. Der Code ist nicht gleichstromfrei, besitzt aber immer zumindest einen Bitwechsel, um den Takt rückzugewinnen. Der 8B10B -Code ist ein Leitungscode in der Telekommunikationstechnik. Dabei werden 8 Bit Daten mit 10 Bit kodiert, sodass zum einen ein Gleichspannungsausgleich gewährleistet ist und zum anderen Taktrückgewinnung aus dem Datensignal möglich ist. Der erzeugte Datenstrom hat einen Overhead von 25% gegenüber dem originalen. Ein ähnlicher, aber deutlich effizienterer Code ist der 64B66B -Code, welcher 64 Bits auf 66 Bits abbildet und daher nur ca. 3% Overhead erzeugt. Blockcodes können zur Fehlererkennung und Fehlerkorrektur bei der Übertragung von Daten über fehlerbehaftete Kanäle verwendet werden. Dabei ordnet der Sender dem zu übertragenen Informationswort der Länge m ein Codewort der Länge n zu, wobei n>m gilt. Durch das Hinzufügen der zusätzlichen Symbole entsteht Redundanz und die Informationsrate sinkt; jedoch kann der Empfänger die redundante Information nun dazu nutzen Übertragungsfehler zu erkennen und zu korrigieren.","tags":"bussysteme","title":"Kanalkodierung"},{"url":"https://www.semiversus.com/dic/grundlagen_der_digitaltechnik/kombinatorik.html","text":"Allgemeines Bei einer kombinatorischen Schaltung handelt es sich um eine Digital-Schaltung deren Ausgänge eindeutig durch die Eingänge bestimmt sind. Um dies zu erreichen darf die Schaltung keine speichernden Elemente aufweisen, d.h. die Schaltung ist Zustandslos . Ein weiteres Kennzeichen von kombinatorischen Schaltungen ist die Zyklenfreiheit . Eine Schaltung besitzt einen Zyklus , wenn der Ausgang eines Gatters auf den Eingang des selbigen rückwirken kann. Ein solches Schaltnetz kann durch die elementaren logischen Schaltglieder ( Gatter ) dargestellt werden: AND , OR , XOR und NOT . Darstellungsformen sind unter anderem Boolesche Funktionen , Wahrheitstabellen oder zeichnerische Verknüpfungen von logischen Schaltglieder. Bei den Schaltnetzen im folgenden Kapitel werden die Schaltverzögerungen durch Gatterlaufzeiten bzw. Signallaufzeiten nicht betrachtet. Logische Gatter Zu den gebräuchlichsten Logikgattern zählen AND , OR , NOT und XOR . Die Gatter NAND , NOR und XNOR können durch Kombination von AND , OR bzw. XOR mit einem NOT Gatter gebildet werden. AND -Gatter Ein AND - bzw. zu deutsch UND -Gatter hat zwei oder mehr Eingänge und einen Ausgang. Die AND -Verknüpfung kann in booleschen Funktionen als \"•\" (Mal), \"&\" oder mittels \"%%\\land%%\" dargestellt werden. In der klassischen Logik wird eine Aussage, die nur dann wahr ist, wenn zwei oder mehr Aussagen wahr sind als Konjunktion bezeichnet. Die Wahrheitstabelle für ein Gatter mit zwei Eingängen: %%A%% %%B%% %%A \\land B%% 0 0 0 0 1 0 1 0 0 1 1 1 Der Ausgang ist also auf logisch 1 wenn A und B auf logisch 1 sind. Der Ausgang eines AND Gatter ist nur dann logisch 1, wenn alle Eingänge logisch 1 sind. Betrachtet man die logisch 0 am Eingang stellt sich auch eine Besonderheit heraus: Der Ausgang eines AND Gatter ist logisch 0, wenn mindestens ein Eingang logisch 0 ist. OR -Gatter Ein OR - bzw. ODER -Gatter hat zwei oder mehr Eingänge und einen Ausgang. In booleschen Funktionen wird die OR -Verknüpfung als \"+\" oder als \"%%\\lor%%\" dargestellt. Eine Disjunktion ist in der klassischen Logik eine Aussage, die dann wahr ist, wenn mindestens eine Teil-Aussage wahr ist. Die Wahrheitstabelle für ein OR -Gatter mit zwei Eingängen: %%A%% %%B%% %%A \\lor B%% 0 0 0 0 1 1 1 0 1 1 1 1 Der Ausgang ist auf logisch 1 wenn A oder B auf logisch 1 sind. In der klassischen Logik gibt die Unterscheidung zwischen der ausschließenden und der nicht-ausschließenden Disjunktion. Bei einer ausschließenden Disjunktion können nicht beide Teilaussagen wahr sein, z.B.:\"Wir gehen nach Italien oder nach Schweden\". Das OR -Gatter bedient sich der nicht-ausschließenden Disjunktion. Allgemein gilt für ein OR -Gatter: Der Ausgang eines OR Gatter ist logisch 1, wenn mindestens ein Eingang logisch 1 ist. Betrachtet man die logisch 0 am Eingang kommt man auf folgende Aussage: Der Ausgang eines OR Gatter ist nur dann logisch 0, wenn alle Eingänge logisch 0 sind. NOT -Gatter Das NOT -Gatter hat einen Eingang und einen Ausgang. Der Ausgang stellt die Invertierung (auch Komplement genannt) des Einganges dar. In booleschen Funktionen wird es mittels \"%%\\neg%%\" dargestellt. In der klassischen Logik stellt es eine Verneinung einer Aussage dar. Oft sieht man auch die Darstellung mittels Überstrich (z.B. %%\\overline{\\overline{A} \\land {B}}%%) Wahrheitstabelle: %%A%% %%\\neg A%% 0 1 1 0 Weitere Verknüpfungen NAND - und NOR Gatter Bei den NAND - und NOR -Gatter handelt es sich jeweils um ein AND - bzw. OR -Gatter dem ein NOT -Gatter nachgeschalten ist. Durch Kombination mehrerer NAND -Gatter (oder auch Kombination mehrer NOR -Gatter) lassen sich alle logischen Verknüpfungen realisieren. %%A%% %%B%% %%\\overline{A \\land B}%% %%\\overline{A \\lor B}%% 0 0 1 1 0 1 1 0 1 0 1 0 1 1 0 0 Am Beispiel des NAND -Gatters zeigt das folgende Bild die Möglichkeiten der Substitution: XOR-Gatter Das XOR-Gatter (von engl. e X clusive OR ) hat meist zwei (oder auch mehr) Eingänge und einem Ausgang. Bei einem XOR-Gatter mit zwei Eingängen ist der Ausgang auf logisch 1, wenn einer der beiden Eingänge auf logisch 1 ist, aber nicht beide gleichzeitig. Dies entspricht der ausschließenden Disjunktion. Für zwei oder mehr Eingänge ist der Ausgang auf logisch 1, wenn an einer ungerade Anzahl von Eingängen eine logische 1 anliegt. In booleschen Funktionen wird die XOR Verknüpfung mittels \"%%\\oplus%%\" dargestellt. Wahrheitstabelle: %%A%% %%B%% %%A \\oplus B%% 0 0 0 0 1 1 1 0 1 1 1 0 Der Ausgang eines XOR Gatter ist logisch 1, wenn an einer ungeraden Anzahl an Eingängen eine 1 anliegt. Darstellungsformen Im europäischen Raum wird für die Darstellung von Schaltsymbolen die Norm IEC 60617 verwendet. In Schaltplänen findet man auch recht häufig die im amerikanischen Raum verbreitete Darstellungsform nach der Norm US ANSI 91-1984. Die Darstellung nach DIN 40700 ist veraltet. Rechengesetze Für die Operatoren der booleschen Algebra gilt die folgende Rangfolge (in absteigender Wertigkeit): Negation (%%\\neg%%) Konjunktion (%%\\land%%) Disjunktion (%%\\lor%%) Name AND OR Kommutativgesetz %%a \\land b = b \\land a%% %%a \\lor b = b \\lor a%% Assoziativgesetz %%( a \\land b ) \\land c = a \\land ( b \\land c )%% %%(a \\lor b) \\lor c = a \\lor (b \\lor c)%% Idempotenzgesetz %%a \\land a=a%% %%a \\lor a=a%% Distributivgesetz %%a \\land (b \\lor c) = (a \\land b) \\lor (a \\land c)%% %%a \\lor (b \\land c) = (a \\lor b) \\land (a \\lor c)%% Neutralitätsgesetz %%a \\land 1 = a%% %%a \\lor 0 = a%% Extremalgesetz %%a \\land 0 = 0%% %%a \\lor 1 = 1%% Doppelnegationsgesetz %%\\overline{ \\overline{a} } = a%% De Morgansche Gesetz %%\\overline{ a \\land b } = \\overline{ a } \\lor \\overline{b}%% %%\\overline{a \\lor b} = \\overline{a} \\land \\overline{b}%% Komplementärgesetz %%a \\land \\overline{a} = 0%% %%a \\lor \\overline{a} = 1%% Dualitätsgesetz %%\\overline{0} = 1%% %%\\overline{1} = 0%% Absorptionsgesetz %%a \\lor (a \\land b) = a%% %%a \\land (a \\lor b) = a%%","tags":"grundlagen_der_digitaltechnik","title":"Kombinatorik"},{"url":"https://www.semiversus.com/dic/robotik/python/kontrollstrukturen.html","text":"","tags":"python","title":"Kontrollstrukturen"},{"url":"https://www.semiversus.com/dic/rechnerarchitektur/logisim_prozessor.html","text":"Allgemeines Zur Übung wird ein Prozessor mit Hilfe von Logisim entwickelt. Vorgaben: - 8 Bit Register und Datenbus - Befehlsformat: 8 Bit (mit optionaler 8 Bit Konstante hinter dem Befehl) - Befehls- und Datenspeicher: jeweils 256 Bytes - Register: Akkumulator A, Indexregister IX Das vollständige Prozessormodell für Logisim steht für Übungszwecke zur Verfügung. Aufbau Datenpfad Der Datenpfad stellt mittels Multiplexer und Enable Signale die Verbindung der einzelnen Register und Funktionseinheiten her. Im Datenpfad sieht man die Register (A, IX), die Arithmetisch-Logische Recheneinheit (kurz ALU) und den Datenspeicher. ALU Die Arithmetisch-Logische Einheit besitzt zwei Eingänge für Operanden (A, B), einen Eingang zur Auswahl der durchzuführenden Rechenaoperation (OpALU), eine Ergebnisausgang und zwei Statusflags (Carry, Zero). Übersicht über die Operationen: OpALU Operation Beschreibung 000 Result=A Legt Operand A auf den Ausgang 001 Result=B Legt Operand B auf den Ausgang 010 Result=A+B Addiert A und B 011 Result=A-B Subtrahiert B von A 100 Result=A AND B Bitweise UND Verknüpfung 101 Result=A OR B Bitweise OR Verknüpfung 110 Result=A EOR B Bitweise Exclusive-OR Verknüpfung 111 Result=A>>1 Logisches Rechtsschieben von Operand A Das Linksschieben ist nicht als eigene Operation angeführt. Dazu kann aber die Addition genutzt werden. Eine Addition von x mit x entspricht x*2 oder einer Linksschiebe-Operation. Das Invertieren aller Bits kann auch mittels Exclusive-OR realisiert werden, indem die Exclusive-ODER Operation mit dem Register A und der Konstante 0xFF durchgeführt wird. MuxALU Der Operand B der ALU kann entweder aus dem Datenspeicher stammen oder als Konstante aus dem Befehlsspeicher ( Immed ) kommen. MuxMA Die Adresse des Datenspeichers kann entweder aus dem Indexregister IX oder als Konstante aus dem Befehlsspeicher kommen. EnA, En, StM Die Signale EnA ( Enable A ), EnIX ( Enable IX ) und StM ( Store Memory ) dienen zur Speicherung der Daten. Eine 1 bewirkt die Übernahme der Daten vom Eingang des Registers in den Speicher des Registers (bei der nächsten steigenden Taktflanke). Beispiele Betrachtet man nun nur den Datenpfad können verschiedene Operationen realisiert werden. Befehl EnA EnIX StM MuxALU MuxMA OpALU Beschreibung ld A, Imm. 1 0 0 1 X 001 Lädt Register A mit Konstante Imm. ld A, (IX) 1 0 0 0 0 001 Lädt Register A mit Wert an Adresse IX ld A, ( Imm. ) 1 0 0 0 1 001 Lädt Register A Wert an der Adresse Imm. ld IX, A 0 1 0 X X 000 Lädt Register IX mit dem Wert aus Register A ld IX, Imm. 0 1 0 1 X 001 Lädt Register IX mit der Konstante Imm. st (IX), A 0 0 1 X 0 000 Speichert Register A an die Adresse IX st ( Imm. ), A 0 0 1 X 1 000 Speichert Register A an die Adresse Imm. add A, Imm. 1 0 0 1 X 010 Addiert zu Register A eine Konstante add A, (IX) 1 0 0 0 0 010 Addiert zu Register A der Wert an Adresse IX add A, ( Imm. ) 1 0 0 0 1 010 Addiert zu Register A der Wert an Adresse Imm. nop 0 0 0 X X X Führt keine Operation aus (No Operation) Steuerwerk Das Steuerwerk dient zur Steuerung des Datenpfades. PC Die Befehle werden mittels PC ( Program Counter ) adressiert. Das Register PC wird um eins erhöht, um den nächsten Befehl adressieren zu können. Bei einem Sprung wird das Register PC mit einer Konstante aus dem Befehlsspeicher geladen. Befehlsspeicher Der Befehls- und Datenspeicher sind getrennt voneinander. Man spricht auch von getrennten Adressräumen. Dies entspricht dem Harvard-Modell. IR Das Register IR ( Instruction Register ) speichert den aktuellen Befehl. Dies ist notwendig, da die Befehlsausführung in zwei Takten erfolgt. Die Befehlsausführung geschieht in zwei Schritten: Fetch : Der Befehl wird mittels PC adressiert, aus dem Befehlsspeicher geholt und im Register IR gespeichert. Decode and Execute : Der Befehl wird dekodiert und ausgeführt. Dabei wird der Datenpfad entsprechend der Signale aus dem Instruktionsdekoder gesteuert. Instruktionsdekoder Der Instruktionsdekoder ist Teil des Steuerwerks. Ein Befehl wird dekodiert und die entsprechenden Signale für Multiplexer, Register usw. gesetzt. Beim internen Aufbau unseres Instruktionsdekoders sieht man, dass das Befehlsbyte in verschiedene Bereiche eingeteilt ist. IType (2 Bit): 00 - Datenoperation, 01 - Spungbefehl ITarget (2 Bit)): 00 - Speichert in Register A, 01 - Register IX, 10 - Datenspeicher, 11 - keine Speicherung IImmed (1 Bit): Der Befehl verwendet eine Konstante aus dem Befehlsspeicher IParam (3 Bit): Bei Datenoperationen: Wert für OpALU, bei Sprungbefehlen: Art des Bedingten Sprungs Das im Befehlsspeicher enthaltene Programm dekodiert sich damit folgenderweise: Adresse Wert Assembler Bedeutung 0x00 0x19 ld IX, 0x05 Lädt IX mit der Konstante 0x05 0x01 0x05 Konstante gehört zum vorherigen Befehl 0x02 0x01 ld A, (IX) Lädt den Wert von der Adresse IX 0x03 0x0a add A, 0x03 Addiert zum Register A die Konstante 0x03 0x04 0x03 Konstante gehört zum vorherigen Befehl 0x05 0x20 st (IX), A Speicher Register A an der Adress IX 0x06 0x48 jmp 0x03 Springe zur Adresse 0x03 0x07 0x03 Konstante gehört zum vorherigen Befehl Einschränkungen Unser Prozessorbeispiel beinhaltet weit nicht alle Funktionen eines mächtigeren Prozessors. So fehlt etwa ein Stackpointer oder die Möglichkeit, das PC Register zu sichern. Dies wäre notwendig, um aus Subroutinen zurückzukehren.","tags":"rechnerarchitektur","title":"Logisim Prozessor"},{"url":"https://www.semiversus.com/dic/digitale_signalverarbeitung/lti_systeme.html","text":"Allgemeines In der Nachrichtentechnik versteht man ein System als eine Anordnung von verbundenen Komponenten zur Realisierung einer Aufgabenstellung. Ein System kann im mathematischen Sinne als Funktion(en) verstanden werden, die einen Zusammenhang zwischen Ein- und Ausgängen herstellt. Je nachdem nach welcher der drei Komponenten (Eingang, Ausgang oder System) gesucht wird unterscheidet man: Systemanalyse - Das Ausgangssignal wird gesucht, gegeben ist das Eingangssignal und das System Systemsynthese - Das System wird gesucht, gegeben ist das Ein- und Ausgangssignal Meßtechnik - Das Eingangssignal wird gesucht, gegeben ist das System und das Ausgangssignal Einordnung von Systemen Lineare Systeme Linearität bedeutet, dass der Zusammenhang des Eingangs und des Ausgangs eines Systems eine Lineare Abbildung ist. Linearität Wenn der Eingang %%x_1[n]%% zum Ausgang %%y_1[n]%% führt und %%x_2[n]%% zum Ausgang %%y_2[n]%% führt, dann muss der addierte und skalierte Eingang %%a_1 x_1[n]+ a_2 x_2[n]%% zum addierten und skalierten Ausgang %%a_1 y_1[n]+ a_2 y_2[n]%% führen. Die Linearität ist eine sehr wichtige Systemeigenschaft, den dadurch wird es mögliche komplexe Eingangssignale in einfachere Teilsignale zu zerlegen und die resultierenden Ausgangssignale zu berechnen. Ein lineares System setzt voraus, dass beim Eingangssignal %%x[n]=0%% das Ausgangssignal %%y[n]=0%% ist, d.h. es darf keinen konstanten Term in der Systemgleichung geben (z.B. %%y[n]=x[n]+2%% ist ein nichtlineares System). Zeitinvariante Systeme Zeitinvarianz bedeutet, dass egal zu welchem Zeitpunkt ein Eingangssignal an ein System angelegt wird, das Ausgangssignal (bis auf die zeitliche Verzögerung) ident ist. Ein lineares System ist zeitinvariant, wenn die Koeffizienten der linearen Differentialgleichung konstant sind. In diesem Fall spricht man von LTI - (engl. für Linear Time Invariant ) Systemen. LTI Systeme sind mittels Digitaltechnik einfach zu realisieren. Bei Analogtechnik gibt hier z.B. Probleme bei der Alterung von Bauteilen oder Temperaturabhängigkeiten. Länge der Impulsantwort Die Impulsantwort enthält die vollständige Information um ein zeitdiskretes LTI System zu beschreiben. Je nach Art des Systems gibt es zwei Möglichkeiten: FIR - engl. für Finite Impuls Response , also endliche Impulsantwort IIR - engl. für Infinite Impuls Response , also unendliche Impulsantwort FIR In einem FIR System hat die Impulsantwort %%h[n]%% endlich viele Werte ungleich Null. Die Antwort eines solchen FIR -Systems kann einfach mittels Faltung des Eingangssignals und der Impulsantwort berechnet werden. Ein FIR System lässt sich wie folgt beschreiben: %%y[n]=h[0]\\cdot x[n] + h[1]\\cdot x[n-1] + h[2]\\cdot x[n-2] + \\ldots + h[N]\\cdot x[n-N]=\\sum\\limits_{k=0}&#94;N h[k] \\cdot x[n-k]%% IIR Ein IIR System liefert eine unendliche lange Impulsantwort. Dies kann der Fall sein, wenn z.B. durch eine Rückkopplung der Ausgang zum Zeitpunkt %%y[n]%% von %%y[n-1]%% abhängig ist. %%y[n]=\\sum\\limits_{k=0}&#94;\\infty h[k] \\cdot x[n-k]%% Speicher Der Ausgang eines speicherlosen Systems ist nur vom aktuellen Eingangswert abhängig. Um eine Abhängigkeit von vorangegangenen Eingangswerten zu ermöglichen benötigt das System einen Speicher, um diese Werte entsprechend vorzuhalten. Ein speicherloses LTI System kann den Eingangswert nur multiplizieren: %%y[n]=a x[n]%% Wenn das System einen Speicher besitzt, können auch %%N%% frühere Eingangswerte berücksichtigt werden: %%y[n]=a_0 x[n] + a_1 x[n-1] + a_2 x[n-2] + \\ldots = \\sum\\limits_{k=0}&#94;N a_k x[n-k]%% Ein System mit einem Speicher nennt man auch ein dynamisches System. Kausalität Ein System ist kausal , wenn es nur von aktuellen oder früheren Eingangswerten abhängt, aber keinen zukünftigen . Beim folgende System ist jeder Ausgangswert das arithmetische Mittel dreier Eingangswerte: %%y[n]=\\frac{1}{3}(x[n-1]+x[n]+x[n+1])%% Dieses System ist nicht kausal , da der Ausgangswert zum Zeitpunkt %%n%% von einem Eingangswert zum Zeitpunkt %%n+1%% abhängt. Das System mit der Eigenschaft der Mittelung von drei Werten lässt sich aber auch kausal formulieren: %%y[n]=\\frac{1}{3}(x[n-2]+x[n-1]+x[n])%% Stabilität Ein System gilt als stabil, wenn das Ausgangssignal bei beschränktem Eingangssignal nicht über alle Grenzen anwächst. Zur Definition von Stabilität gibt es verschiedene Methoden, wobei in der Systemtheorie die sogenannte BIBO -Stabilität üblich ist. BIBO steht für engl. bounded input, bounded output (beschränkter Eingang, beschränkter Ausgang) In einem LTI System lässt sich die BIBO Stabilität über die Impulsantwort ausdrücken, wenn diese absolut integrierbar ist: %%\\sum\\limits_{n=0}&#94;\\infty \\left|h[n]\\right|\\ < \\infty%% Jedes FIR System ist BIBO stabil, da die Summe über die Absolutwerte der Impulsantwort kleiner Unendlich ist (solange kein Koeffizient unendlich ist). Bei einem IIR System ist es möglich nicht BIBO stabil zu sein. So ist die ein IIR System mit der Impulsantwort %%h[n]=u[n]%% (Einheitssprung) nicht BIBO stabil, da die Summe der Werte des Ausgangssignals von 0 bis Unendlich gleich Unendlich ist. Als Gegenbeispiel ist ein System mit der Impulsantwort %%h[n]=e&#94;{-n}%% (für n größer gleich 0) BIBO stabil, obwohl die Impulsantwort unendlich lang ist, sie sich aber 0 immer weiter annähert und daher die Summe kleiner Unendlich ist.","tags":"digitale_signalverarbeitung","title":"LTI Systeme"},{"url":"https://www.semiversus.com/dic/programmierbare_logik/modellierungsarten.html","text":"Verhaltensmodellierung Bei der Verhaltensmodellierung wird ein System durch einen Algorithmus in VHDL Notation veschrieben. Es werden keine Gatter oder komplexere Komponenten direkt verwendet. Ein Verhaltensmodell ist im Prinzip eine Black Box Sicht des zu beschreibenden Systems. Ein Volladdierer lässt sich mittels Verhaltensmodellierung wie folgt beschreiben: entity fulladder is port ( x , y , cin : in std_ulogic ; s , cout : out std_ulogic ); end entity ; architecture behave of fulladder is begin s <= '0' when ( x = '0' and y = '0' and cin = '0' ) else '1' when ( x = '0' and y = '0' and cin = '1' ) else '1' when ( x = '0' and y = '1' and cin = '0' ) else '0' when ( x = '0' and y = '1' and cin = '1' ) else '1' when ( x = '1' and y = '0' and cin = '0' ) else '0' when ( x = '1' and y = '0' and cin = '1' ) else '0' when ( x = '1' and y = '1' and cin = '0' ) else '1' when ( x = '1' and y = '1' and cin = '1' ); cout <= '0' when ( x = '0' and y = '0' and cin = '0' ) else '0' when ( x = '0' and y = '0' and cin = '1' ) else '0' when ( x = '0' and y = '1' and cin = '0' ) else '1' when ( x = '0' and y = '1' and cin = '1' ) else '0' when ( x = '1' and y = '0' and cin = '0' ) else '1' when ( x = '1' and y = '0' and cin = '1' ) else '1' when ( x = '1' and y = '1' and cin = '0' ) else '1' when ( x = '1' and y = '1' and cin = '1' ); end architecture ; In der Beschreibung wird das Verhalten dargestellt, in diesem Beispiel mittels Umsetzung der Wahrheitstabelle. Strukturmodellierung Die Basis für den strukturellen VHDL Entwurf ist ein synchrones Design. Prinzipiell besteht jedes synchrone Design aus Kombinatorik und Flip-Flops (meist Register genannt), die alle auf einen gemeinsamen Takt synchronisiert sind. Um das Design zu strukturieren wird meist das Design meist als Datenpfades aufgebaut. Elemente eines Datenpfades sind dabei: Multiplexer Arithmetische Operatoren (Addierer, Subtrahierer, usw.) Logische Operatoren Komperatoren Register Diverse andere Elemente wie Vorzeichenerweiterung usw. Die Elemente und die Pfade zwischen den Elementen können entweder einzelne Signale sein oder mehrere zusammengefasste Signale (Busse). Beispiel Im folgenden Beispiel soll ein Zähler aufgebaut werden mit drei Eingangssignale value (Bus mit 8 Bit), load und clear . Wie in allen synchronen Designs wird ein gemeinsamer Takt für alle Register genutzt (hier clock ). Das Register hat eine Bitbreite von 8. Textuelle Beschreibung Die Funktion soll wie folgt sein: Wenn clear gleich 1 ist, soll der Zählerstand auf 0 gesetzt werden, ansonsten wenn load gleich 1 ist, soll der Zählerstand auf value gesetzt werden ansonsten soll der Zählerstand um value erhöht werden. Schaltung VHDL Entity entity sum is port ( clk : in std_ulogic ; value : in unsigned ( 7 downto 0 ); load : in std_ulogic ; clear : in std_ulogic ; result : out unsigned ( 7 downto 0 ) ); end entity ; VHDL Architecture architecture behave of sum is begin process ( clk ) begin if rising_edge ( clk ) then if clear = '1' then result <= ( others => '0' ); elsif load = '1' then result <= value ; else result <= result + value ; end if ; end if ; end process ; end architecture ; Timingdiagramm Test des Designs Online VHDL Modell mit Testbench Umsetzung des Volladdierers entity fulladder is port ( x , y , cin : in std_ulogic ; s , cout : out std_ulogic ); end entity ; architecture structural of fulladder is signal halfadder1_s : std_ulogic ; signal halfadder1_cout : std_ulogic ; signal halfadder2_cout : std_ulogic ; begin halfadder1 : entity work . halfadder port map ( x => x , y => y , cout => halfadder1_cout , s => halfadder1_s ); halfadder2 : entity work . halfadder port map ( x => halfadder1_s , y => cin , cout => halfadder2_cout , s => s ); cout <= halfadder1_cout or halfadder2_cout ; end architecture ; An diesem Beispiel für die strukturelle Modellierung sieht man den Aufbau mittels Komponenten. Dadurch ergibt sich eine Hierarchie der Komponenten. Datenflussmodellierung Bei der Datenfluss wird der Fluss der Daten modelliert. Dabei werden auf die Eingänge Transformationen angewendet, um die Ausgänge zu berechnen. entity fulladder is port ( x , y , cin : in std_ulogic ; s , cout : out std_ulogic ); end entity ; architecture dataflow of fulladder is begin s <= x xor y xor cin ; cout <= ( x and y ) or ( ( x xor y ) and cin ); end architecture ;","tags":"programmierbare_logik","title":"Modellierungsarten"},{"url":"https://www.semiversus.com/dic/programmierbare_logik/nebenlaeufigkeit.html","text":"Allgemeines Die architecture beschreibt den inneren Aufbau der Schaltung einer Komponente. Für diese Beschreibung stehen mehrere Anweisungen zur Verfügung, die eine Nebenläufigkeit ermöglichen. Betrachtet man die Komponeten eine digitale Schaltung laufen diese jede für sich gesehen unabhängig von der anderen. Die unabhängigkeit lässt sich auch mittels Nebenläufigkeit (engl. concurrent ) beschreiben, deswegen heißen diese Anweisungen auch engl. concurrent statements . Es gibt folgende concurrent statements : process Anweisungen - Beschreiben einen nebenläufigen Prozess (siehe process Anweisung ) Einfache Signalzuweisung - Weist einen Ausdruck einem Signal zu Bedingte Signalzuweisung - Je nach Bedingung wird der Wahr -Ausdruck oder der Falsch -Ausdruck zugewiesen Selektive Signalzuweisung - Entspricht einem Multiplexer, der abhängig von einem select -Ausdruck den entsprechenden Ausdruck auswählt. Einfache Signalzuweisung library ieee ; use ieee.std_logic_1164. all ; entity half_adder is port ( a_i : in std_ulogic ; b_i : in std_ulogic ; sum_o : out std_ulogic ; carry_o : out std_ulogic ); end entity ; architecture behave of half_adder is begin sum_o <= a_i xor b_i ; carry_o <= a_i and b_i ; end architecture ; In diesem Beispiel wird ein Halbaddierer beschrieben. Bei den Signalzuweisungen von sum_o und carry_o handelt es sich um einfache Signalzuweisungen. Auf der rechten Seite der Zuweisung steht ein Ausdruck, der durch Kombinatorik ausgewertet werden kann. Bedingte Signalzuweisung mittels when Für eine bedingte Signalzuweisung wird folgender Syntax verwendet: signal <= expr_true when cond else expr_false ; Als konkretes Beispiel können wir wieder den Halbaddierer verwenden. Das Exklusiv-Oder lässt sich auch mittels Bedingung realisieren. Ist der Eingang b_i gleich 0 enstpricht der Ausgang a_i , ansonsten entspricht der Ausgang not a_i : Beispiel sum_o <= a_i when b_i = '0' else not a_i ; Bei einer bedingten Signalzuweisung wird immer ein Multiplexer mit zwei Eingängen beschrieben. Verschachtelung Der Ausdruck im else Zweig kann auch wieder eine bedingte Signalzuweisung sein: result <= ( others => '0' ) when clear = '1' else input when load = '1' else counter + 1 ; Selektive Signalzuweisung mittels with / select Die selektive Signalzuweisung erlaubt den Aufbau eines Multiplexers mit mehreren Eingängen. Dazu wird folgender Syntax verwendet: with select_expr select signal <= expr1 when choice , expr2 when choice2 , expr3 when choice3 , -- ... exprN when others ; Beispiel Dazu ein ausführlicheres Beispiel, das die Umwandlung einer 4 Bit BCD Zahl in eine Sieben Segment Anzeige erlaubt (siehe auch Übung1 ): library ieee ; use ieee.std_logic_1164. all ; entity seven_seg_decoder is port ( digit_i : in std_ulogic_vector ( 3 downto 0 ); segments_o : out std_ulogic_vector ( 6 downto 0 ) ); end entity ; architecture behave of seven_seg_decoder is begin with digit_i select segments_o <= \"0000001\" when \"0000\" , -- display 0 \"1001111\" when \"0001\" , -- display 1 \"0010010\" when \"0010\" , -- display 2 \"0000110\" when \"0011\" , -- display 3 -- ... \"1111111\" when others ; end architecture ;","tags":"programmierbare_logik","title":"Nebenläufigkeit"},{"url":"https://www.semiversus.com/dic/programmierbare_logik/operatoren.html","text":"Allgemeines Logische Operatoren Als stehen folgende logische Operatoren zur Verfügung: and or nand nor xor xnor Beispiel für std_ulogic Typen:","tags":"programmierbare_logik","title":"VHDL Operatoren"},{"url":"https://www.semiversus.com/dic/programmierbare_logik/pla.html","text":"Allgemeines Programmierbare Logik hat im Vergleich zu festverdrahten Logikbausteinen folgende Vorteile: Hohe Integrationsdichte (viele Gatter auf kleiner Fläche) Teilweise im Feld neu programmierbar Hohe Taktfrequenzen möglich Es gibt je nach Programmierbarkeit folgende Klassifizierungen: ASIC s (Application Specific Integrated Circuits) sind integrierte Schaltkreise, die für ganz bestimmten Einsatzzweck entwickelt und gefertigt werden. Die Logik wird mittels Standardzellenentwurf entwickelt. Die Grundkosten sind sehr hoch, bei großen Stückzahlen sind die Kosten pro IC aber sehr gering. OTP (One Time Programmable) sind programmierbare Logikbausteine, die einmal programmierbar sind. Für die Speicherzellen wird dabei meist die Anti-Fuse Technologie genutzt. Mehrfach Wiederbeschreibbar sind programmierbare Logikbausteine, wenn als Speicherzellen EEPROM, Flash oder SRAM Zellen verwendet werden. Kombinatorische Grundstruktur Einfache programmierbare Logikbausteine realisieren meist eine Grundstruktur, die es ermöglicht, die disjunktive Normalform von booleschen Gleichungen zu realisieren. Dazu werden die Eingänge mittels eines UND-Arrays zu Mintermen zusammengefasst. Die Minterme werden dann durch ein ODER-Array zur disjunktiven Normalform zusammengefasst und an die Ausgangspins geführt. Mit dieser Struktur können alle kombinatorischen Schaltungen realisiert werden, die keine kombinatorische Rückkopplung oder Schleife enthält. Man unterscheidet bei den verschiedenen Bauformen, ob das UND- oder das ODER-Array programmierbar ist. Wird eine vom Anwender programmierbare Verbindung nicht genutzt, wird sichergestellt, dass dieses Signal einen Pegel hat, der die Funktionsweise nicht beeinträchtigt. So wird im UND-Array eine nicht verwendete Leitung auf einem 1 -Pegel gehalten und im ODER-Array auf einem 0 -Pegel. Um die Darstellung zu vereinfachen werden die parallelen Eingänge der UND und ODER Gatter meist zusammengefasst: Realisierung ROM Baustein Eine programmierbare Logik kann auch mit einem Speicher realisiert werden, wobei die Eingänge die Adresse darstellen und die Ausgänge sind die entsprechenden Datenausgänge. Der Speicherinhalt wird dadurch zur Darstellung einer Wahrheitstabelle. An A2 A1 A0 Dm D3 D2 D1 D0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 1 1 1 0 0 1 0 1 1 0 0 0 ... ... ... ... ... ... ... ... ... 1 1 1 1 0 0 1 0 1 Ein ROM Baustein entspricht der vorgestellten kombinatorischen Grundstruktur, wobei der Teil im UND-Array fest verdrahtet ist und nur der Teil des ODER-Arrays vom Benutzer programmierbar ist. Ein Speicher mit n Adressbits und m Datenbits kann eine Kombinatorik mit n Eingängen und m Ausgängen realisieren. PLA Bei einem PLA (Programmable Logic Array) sind sowohl UND- als auch das ODER-Array vom Anwender programmierbar. PAL PALs (Programmable Array Logic) werden heute nicht mehr eingesetzt. Sie sind aber die Vorstufe zu vielen Entwicklungen, die heute noch in Verwendung sind. Bei PALs ist das UND-Array frei programmierbar, das ODER-Array ist festverdrahtet. PAL Bausteine sind nur einmal programmierbar. GAL Eine Weiterentwicklung der PAL s stellen die GAL (Generic Array Logic) Bausteine von Lattice dar. Diese sind durch UV-Licht oder elektrisch löschbar und dadurch wiederbeschreibbar. An jedem Ausgang befindet sich eine OLMC (Output Logic Macro Cell). Diese Ausgangszelle enthält neben der Option, den Ausgang zu invertieren auch die Möglichkeit, ein Flipflop zu verwenden. Es besteht die Möglichkeit, Signale der OLMC wieder als Eingänge zu benutzen. Es ist möglich, den Ausgangstreiber hochohmig zu schalten und damit diesen Pin als Eingang zu benutzen.","tags":"programmierbare_logik","title":"Programmierbare Logische Anordnungen"},{"url":"https://www.semiversus.com/dic/programmierbare_logik/process.html","text":"Allgemeines Ein process hat folgende Eigenschaften: Er besteht aus sequentiellen Anweisungen. Eine Sensitivity List definiert die Signale, bei deren Änderung die Anweisungen ausgewertet werden. Die \"Ausführung\" läuft parallel zu allen anderen process Statements Der process selbst enthält keine nebenläufige Statements Es erlaubt eine funktionale Beschreibung ähnlich zu einer Programmiersprache Prozess für kombinatorische Schaltungen Bei kombinatorischen Schaltungen gibt es keine speichernden Elemente. Die Ausgänge sind direkt von den Eingängen abhängig. Beispiel half_adder_sum : process ( a_i , b_i ) begin carry_o <= a_i and b_i ; end process ; Dieser Prozess wertet den Ausdruck a_i and b_i aus und weist das Ergebnis carry_o zu. Diese Auswertung geschieht sobald sich a_i oder b_i ändert. Einen kombinatorischen Prozess zeichnet aus, dass bei der Auswertung nur die Pegel der Signale ausgewertet werden. Unvollständige Sensitivity Liste Für kombinatorische Prozesse ist eine vollständige Sensitivity Liste wichtig. Wird im obigen Beispiel etwa a_i vergessen baut die Synthese ein speicherndes Element ein (Latch)! Das obige Beispiel entspricht genau der folgenden nebenläufigen Anweisung: carry_o <= a_i and b_i ; Prozess für sequentielle Schaltungen Sequentiellen Schaltungen werden mittels speichernden Elementen ( Register ) realisiert. Bei synchronen Schaltungen arbeiten alle Register mit einem globalen Takt und reagieren auf die gleiche Taktflanke. Typischerweise wird die steigende Taktflanke gewählt, prinzipiell lässt sich aber auch die fallende Taktflanke wählen. Erkennung einer Takflanke Um eine Taktflanke erkennen zu können ist es notwendig, das Taktsignal in der Sensitivitätsliste hinzuzufügen. Damit wird der Prozess ausgewertet, wenn sich am Taktsignal etwas ändert. Name für das Taktsignal Es steht dem Entwickler frei, einen Namen für das Taktsignal zu wählen. In der Praxis wird meist clk oder clock gewählt, sofern es nur einen Takt im Design gibt. Gibt es mehrere Takte bieter sich ein Postfix wie clk_master an. In diesem Skriptum wird das Taktsignal mit clk bezeichnet. Im folgenden Beispiel wird die Verwendung der Funktion rising_edge gezeigt, um auf eine steigende Flanke an clk zu reagieren: Beispiel library ieee ; use ieee.std_logic_1164. all ; entity dff is port ( clk : in std_ulogic ; data_i : in std_ulogic ; data_o : out std_ulogic ); end entity ; architecture behave of dff is begin process ( clk ) begin if rising_edge ( clk ) then data_o <= data_i ; end if ; end process ; end architecture ; Statt der Funktion rising_edge lässt sich auch folgendes Konstrukt verwenden: process ( clk ) begin if clk 'event and clk = '1' then data_o <= data_i ; end if ; end process ; Anweisung innerhalb eines Prozesses if -Anweisung Die if -Answeisung wertet die Bedingung aus und entsprechend dann den Wahr Zweig oder gegebenenfalls den Falsch Zweig ( else ) oder eine andere Bedingung aus ( elsif ). Die if Anweisung wird mit endif; beendet. Beispiel process ( clear , load , input , counter ) begin if clear = '1' then result <= ( others => '0' ); elsif load = '1' then result <= input else result <= counter + 1 ; end if ; end process ; Vergleich mit nebenläufiger Anweisung Der Syntax von VHDL ist oft nicht sehr konsistent. Das gleiche Ergebnis lässt sich durch folgende Zuweisung als nebenläufige Anweisung realisieren: result <= ( others => '0' ) when clear = '1' else input when load = '1' else counter + 1 ; Es gilt die unterschiedliche Anordnung zu beachten. Die Funktionalität ist identisch. case -Anweisung Die case -Anweisung überprüft den Zustand eines Signals und führt davon abhängig eine Anweisung aus. Beispiel process ( digit_i ) begin case digit_i is when \"0000\" => segments_o <= \"0000001\" ; -- display 0 when \"0001\" => segments_o <= \"1001111\" ; -- display 1 when \"0010\" => segments_o <= \"0010010\" ; -- display 2 -- ... when others => segments_o <= \"1111111\" ; end case ; end process ; Vergleich mit nebenläufiger Anweisung Hier der Vergleich mit der entsprechenden with / select Anweisung als nebenläufige Anweisung: with digit_i select segments_o <= \"0000001\" when \"0000\" , -- display 0 \"1001111\" when \"0001\" , -- display 1 \"0010010\" when \"0010\" , -- display 2 -- ... \"1111111\" when others ; Auch hier ist die Funktionalität identisch, die Schreibweise unterscheidet sich aber stark. for -Schleife Die for Schleife erlaubt den vielfachen Aufbau eines Schaltungsteils. Beispiel process ( clk ) begin if rising_edge ( clk ) then for i in range 1 to 7 loop shift_reg ( i ) <= shift_i ( i - 1 ); end loop ; shift_reg ( 0 ) <= '0' ; end if ; end process ; Die Laufvariable i muss nicht eigens definiert werden. Der Typ für i ergibt sich aus den Elementen des Bereichs.","tags":"programmierbare_logik","title":"Process-Statement"},{"url":"https://www.semiversus.com/dic/rechnerarchitektur/programmiermodell.html","text":"Allgemeines Das Programmiermodell (engl. Instruction Set Architecture oder kurz ISA ) beschreibt den Aufbau eines Prozessors als abstraktes Modell. Dazu gehört: Beschreibung der Befehle, die der Prozessor ausführen kann Codierung der Befehle Adressierungsarten Aufbau der Register Zeitverhalten (Anzahl der benötigten Taktzyklen) Befehlssatz Die Gesamtheit aller Befehle eines Prozessors wird auch Befehlssatz genannt. Je nach Umfang des Befehlssatzes wird zwischen der CISC und RISC Designphilosophie unterschieden. Bei der Complex Instruction Set Computer Philosophie gibt es Befehle, die sehr komplexe Operationen ausführen können. Diese benötigen aber meist mehrere Taktzyklen. Viele klassische Prozessorarchitekturen (zum Beispiel Intel x86, Zilog Z80 und Motorola 68k) gelten als typische Vertreter von Prozessorarchitekturen mit CISC -Befehlssätzen. Der Begriff CISC wurde nachträglich eingeführt, um die bis damals vorherrschende Befehlssätze von neuartigen Design zu unterscheiden, die als RISC ( Reduced Instruction Set Computer ) Befehlssätze bezeichnet wurden. Bei RISC Befehlssätzen wird auf komplexe Befehle verzichtet, dadurch wird ein einfacheres Chipdesign ermöglicht. CISC benötigt im Vergleich weniger Programmspeicher, da die einzelnen Befehle komplexer sind und dadurch \"mehr\" ausführen können Meist benötigt ein Befehl mehrere Takte Die Realisierung eines CISC Prozessors wird oft mittels Mikrocode realisiert. Zur Ausführung eines Befehl führt das Steuerwerk den entsprechenden Mikrocode aus. Dieser Mikrocode steuert den Datenpfad des Prozessors an. Dadurch können komplexe Befehle realisiert werden. RISC Für die meisten Prozessoren mit RISC -Befehlssatz gilt: Load-Store Befehle: Speicherzugriffe erfolgen (nur) durch Load bzw. Store Befehle. Dies vereinfacht den Datenpfad Befehlsausführung meist in einem Taktzyklus Sehr viele frei verwendbare Register Befehle haben meist eine feste Länge Steuerwerk ist festverdrahtet (vgl. CISC mit Mikrocode) unabhängige Verarbeitungseinheiten ermöglichen Pipelining Befehle Transferbefehle Transferbefehle werden verwendet, um Information innerhalb eines Prozessors oder über den Speicher zu transferieren. Da die Daten an ihrem Quellort nicht verändert werden ist der Vorgang eigentlich eine Kopie. Je nach Prozessorarchitektur können dies ein- oder mehrere Bytes auf einmal sein. Eine Sondergruppe bilden Befehle, die mit dem Stack arbeiten. Es können Daten auf den Stack kopiert ( push ) oder vom Stack geholt ( pop ) werden. Arithmetische und logische Befehle Bei diesem Befehlen wird eine arithmetische Operation (Addition, Subtraktion, Multiplikation, usw.) oder eine logische Operation (UND-, ODER-Verknüpfung, usw.). Auch Schiebe- und Rotationsoperationen gehören hier dazu. Die Operationen selbst werden im Prozessor mittels einer Arithmetisch-Logischen Einheit (engl. arithmetic logic unit oder kurz ALU ) durchgeführt. Sprungbefehle Sprungbefehle dienen zum Ändern des Programmablaufes. Dabei wird zwischen unbedingten und bedingten Sprüngen unterschieden. Unbedingte Sprünge werden immer ausgeführt, bedingte Sprünge sind abhängig von einem Prozessorstatus. Bei Sprüngen wird darüber hinaus zwischen absoluten Sprüngen (referenziert auf die Befehlsspeicheradresse 0) oder relativen Sprüngen (relativ zum aktuellen Befehlszähler) unterschieden. Bei allen Nicht-Sprung Befehlen wird der Programmablauf mit dem nachfolgenden Befehl fortgesetzt. Sonstige Befehle Es gibt noch weitere Befehle, die in keine der aufgeführten Kategorien passen. Dazu zählen Befehle zum Umgang mit Interrupts, aktivierung bestimmter Betriebsarten (z.B. Sleep Modes) oder der häufig vorhandene No Operation Befehl, der während seiner Ausführung keine Änderung vornimmt und somit nur Zeit \"verbraucht\". Adressierungsarten Die Adressierungsarten beschreiben die Möglichkeiten, wie ein Prozessor auf die Daten für eine Operation zugreift. Dies gilt für die Operanden sowie für das Ergebnis einer Operation. Unmittelbare Adressierung Der benötigte Wert ist unmittelbar im Befehl selbst kodiert. Bei den meisten Prozessorarchitekturen gibt es Befehle, die ein Register mit einem unmittelbaren Wert laden. Auch absolute Sprünge sind meist durch einen Befehl mit unmittelbarer Adressierung realisiert. Registeradressierung Bei der Registeradressierung wird das gewünschte Register angegeben. Absolute Adressierung Bei der absoluten Adressierung wird eine Adresse im Speicher übergeben. Geladen wird der Wert an dieser Adresse. Relative Adressierung Die Relative Adressierung bezieht sich auf den Befehlszähler und wird für einen relativen Sprung verwendet. Dabei wird ein Wert zum Befehlszähler addiert bzw. subtrahiert. Indirekte Adressierung Bei der indirekten Adressierung wird ein Register adressiert, welches eine Adresse auf den Speicher darstellt. Geladen wird der Wert an dieser Adresse. Bei der indirekten Adressierung gibt es die Erweiterung, dass die Adresse, die im Register gespeichert ist entweder vor (Prä- ) oder nach (Post- ) der Ausführung des Befehls modifiziert wird. Meistens handelt es sich bei der Modifikation um eine Addition oder Subtraktion um 1 (Inkrement bzw. Dekrement). Indizierte Adressierung Bei der indizierten Adressierung kommen zwei Adressen zum Einsatz. Es wird ähnlich zur indirekten Adressierung ein Register adressiert, welches eine Adresse auf den Speicher darstellt. Zu dieser Adresse wird dann ein unmittelbar kodierter Offset addiert. Andere Adressierungsarten Es gibt ja nach Prozessormodell noch weitere Adressierungsarten. Es ist genauso möglich, dass ein Prozessor eine der oben angeführten Adressierungsarten nicht unterstützt. Für Signalprozessoren steht meist eine Modulo-Adressierung zur Verfügung. Dies entspricht einer Indirekten Adressierung mit einer Modifizierung der Adresse im Register, wobei für die Berechnung der neuen Adresse eine Modulo-Operation durchgeführt wird. Dadurch lassen sich effiziente Ringspeicher erzeugen. Anzahl der Operanden Befehlssätze können je nach Anzahl der Operanden, die ein Befehl nutzt, in Kategorien eingeteilt werden. Drei-Adress Architektur Bei dieser Architektur kann ein Befehl bis zu drei Adressen nutzen. Dabei werden zwei Adressen für die Operanden und die dritte Adresse für das Ergebnis genutzt. Beispiel (MIPS Architektur): addi $t1, $t0, 1 # $t1=$t0+1 Zwei-Adress Architektur Bei dieser Architektur stehen zwei Adressen pro Befehl zur Verfügung, wobei für viele Operationen eine Adresse für den Operand und gleichzeitig für das Ergebnis genutzt wird. Beispiel (AVR Architektur): add r24, r25 ; r24=r24+r25 Ein-Adress Architektur Bei dieser Architektur spricht man auch vom Akkumulator -Rechner, da sämtliche Rechenoperationen nur über das Akkumulator -Register laufen. Beispiel (68HC11 Architektur) adda $48 ; Addiere den Wert an der Speicherstelle 0x48 zum Akkumulator 0-Adress Architektur Die 0-Adress Architektur ist ein Spezialfall, bei der ein Befehl keine Operanden adressieren kann. Eine Realisierungsvariante ist ein Stack-Prozessor, der selbst keine Register besitzt, sondern alle Operationen am Stack ausführt. Um Werte auf den Stack zu bekommen ist allerdings die unmittelbare Adressierung notwendig. Beispiel (picoJava-II Architektur) iadd ; Hole zwei Integer vom Stack, addiere diese und lege diese wieder ab Typische Stack Maschinen haben Befehle wie push und pop um Daten auf den Stack zu legen oder vom Stack zu entfernen. Rechenoperationen wie add , mult , sub , usw. holen zwei Werte vom Stack, führen mit diesen die Rechenoperation aus und legen das Ergebnis wieder am Stack ab. Die Rechenoperation 4+5*(3+6) kann dabei folgenderweise realisiert werden: push 4 push 5 push 3 push 6 add ; addiert 3 und 6 und legt das Ergebnis 9 wieder am Stack ab mult ; multipliziert 5 und 9 und legt das Ergebnis 45 wieder am Stack ab add ; addiert 45 und 4 und legt das Ergebnis 49 wieder am Stack ab Nach der Ausführung liegt nur mehr ein Wert am Stack und dies ist das Ergebnis.","tags":"rechnerarchitektur","title":"Programmiermodell"},{"url":"https://www.semiversus.com/pages/projects-en.html","text":"Here will be a summary of some projects I'm working on. At the moment please see my GitHub page.","tags":"projekte","title":"Projects"},{"url":"https://www.semiversus.com/projekte/projekte.html","text":"Hier ensteht eine kurze Übersicht über meine Projekte. Momentan kann ich nur auf GitHub verweisen.","tags":"projekte","title":"Projekte"},{"url":"https://www.semiversus.com/dic/robotik/raspberry.html","text":"Inbetriebnahme Vorbereitungen Netzwerkkabel (ausgekreuzt) zur Verbindung zwischen Notebook und RaspberryPi SD- bzw. MicroSD-Karte mit aktuellem Raspian Jessie RaspberryPi (funktioniert mit allen Versionen) Versorgung für RaspberryPi (Netzteil mit Micro-USB Stecker oder über Notebook) Achtung: Spezifiziert mit bis zu 2 Ampere!","tags":"robotik","title":"RaspberryPi"},{"url":"https://www.semiversus.com/dic/komplexe_digitale_systeme/raspberrypi.html","text":"","tags":"komplexe_digitale_systeme","title":"Raspberry Pi"},{"url":"https://www.semiversus.com/dic/programmierbare_logik/register.html","text":"Allgemeines Register dienen in der Digitaltechnik dazu, Werte zu speichern. Register können durch verschiedene Arten von Flip-Flops realisiert werden (siehe sequentielle Logik ). Register mit Reset Name für das Reset Signal Wie beim Taktsignal steht es dem Entwickler frei, einen Namen für das Resetsignal zu wählen. In der Praxis wird meist ` oder reset verwendet. Je nach Anwendung kann es high - oder low -aktiv sein. Bei low -aktiven Resets wird meist ein Postfix verwendet, der darauf hindeutet (z.B. rst_n für NOT ). In diesem Skriptum wird das Resetsignal mit rst bezeichnet und ist bei High aktiv. Mit asynchronem Reset library ieee ; use ieee.std_logic_1164. all ; entity dff is port ( clk : in std_ulogic ; rst : in std_ulogic ; data_i : in std_ulogic ; data_o : out std_ulogic ); end entity ; architecture behave of dff is begin process ( rst , clk ) begin if rst = '1' then data_o <= '0' ; elsif rising_edge ( clk ) then data_o <= data_i ; end if ; end process ; end architecture ; Dem taktflanken getriggerten D FlipFlop wurde ein asynchroner Reset hinzugefügt. rst wurde der Sensitivitätsliste hinzugefügt, d.h. der process wird auch für Änderungen an rst getriggert. Innerhalb des process wird zuerst rst ausgewertet und erst dann auf eine steigende Taktflanke überprüft. Mit synchronem Reset In diesem Beispiel soll der Zustand nur bei einer steigenden Taktflanke von clk und bei rst auf 1 zurüclgesetzt werden. Das Zurücksetzen erfolgt also synchron zum Takt. library ieee ; use ieee.std_logic_1164. all ; entity dff is port ( clk : in std_ulogic ; rst : in std_ulogic ; data_i : in std_ulogic ; data_o : out std_ulogic ); end entity ; architecture behave of dff is begin process ( clk ) begin if rising_edge ( clk ) then if rst = '1' then data_o <= '0' ; else data_o <= data_i ; end if ; end if ; end process ; end architecture ; Die Sensitivity List besteht nur mehr aus dem clk Signal. Bei einer steigenden Taktflanke wird ausgewertet, ob rst gleich 1 ist. Wenn dies der Fall ist, wird der interne Zustand data_o auf 0 gesetzt, ansonsten wird der Wert von data_i übernommen. Mittels Initialisierung In FPGAs lässt sich der Zustand eines FlipFlops nach einem Ein-Ausschalt Zyklus auch durch die Initialisierung des entsprechenden Signals realisieren. Das Register hält dann den entsprechenden Initialisierungswert, nachdem der FPGA sein Design geladen. architecture behave of dff is signal d_reg : std_ulogic := '0' ; begin process ( clk ) begin if rising_edge ( clk ) then d_reg <= data_i ; end if ; end process ; data_o <= d_reg ; end architecture ;","tags":"programmierbare_logik","title":"Register"},{"url":"https://www.semiversus.com/dic/bussysteme/rs232.html","text":"Allgemeines Bei der seriellen Datenübertragung werden Bits (oder genauer Symbole) zeitlich hintereinander über eine Leitung übertragen. Die Anordnung der Bits, das Verpacken in einen Übertragungsrahmen (Frame) und die physikalischen Pegel werden durch das verwendete Protokoll definiert. Ein oft verwendeter Standard ist hier RS232 (bezeichnet oft auch mit EIA-RS-232 oder CCITT-V.24 ). Ein für jede serielle Übertragung wichtiger Begriff ist die Baudrate . Sie definiert die Anzahl der Symbole pro Sekunde. Dabei werden auch Symbole zur Synchronisierung mitgerechnet und unterscheidet sich damit von der eigentlichen Datenübertragungsrate. Aufbau RS232 RS232 Timingdiagramm (Bild: Gerald.deppe Public Domain) Übertragungsparameter Zur Beschreibung der Übertragung einer RS232 Schnittstelle benötigt man folgende Parameter: Anzahl der Datenbits : Üblicherweise 8 Bit. Teilweise aber auch 5,6,7 oder 9 Bit. Parität : Nach den Datenbits kann ein Paritätsbit übertragen werden. Es kann gerade Parität (beschrieben durch E für even ) oder ungerade Parität ( O für odd ) verwendet werden. Wird keine Parität verwendet, wird dies durch N beschrieben. Anzahl der Stoppbits : Meist wird 1 Stoppbit verwendet. Es sind aber auch 2 Stoppbits möglich. Zusammen mit der Baudrate schaut eine Beschreibung zum Beispiel so aus: 38400 Baud 8O1 - sprich 38400 Baud mit 8 Datenbits, ungerade Parität und ein Stoppbit. Sender und Empfänger einer seriellen Übertragung müssen die gleichen Übertragungsparameter einstellen, um eine Datenübertragung zu ermöglichen. Bei der Baudrate gibt es systembedingt oft Abweichungen. Dies einzelne Baudrate sollte +/- 2 Prozent Abweichung nicht überschreiten (bei 8N1). Zu den gängisten Baudrates zählen 4800 Baud, 9600 Baud, 19200 Baud 38400 Baud, 57600 Baud und 115200 Baud. Es finden auch 125kBaud, 250kBaud, 500kBaud und 1MBaud in der Praxis Verwendung.","tags":"bussysteme","title":"Serielle Datenübertragung mittels RS232"},{"url":"https://www.semiversus.com/dic/grundlagen_der_digitaltechnik/schaltnetze.html","text":"Allgemeines Es gibt viele Schaltnetze, deren Funktion häufig eingesetzt wird. Dabei werden die Schaltnetze nicht mehr auf der Ebene der Logikgatter betrachtet, sondern die Funktionalität wird abstrahiert. Multiplexer Ein Multiplexer (auch oft kurz \"Mux\") selektiert aus mehreren Eingängen einen einzelnen aus und gibt den Wert, der an diesem Eingang anliegt am Ausgang aus. Man unterscheidet die Multiplexer nach Anzahl der Eingänge. Die einfachste Form ist ein Multiplexer mit zwei Eingängen. In der Wahrheitstabelle wird ersichtlich, dass nur der jeweils ausgewählte Eingang den Ausgang beeinflusst. Ist s0 =0 so gilt a = e0 , bei s0 =1 gilt a = e1 . s0 e1 e0 a 0 x 0 0 0 x 1 1 1 0 x 0 1 1 x 1 Bei mehr als zwei Eingängen ist auch mehr als ein Selektionseingang notwendig. Halb-Addierer Der Halb-Addierer dient zur Addition von zwei einstelligen Binärzahlen. Als Ausgang stehen das Summenbit und ein Übertragsbit (engl. Carry ) zur Verfügung. Der Übertrag wird benötigt, sobald man zwei mindestens zweistellige Binärzahlen addieren will. x y s c 0 0 0 0 0 1 1 0 1 0 1 0 1 1 0 1 Voll-Addierer Der Voll-Addierer berücksichtigt einen Übertrag aus einer vorhergehenden Stufe. Der Voll-Addierer kann mittels zwei Halb-Addierer realisiert werden. Um nun zwei 4 Bit Zahlen zu addieren, werden insgesamt vier einzelne Addierer benötigt, die jeweils zwei Bit unter Berücksichtigung eines Übertrages der Vorstufe addieren. Der Addierer, der die niederwertigsten Bits addiert kann auch ein Halbaddierer sein, da kein Übertrag beachtet werden muss. Wird ein Voll-Addierer genutzt, muss der entsprechende Übertragseingang auf 0 gesetzt werden. Komparator Ein Komparator vergleicht zwei Binärzahlen gleicher Bitbreite miteinander. Eine einfache Ausführung des Komparators hat dabei nur einen \"ist gleich\"-Ausgang. Sind also beide Zahlen gleich groß, so wird der \"ist gleich\"-Ausgang auf 1 gesetzt. Eine Erweiterung stellt die Variante mit zusätzlichem \"größer\"- und \"kleiner\"-Ausgang dar. Um mehrere Komparatoren zu kombinieren, sind Eingänge für \"ist gleich\", \"größer\" und \"kleiner\" Signale der Vorstufe notwendig. Prioritätsenkoder Der Prioritätsenkoder gibt die Nummer des aktiven Eingangs aus, der die höchste Priorität hat. Im folgenden Beispiel gibt es vier Eingänge ( i0 bis i3 ), wobei i3 die höchste Priorität hat. Ist i3 aktiv, wird am Ausgang der Wert 3 ( y1 =1, y0 =1), unabhängig davon, welchen Zustand die anderen Eingänge haben. i3 i2 i1 i0 y1 y0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 x 0 1 0 1 x x 1 0 1 x x x 1 1","tags":"grundlagen_der_digitaltechnik","title":"Grundlegende Schaltnetze"},{"url":"https://www.semiversus.com/dic/komplexe_digitale_systeme/scheduling.html","text":"Allgemeines Unter Scheduling (englisch für „Zeitplanerstellung\"), versteht man das Erstellen eines Ablaufplanes (schedule), der Prozessen zeitlich begrenzt Ressourcen zuteilt. Dem Scheduler stehen als Entscheidungsbasis die anstehenden Aufgaben zur Verfügung. Kriterien Ein gutes Scheduling-Verfahren zeichnet sich dadurch aus, dass es die folgenden Kriterien optimiert: Durchsatz : Möglichst viele Prozesse werden in möglichst kurzer Zeit abgearbeitet. Effizienz : Die zur Verfügung stehenden Ressourcen werden möglichst vollständig ausgelastet. Fairness : Die Ressourcen werden den Prozessen gerecht zugeteilt, das heißt kein Prozess wird dauerhaft vernachlässigt. Man sagt auch, das Verfahren vermeide das „Verhungern\" (starvation) von Prozessen. Echtzeit : Prozesse, die zu einem bestimmten Zeitpunkt beendet sein müssen, werden so geplant, dass der Zeitpunkt eingehalten wird. Verweilzeit : Prozesse sollten möglichst schnell beendet sein. Einfach und schnell : Für Implementierungen kann es sinnvoll sein, möglichst wenig Ressourcen im Scheduler selbst zu verbrauchen. Präemptiv und Nicht-Präemptiv Beim nicht-präemptiven Verfahren übergibt ein Prozess die benötigten Ressourcen selbstständig, wenn diese nicht mehr benötigt werden. Dies gilt insbesondere für die Prozessorzeit. Wenn einem Prozess also Prozessorzeit zugeteilt wird kann dieser Prozess frei entscheiden, wann er die Kontrolle an das Betriebssystem zurück gibt. Dieses Verfahren wird auch kooperatives Verfahren genannt. Wenn ein Prozess durch einen Fehler die Kontrolle nicht zurück gibt bleibt das ganze System hängen . Dieses Verfahren kann aber große Vorteile bei Echtzeitbetriebssystemen haben, da es möglich ist, die Ressourcen sehr gut zu nutzen. Das präemtive (engl. preemptive) Verfahren hat die Möglichkeit, dem Prozess die Zuteilung des Prozessors zu entziehen. Dieses Verfahren wird meist mit festen Zeitschlitzen implementiert, nach deren Ende jeweils ein Prozesswechsel vollzogen wird. Scheduling Strategien Das größte Problem des Schedulers ist die Tatsache, dass die benötigten Betriebsmittel für die einzelnen Prozesse meist nicht im Vorfeld bekannt sind. Es lässt sich also im Allgemeinen keine optimale Planung erstellen, sondern der Scheduler muss dynamisch auf geänderte Anforderungen reagieren. Dabei können (abhängig vom Scheduler) verschiedene Zuteilungsstrategien zum Einsatz kommen. First In – First Out (FIFO), First-Come First-Served (FCFS) Hierbei werden alle Prozesse in der Reihenfolge ihres Eingangs bearbeitet. Eine Neuzuteilung der Prozesse findet erst statt, wenn der laufende Prozess zu warten beginnt oder seine Ausführung beendet ist. Diese Strategie erzielt eine gute Auslastung bezüglich der CPU, allerdings nicht bezüglich Ressourcen, die längere Zeit für eine Anforderung benötigen können, wie z. B. Ein-/Ausgabe oder Massenspeicher. Für Mehrbenutzersysteme ist die Strategie darüber hinaus wenig geeignet, da einzelne Benutzer so ggf. für längere Zeit (nämlich bei aufwendigen Prozessen anderer Benutzer) ausgeschlossen werden. Beispiel mit kooperativem Scheduling Startzeit Dauer Job A 0 4 Job B 1 3 Job C 2 2 Job D 5 1 Ausführung: 0 1 2 3 4 5 6 7 8 9 A A A A B B B C C D Shortest-Job-Next (SJN), Shortest Job First (SJF), Shortest Processing Time (SPT) Ein weiteres Verfahren, das nicht für Mehrbenutzersysteme geeignet ist. Es lässt sich in Fällen einsetzen, in denen die benötigte Rechenzeit für einzelne Aufgaben aus Erfahrungswerten gut vorhergesagt werden kann. Ein Nachteil ist, dass große Prozesse u. U. niemals die CPU zugeteilt bekommen, wenn sich immer kürzere Jobs vordrängeln. Können Prozesse unterbrochen werden, das heißt ein Prozesswechsel wird durchgeführt, wenn ein neu ankommender Prozess eine kürzere Ausführungszeit aufweist, als die verbleibende Ausführungszeit des aktuellen Prozesses, so spricht man von Shortest-Remaining-Time (SRT) oder Shortest-Remaining-Processing-Time (SRPT). Ausführung (gleiche Angaben wie Beispiel davor): 0 1 2 3 4 5 6 7 8 9 A A A A C C D B B B Earliest Due Date (EDD) Bei dieser Strategie werden diejenigen Prozesse zuerst ausgeführt, welche die geringste Deadline haben. Voraussetzung dafür sind statische Deadlines und gleichzeitiges Eintreffen voneinander unabhängiger Tasks. Dieses nichtunterbrechende Verfahren ist ideal, um die maximale Verspätung zu minimieren. Wenn Prozesse unterbrochen werden können spricht man von einer Terminabhängigen Ablaufplanung, Planen nach Fristen oder Earliest Deadline First (EDF). Diese Strategie kommt hauptsächlich in Echtzeitsystemen vor, da es damit möglich ist, eine definierte Antwortzeit für bestimmte Prozesse zu garantieren. Round Robin, Zeitscheibenverfahren Einem Prozess wird die CPU für eine bestimmte (kurze) Zeitspanne zugeteilt. Danach wird der Prozess wieder hinten in die Warteschlange eingereiht. Sind die einzelnen Zeitspannen unterschiedlich groß, so spricht man von Weighted Round Robin (WRR). Round-Robin behandelt alle Prozesse gleich, so dass einerseits kein Prozess unfair behandelt wird oder gar verhungert, es aber andererseits auch nicht möglich ist, Prozesse mit höherer Dringlichkeit bevorzugt abzuarbeiten. Der Durchsatz dieses Scheduling-Verfahrens ist im Allgemeinen weder besonders niedrig noch besonders hoch. Die Verwendung von Zeitschlitzen fester Länge macht Round-Robin unflexibel und führt dazu, dass Ressourcen häufig ungenutzt bleiben. Beispiel mit präemptivem Scheduling: Startzeit Dauer Job A 0 4 Job B 0 3 Job C 0 2 Job D 3 1 Ausführung: 0 1 2 3 4 5 6 7 8 9 A B C A B C D A B A Lotterie-Scheduling Hierbei handelt es sich um ein Wahrscheinlichkeits-Scheduling-Verfahren. Prozesse bekommen alle eine bestimmte Anzahl von Losen zugewiesen und der Prozess-Scheduler zieht ein Zufallslos, um den nächsten Prozess auszuwählen. Die Aufteilung der Lose muss nicht gleich sein. Wenn man einem Prozess mehr Lose zuweist, erhöht das seine relativen Chancen, ausgewählt zu werden. Diese Technik kann man benutzen, um sich anderen Scheduling-Verfahren, wie zum Beispiel dem Shortest-Job-Next-Verfahren und dem Fair-Share-Scheduling, anzunähern. Lotterie-Scheduling löst das Problem des Verhungerns. Wenn man jedem Prozess mindestens ein Los gibt, garantiert dies, dass es eine Wahrscheinlichkeit von über 0 % gibt, dass dieser Prozess bei der jeweils nächsten Scheduling-Operation ausgewählt wird. Prioritätsscheduling Bei diesen Strategien wird jedem Prozess eine Priorität zugeordnet. Die Abarbeitung erfolgt dann in der Reihenfolge der Prioritäten. Rate Monotonic Scheduling (RMS): Die Priorität wird aus der Periodenlänge berechnet (Prozesse mit kürzeren Perioden haben höhere Priorität). Deadline Monotonic Scheduling (DMS): Die Priorität wird aus der relativen Deadline berechnet (Prozesse mit größeren Deadlines haben höhere Priorität. Man kann auch mehreren Prozessen die gleiche Priorität geben, sie werden dann in Eingangsreihenfolge ausgeführt, oder mit einem untergeordneten Zeitscheibenverfahren innerhalb der gleichen Priorität abgewechselt (zum Beispiel Multilevel Feedback Queue Scheduling oder Shortest-Elapsed-Time (SET) ) Die Prioritäten können auch dynamisch sein, wobei sich die Priorität eines Prozesses mit der Zeit erhöht, damit auch niedrig priorisierte Prozesse irgendwann bearbeitet werden und nicht ständig von höher priorisierten Prozessen verdrängt werden. Prioritätsinversion An einer Prioritätsinversion sind mehrere Prozesse mit unterschiedlicher Priorität und eine Ressource beteiligt. Die Ressource wird hierbei mit wechselseitigem Ausschluss exklusiv belegt (etwa einem Semaphor). Ein Prozess mit hoher Priorität will auf eine Ressource zugreifen, kann dies aber nicht, da die Ressource bereits von einem niedriger priorisierten Prozess belegt ist. Der hoch priorisierte Prozess muss warten, bis der andere Prozess die Ressource wieder freigibt. Dadurch sind die Prozess-Prioritäten in einer ersten Form der Prioritätsinversion vertauscht. Existiert nun ein Prozess mit mittlerer Priorität, der die fragliche Ressource nicht verwendet, kann dieser mittel priorisierte Prozess den niedrig priorisierten verdrängen, d.h. der mittel priorisierte Prozess wird anstelle des niedrig priorisierten Prozesses ausgeführt. Der niedrig priorisierte Prozess kann die Ressource nun nicht mehr freigeben, so dass der hoch priorisierte Prozess nicht zur Ausführung kommt. Damit hindert der mittel priorisierte Prozess indirekt auch den hoch priorisierten Prozess an der Ausführung, was er nach dem Prinzip des Prioritäts-Schedulings nicht darf. Die Priorität des hoch priorisierten Prozesses und des mittel priorisierten Prozesses sind somit in einer zweiten Form der Prioritätsinversion vertauscht. Aushungern Zur Aushungerung von Prozssen (engl. Starvation) kommt es, wenn niederpriore Prozesse nie zur Ausführung kommen, da immer höher priore Prozesse an die Reihe kommen. Ein Mittel zur Vermeidung von Aushungerung ist das Priority Aging . Dabei wird die Priorität eines Prozess während der Laufzeit erhöht, wenn er nicht zur Ausführung kommt. Irgendwann ist diese dynamische Priorität höher als die der anderen Prozesse und der Prozess kommt zur Ausführung. Priority Aging ist auch eine mögliche Lösung zur Prioritätsinversion.","tags":"komplexe_digitale_systeme","title":"Scheduling"},{"url":"https://www.semiversus.com/dic/grundlagen_der_digitaltechnik/sequentielle_logik.html","text":"Allgemeines Bei der Betrachtung von kombinatorischen Schaltungen geht man von einer Zustandslosigkeit des Schaltnetzes aus. Damit können keine Informationen (über die Schaltungsfunktion selbst hinaus) gespeichert werden. Die sequentielle Logik ist das Teilgebiet der Digitaltechnik, welches sich mit dem Speichern von Information beschäftigt. Die Ausgänge einer Schaltung mit sequentieller Logik hängen nun also nicht mehr ausschließlich von den Eingängen ab sondern zusätzlich vom Zustand der enthaltenen Speicherelemente. Speicherelement Ein Speicherelement kann ein Bit speichern und besitzt zwei stabile Zusände (0 oder 1). Es wird deshalb auch als bistabile Kippstufe bezeichnet. Gewöhnlicherweise wird der Zustand nur gespeichert, solange eine Spannungsversorgung vorhanden ist. Prinzip der Rückkopplung Speicherelemente beinhalten immer eine Art von Rückkopplung, um den Zustand speichern zu können. Bei der dargestellten Schaltung wird ein Multiplexer so verschalten, dass ein Eingang direkt mit dem Ausgang verbunden ist. Dadurch ergibt sich folgende Funktionalität: Transparente Phase G =1 : Der Eingang 1 des Multiplexers, an dem das Signal D anliegt, wird auf den Ausgang ausgegeben. Wenn also G gleich 1 ist folgt das Signal Q dem Signal D . Halte Phase G =0 : Beim Umschalten des Signals G von 1 auf 0 liegt am Eingang 0 des Multiplexers das Signal Q an. Dieses Signal wird dann am Ausgang des Multiplexers ausgegeben. Es wird also das Signal D zum Umschaltzeitpunkt gehalten. Pegelgesteuerte Latches Laut Definition ist ein Latch ein Speicherelement, welches abhängig vom Pegel der Eingänge den Zustand ändert. Anders ist dies beim Flip-Flop , welches per Definition nicht vom Pegel abhängig, sondern von einer Flanke des Taktsignals den neuen Zustand einnimmt. In der Praxis werden die Begriffe Latch und Flip-Flop oft als äquivalente Begriffe verwendet. Um Missverständnisse zu vermeiden wird in diesem Skriptum immer streng zwischen Latch und Flip-Flop unterschieden. Transparentes RS Latch Anhand der Schaltung und des Impulsdiagramm können wir die Funktionsweise des RS Latch nachvollziehen. Angenommen wird ein Anfangszustand von %%Q%% gleich 0 und %%\\overline{Q}%% gleich 1. Im Impulsdiagramm sieht man folgenden Signalverlauf: Phase S R Bemerkung 0 0 0 Das Latch hält den aktuellen Zustand und ist stabil. 1 1 0 Damit wechselt der Ausgang %%Q%% auf 1 und der Ausgang %%\\overline{Q}%% wechselt auf 0. 2 0 0 Das Latch hält den Zustand und ist stabil. 3 0 1 Damit wechselt der Ausgang %%Q%% auf 0 und der Ausgang %%\\overline{Q}%% wechselt auf 1. 4 0 0 Das Verhalten entspricht wieder Phase 0. 5 1 0 Der Ausgang %%Q%% wechselt auf 1 und der Ausgang %%\\overline{Q}%% auf 0. 6 1 1 Der Ausgang %%Q%% und %%\\overline{Q}%% sind gleich 0. 7 0 0 Das Verhalten ist nicht definiert. Es kommt zur Metastabilität. Aufgrund des Verhaltens können wir folgende Punkte zusammen fassen: Ist R und S auf 0, wird der momentane Zustand behalten. Ist R auf 0 und S auf 1, wird der Ausgang %%Q%% auf 1 und %%\\overline{Q}%% auf 0 gesetzt. Deshalb spricht man beim Eingang S vom Set -Eingang. Ist R auf 1 und S auf 0, wird der Ausgang %%Q%% auf 0 und %%\\overline{Q}%% auf 1 gesetzt. Deshalb spricht man beim Eingang R vom Reset -Eingang. Für die jetzigen Verhalten sind die Ausgänge %%Q%% und %%\\overline{Q}%% immer invertiert zu einander, deshalb auch diese Bezeichnung. Der Zustand R und S gleich 1 ist zu vermeiden. Während diesem Zustand ist das Latch zwar stabil, die Ausgänge sind aber nicht mehr invertiert zu einander, sondern beide auf 0. Undefiniert wird das Verhalten, wenn beide Eingänge auf 1 sind und gleichzeitig auf 0 wechseln. Das hier gezeigt RS Latch ist mittels NOR -Gatter aufgebaut, deswegen spricht man auch vom RS-NOR-Latch. Im folgenden sieht man ein RS Latch, welches mittels NAND -Gatter aufgebaut ist. Man spricht dann vom RS-NAND-Latch. Taktzustandgesteuertes RS Latch Bei einem taktzustandgesteuertem RS Latch wird ein zusätzlicher Eingang C hinzugefügt. Von diesem Eingang C hängt nun ab, ob das Latch transparent ( R und S können den Zustand ändern) oder ob es im Halte Modus betrieben wird. Im Halte Modus können die Eingänge R und S den Zustand nicht ändern, der momentane Zustand wird also gehalten. Taktzustandgesteuertes D Latch In der Praxis gibt es viele Anwendungen, in denen ein Bit gespeichert werden soll. Die Schaltung eines taktzustandgesteuerten RS Latch wird also so erweitert, dass ein einzelner Eingang die Funktion von R und S übernimmt. Hier werden die ursprünglichen Eingänge R und S durch den Eingang D ersetzt. Dieser Eingang hat steuert direkt den ursprünglichen Set -Eingang an und in invertierter Form den ursprünglichen Reset -Eingang. Für den Eingang C gleich 1 gilt: Ist Eingang D gleich 1 wird das RS Latch gesetzt, bei D gleich 0 wird es zurückgesetzt. Ist der Eingang C auf 0 ist das D Latch im Halte Modus. Flankengetriggerte Flip-Flops Es gibt viele Anwendungen, die ein Speicherelement benötigen, welches auf eine Taktflanke reagiert. Der transparente Modus ist hier nicht gewünscht. D Flip-Flop Um dies zu erreichen werden zwei Latches miteinander kombiniert: Ist der Eingang C gleich 1, so ist das Master Latch transparent und das Slave Latch im Halte Zustand. Ist der Eingang C gleich 0, hält das Master Latch seinen Zustand und das Slave Latch ist transparent. Wenn C also von 0 auf 1 wechselt, wird der Zustand am Eingang D gespeichert und am Ausgang ausgegeben. Man spricht in diesem Fall von einem Flip-Flop, das auf die positive Flanke des Signals C reagiert. Die Flankentriggerung wird im DIN Symbol mittels einem Dreieck am Eingang symbolisiert. Als Beispiel für ein Datenblatt dient uns ein 74HC74. Dieser Baustein enthält zwei flankengetriggerte D-Flip-Flops mit asynchronem Reset und Set Eingang ( Datenblatt ). RS Flip-Flops Durch Kombination von zwei Latches in dieser Master-Slave Anordnung lässt sich auch ein RS Flip-Flop konstruieren. JK Flip-Flops Bei RS Flip-Flops gilt es nach wie vor den Zustand von gleichzeitig gesetztem R und S zu vermeiden. Durch eine zusätzliche Beschaltung wird ein RS-Flipflop zu einem JK-Flipflop. Für ein JK Flipflop gilt folgende Funktionstabelle: J K %%Q%% %%\\overline{Q}%% Beschreibung 0 0 %%Q_{-1}%% %%\\overline{Q_{-1}}%% Halten 0 1 0 1 Zurücksetzen 1 0 1 0 Setzen 1 1 %%\\overline{Q_{-1}}%% %%Q_{-1}%% Toggeln Hier wird also das gleichzeitige Setzen der Eingänge genutzt, um eine neue Funktion einzuführen: Das Invertieren des aktuellen Zustandes. T Flip-Flop Ein T Flip-Flop reagiert auf eine Taktflanke und hat einen Eingang. Der Eingang gibt an, ob der Zustand beibehalten werden soll ( T =0) oder ob er wechseln soll ( T =1). Asynchrone Eingänge Je nach Bauart können auch noch zusätzliche asynchrone Eingänge vorhanden sein. Diese asynchronen Eingänge verändern den Zustand unabhängig vom Taktsignal. So kann ein asynchroner Reset genutzt werden, das Flip-Flop unabhängig vom Takt in einen definierten Zustand zu bringen.","tags":"grundlagen_der_digitaltechnik","title":"Sequentielle Logik"},{"url":"https://www.semiversus.com/dic/digitale_signalverarbeitung/signale.html","text":"Allgemeines Ein Signal ist einer messbaren physikalischer Größe (z.B. Spannung) eine Information zuordnet. Dabei ändert sich im Allgemeinen der Betrag als Funktion der Zeit. Kontinuierliche und diskrete Signale Analogsignal Ein Analogsignal ist im Rahmen der Signaltheorie eine Form eines Signals mit stufenlosem und unterbrechungsfreiem Verlauf. Ein Analogsignal wird als glatte Funktion beschrieben und es lässt sich damit beispielsweise der zeitlich kontinuierliche Verlauf einer physikalischen Größe wie der Schalldruck in Form eines analogen Audiosignals beschreiben. Der Wertebereich eines Analogsignals wird als Dynamikumfang bezeichnet. Im Gegensatz zu einem Digitalsignal weist ein Analogsignal einen stufenlosen und beliebig feinen Verlauf auf und kann im Dynamikbereich theoretisch unendlich viele Werte annehmen. Bei realen physikalischen Größen ist die Auflösung allerdings durch Störungen wie das Rauschen oder durch Verzerrungen begrenzt. Wert- und zeitkontinuierliches Signal Bei einem Analogsignal spricht man auch von einem Signal, das wert- und zeitkontinuierlich ist. Zeitdiskrete Signale Ein zeitdiskretes Signal kann als Folge %%x[n]%% von reellen Zahlen mit %%n \\in \\mathbb{N}%% beschrieben werden. Der Index %%n%% stellt die normierte Zeitvariable dar, welche auf die Abtastrate normiert ist. Üblicherweise erfolgt die Abtastung zu konstanten Abständen. Wertkontinuierliches und zeitdiskretes Signal Hier spricht man von einem Signal, das wertkontinuierlich und zeitdiskret ist. Die Darstellung wird im englischen oft als Stem - oder Lollipop -Graph bezeichnet. Die Werte zwischen den diskreten Abtastzeitpunkten sind nicht 0 sondern undefiniert. Wertdiskrete Signale Digitale Systeme nutzen AD- und DA-Wandler um Analogsignale in digitale Werte zu wandeln. Bei dieser Quantisierung wird das wertkontinuierliche Signal einer Quantisierungsstufe von aneinandergrenzender Intervalle endlicher Zahl zugewiesen. Wertdiskretes und zeitkontinuierliches Signal Bei diesem Plot ist die Zeit kontinuierlich, die möglichen Werte hingegen diskret. Der nächste Plot zeigt ein Signal, das wert- und zeitdiskret ist. Wert- und zeitdiskretes Signal Während sich zeitkontinuierliche Signale nur als Funktion darstellen lassen kann man bei zeitdiskreten Signalen auch eine Folge angeben. Im obigen Beispiel wäre dies: %%x[n]=(\\ldots,\\ 0,\\ 3,\\ 3,\\ 2,\\ 0,\\ {-1},\\ \\underline{0},\\ 2,\\ 4,\\ 3,\\ 1,\\ 0,\\ 0,\\ \\ldots)%% Um die Position des Index 0 zu markieren wird der entsprechende Wert unterstrichen. Die Folge wird aber auch oft wie folgt angeschrieben: %%x[n]=0\\quad 3\\quad 3\\quad 2\\quad 0\\quad {-1}\\quad \\underline{0}\\quad 2\\quad 4\\quad 3\\quad 1\\quad 0\\quad 0%% In weiterer Folge werden ausschließlich zeitdiskrete Signale behandelt. Transformation von Signalen Verschiebung im Zeitbereich Bei einer Verschiebung im Zeitbereich wird ein Signal um ein oder mehr Abtastintervalle nach links oder rechts verschoben. Für die folgenden Beispiele wird dieses Ausgangssignal %%x[n]%% verwendet: Beispielsignal Um die Werte für %%x[n-1]%% zu ermitteln, werden für %%n%% alle natürlichen Zahlen eingesetzt. An der Position 0 ist dies also der Wert von %%x[-1]%%, für die Position 1 der Wert von %%x[0]%% usw. Das Signal wird also insgesamt nach rechts geschoben. Verschiebung nach rechts Wird eine positive Zahl zum Index addiert verschiebt sich das Signal nach links: Verschiebung nach links Spiegelung im Zeitbereich Bei der Spiegelung des Signals um die Y-Achse wird der Index negiert. Der Wert an der Position 0 bleibt gleich, der Wert an der Position 1 ist gleich %%x[-1]%%, usw. Spiegelung um die Y-Achse Skalierung im Zeitbereich Bei der Skalierung wird der Index mit einem Faktor multipliziert. Ist dieser Faktor größer als 1 wird das Signal gestaucht. Bei einer Stauchung gehen unmittelbar Werte verloren: Skalierung um Faktor 2 Ist der Faktor kleiner als 1 wird das Signal gestreckt. Nicht definierte Indexe werden mit dem Wert 0 ausgegeben: Skalierung um Faktor 0.5 Kombination von Transformationen Wenn Verschiebung, Spiegelung und Skalierung gleichzeitig angewendet werden sollen ist die Reihenfolge wichtig: Verschieben Spiegeln Skalieren Um die Impulsfolge für das Signal %%x[-2n+2]%% zu ermitteln wird das Signal zuerst Verschoben: Verschiebung nach links Anschließend gespiegelt: Spiegelung Und zum Schluss skaliert: Skalierung Eigenschaften von Signalen Gerade und ungerade Signale Ein Signal ist gerade wenn gilt %%x[n]=x[-n]%%, d.h. wenn das Signal gleich dem um die Y-Achse gespiegelten Signal ist. Beispiel für ein gerades Signal Ein Signal ist ungerade wenn gilt %%x[n]=-x[-n]%%, d.h. wenn das Signal gleich dem um den 0-Punkt um 180 Grad rotierten Signal ist. Diese Symmetrie forder auch, dass der Wert an der Position 0 gleich 0 ist. Beispiel für ein ungerades Signal Jedes Signal lässt sich in seine gerade und ungerade Komponente zerlegen. Für die gerade Komponente gilt: %%y_{gerade}[n]=\\frac{1}{2}(x[n]+x[-n])%% Für die ungerade Komponente gilt: %%y_{ungerade}[n]=\\frac{1}{2}(x[n]-x[-n])%% Periodische Signale Ein Signal ist periodisch, wenn es die Bedingung %%x[n]=x[n+k*P]%% erfüllt, wobei %%k \\in \\mathbb{N}%% und %%P%% das Periodenintervall darstellt. Periodisches Signal mit der Periode 4 Periodisches Signal mit dem Sonderfall der Periode 1 Kausale Signale Ein Signal nennt man kausal , wenn alle Werte des Signals auf der negativen Zeitachse Null sind. Beispiele dafür sind der Einheitsimpuls oder der Einheitssprung. Sind die Werte des Signals auf der negativen Zeitachse ungleich Null spricht man auch von einem antikausalen Signal. Elementarsignale Einheitimpuls Der Einheitsimpuls %%\\delta[n]%% (auch Dirac-Impuls genannt) ist definiert durch: %%\\delta[n]=\\begin{cases} 1 & \\text{für } n = 0 \\\\ 0 & \\text{für } n \\neq 0 \\end{cases}%% Einheitsimpuls Ausblendeigenschaft Der Einheitsimpuls hat eine Ausblendeigenschaft: Wird ein beliebiges Signal mit dem Einheitsimpuls multipliziert, sind alle Werte 0, außer dem Wert an Position 0 - dieser entspricht dem ursprünglichen Wert des Signals an der Position 0. Wird der Einheitsimpuls zusätzlich zeitlich verschoben, lässt sich auch die Ausblendeigenschaft entsprechend steuern. Es gilt: %%x[n]\\cdot\\delta[n-k]=\\begin{cases} x[n] & \\text{für } n = k \\\\ 0 & \\text{für } n \\neq k \\end{cases}%% Einheitssprung Der Einheitssprung %%u[n]%% ist definiert durch: %%u[n]=\\begin{cases}1 & \\text{für } n \\geq 0 \\\\ 0 & \\text{für } n < 0 \\end{cases}%% Einheitssprung Der Einheitssprung kann auch als Summe von vielen Einheitsimpulse aufgefasst werden: %%u[n]=\\delta[n] + \\delta[n-1] + \\delta[n-2] + \\delta[n-3] + \\ldots=\\sum\\limits_{k=0}&#94;\\infty \\delta[n-k]%% Signalsynthese Ein Signal lässt sich aus beliebig vielen Komponenten zusammensetzen: Zusammengesetztes Signal","tags":"digitale_signalverarbeitung","title":"Signale"},{"url":"https://www.semiversus.com/dic/programmierbare_logik/signaltypen.html","text":"Allgemeines Um eine digitale Schaltung beschreiben zu können benötigt man Leitungen, um einzelne Komponenten miteinander zu verbinden. Leitungen entsprechen bei VHDL sogennanten Signalen (Schlüsselwort signal ). Um in VHDL ein Signal zu definiere muss das Signal einen bestimmten Signaltyp haben. Der einfachste Signaltyp ist bit . Dieser Signaltyp kennt die beiden Werte 0 und 1 . Dies mag für digitale Schaltungen auf den ersten Blick ausreichend erscheinen, es gibt aber einige Situationen, in denen diese beiden Werte nicht ausreichen. Signale werden wie folgt definiert: signal < name > : < typ > ; -- Signal <name> ist vom Typ <typ> und wird nicht initialisert signal < name > : < typ > := < default > ; -- Signal <name> ist vom Typ <typ> und wird mit <default> initialisiert Standard Logic 1164 Die der Bibliothek Standard Logic 1164 werden Signaltypen definiert, die mehr als 0 und 1 darstellen können. Um diese Bibliothek in einer VHDL Datei zu verwenden sind folgende zwei Zeilen notwendig: library ieee ; use ieee.std_logic_1164. all ; Diese Typen haben 9 Werte (d.h. werden sie auch 9-wertige Logik genannt) U : undefiniert - wird für nichtinitalisierte Signale in der Simulation verwendet X : unbekannt (starker Treiber) - wenn zwei Ausgänge miteinander verbunden werden, die gegeneinander treiben ( 0 und 1 ) 0 : logische Null (starker Treiber) 1 : logische Eins (starker Treiber) Z : hochohmig W : unbekannt (schwacher Treiber) L : logische Null (schwacher Treiber) H : logische Eins (schwacher Treiber) - : unwichtig (vgl. don't care in KV-Diagrammen) Werden mehrere Ausgänge zusammengeschalten setzen sich starke Treiber gegenüber schwachen durch. Ein U setzt sich gegenüber aller anderen Werten durch. Die Funktion, die die Auflösung beschreibt nennt sich resolution -Funktion. Resolved Signale Innerhalb eines FPGAs gibt es nie die Notwendigkeit mehrer Ausgänge direkt miteinander zu verbinden. Man hat immer die Möglichkeit, dies über eine Kombinatorik zu tun. std_logic und std_ulogic Der Signaltyp std_logic wird in der Bibliothek Standard Logic 1164 definiert und nutzt die oben gezeigte 9-wertige Logik. Der Signaltype std_logic ist resolved , d.h. es ist möglich mehrere Ausgänge direkt miteinander zu verbinden. Dies kann eine Fehlersuche erschweren, wenn versehentlich ein Signal von zwei Treibern angesteuert wird. Je nach Synthese- Tool wird kein Fehler angezeigt. Um nun zu verhindern, dass versehentlich zwei Treiber ein Signal ansteuern gibt es den Signaltyp std_ulogic . Das U steht dabei für unresolved - es wird also bei mehreren Treibern nicht aufgelöst. Das Synthese-Tool gibt also auf alle Fälle einen Fehler aus. Was spricht für std_logic ? Viele bestehende Beispiele und Lösungen verwenden std_logic Generierte VHDL Beschreibungen enthalten oft std_logic Was spricht für std_ulogic ? Es ist nicht versehentlich möglich, mit mehreren Treibern ein Signal anzusteuern Simulationen sind (manchmal) schneller, da es die Resolution -Funktion nicht benötigt Eine Umwandlung von std_logic zu std_ulogic und umgekehrt ist jederzeit möglich. In diesem Skriptum wird std_ulogic verwendet Alle gezeigten Beispiele mit std_ulogic lassen sich auch mittels std_logic realisieren. Definition eines Signals mit std_ulogic signal led_reg : std_ulogic := '0' ; -- Hier wird das Signal led_reg als std_ulogic definiert und mit '0' initialisiert Busse mittels std_ulogic_vector In vielen Anwendungen werden mehrere Signale zu einem Bus zusammengefasst. Dazu wird der Signaltyp std_ulogic_vector verwendet. Um einen Bus data_reg mit 8 Signalen zu definieren und diesen mit den Bits \"00000001\" zu initialisieren wird folgende Definition genutzt: signal data_reg : std_ulogic_vector ( 7 downto 0 ) := \"00000001\" ; downto und to Im obigen Beispiel wurde downto genutzt um innerhalb des Vektors die einzelnen Indizies zu definieren. Wir können auf ein einzelnes Signal im Bus mittels data_reg(0) zugreifen. Dies wurde laut obiger Definition '1' zurückliefern und entspricht somit (wie erwartet) dem niederwertigsten Bit. Würde data_reg wie folgt definiert sein: signal data_reg : std_ulogic_vector ( 0 to 7 ) := \"00000001\" ; würden wir bei data_reg(0) den Wert '0' zurückbekommen, da der Index 0 nun dem äußerst linken Bit entspricht. Verwende downto Da bei den meisten Darstellungen das höchstwertigste Bit links und das niederwertigste Bit rechts steht bietet sich downto an. Prinzipiell spricht nichts gegen eine Verwendung von to solange man weiß, was man tut! Literale Wir haben im obigen Beispiel die Initialisierung mit dem Bitstring \"00000001\" gesehen. Solche Werte werden Literale ( engl. literals ) genannt. In diesem Beispiel wird jedes einzelne Bit aufgeschlüsselt. Das gleiche Ergebnis erzielt man mittels x\"01\" für die Darstellung mittels hexadezimaler Zahl. Eine andere Möglichkeit bietet die Darstellung mittels Mapping: signal data_reg : std_ulogic_vector ( 7 downto 0 ) := ( 0 => '1' , others => '0' ); Diese Definition setzt den Index 0 auf '1' und alle anderen Bits auf '0' . Verknüpfen von Bussen Busse lassen sich beliebig zusammenführen und aufteilen. Im folgenden Beispiel wird der 8 Bit Bus data_in_reg in zwei Teilbusse low_nibble und high_nibble mit jeweils 4 Bit aufgeteilt. Der 8 Bit Bus data_out_reg besteht aus den einzelnen 4 Bit Bussen, die in umgekehrter Reihenfolge wieder zusammengesetzt werden. signal data_in_reg : std_ulogic_vector ( 7 downto 0 ); signal low_nibble : std_ulogic_vector ( 3 downto 0 ); signal high_nibble : std_ulogic_vector ( 3 downto 0 ); signal data_out_reg : std_ulogic_vector ( 7 dowto 0 ); low_nibble <= data_in_reg ( 3 downto 0 ); high_nibble <= data_in_reg ( 7 downto 4 ); data_out_reg <= low_nibble & high_nibble ; Das gleiche würde sich auch wie folgt realisieren lassen: data_out_reg <= data_in_reg ( 3 downto 0 ) & data_in_reg ( 7 downto 4 ); Numerische Signaltypen unsigned und signed Der Signaltyp std_ulogic_vector ist eine einfache Ansammlung einzelner std_ulogic Signale. Damit zu rechnen ist nicht unmittelbar möglich. Für diese Anwendungsfälle gibt es die Bibliothek numeric_std mit den Signaltypen unsigned und signed . library ieee ; use ieee.numeric_std. all ; Die Definition selbst entspricht der Definition von Bussen mittels std_ulogic_vector : signal counter_reg : unsigned ( 7 downto 0 ); Damit werden nun Addition und Subtraktion mit anderen unsigned bzw. signed Typen sowie Integern möglich: counter_reg <= counter_reg + 1 ; Ganzzahlen mittels integer In vielen Anwendungen werden arithmetische Operationen mit Signalen durchgeführt. Oft ist es aber nicht notwendig, auf die einzelnen Bits zuzugreifen. Für solche Zwecke gibt folgende Ganzzahl Signaltypen: integer : Ganzzahl, je nach Synthesetool meist als 32 Bit vorzeichbehaftete Zahl representiert natural : Subtype von integer die positive Zahlen inklusive 0 enthält. positive : Subtype von integer die ausschließlich positive Zahlen enthält (ohne 0 ). Eingrenzung mittels range Für Signale kann der Wertebereich der Ganzzahltypen weiter eingeschränkt werden. Für einen Zähler im Dezimalsystem bietet sich eventuell folgende Definition an: signal dec_counter_reg : integer range 0 to 9 ; Überlauf bei integer Wenn wie im obigen Beispiel der Bereich auf 0 bis 9 eingeschränkt ist, bedeutet dies nicht, dass bei einem Überlauf (9+1) das Ergebnis auf 0 überläuft. Es ist ein Hinweis für Simulation und Synthese, die im Falle eine Warnung ausgeben können, der Überlauf selbst muss aber durch eine eigene Beschreibung abgefangen werden. Konvertierung und Casting Wird ein Signaltyp mit dem Wert eines anderen Signaltyps angesteuert benötigt man eine Konvertierung bzw. einen Cast . Die Typen std_ulogic_vector , unsigned und signed sind Vektoren. Hier reicht es aus den Typ zu casten . Bei einer Umwandlung von einem integer zu einem Vektor benötigt man die Information, wieviele Bits notwendig sind. Für die folgenden Beispiele gehen wir von folgender Definition aus: signal sul_vector : std_ulogic_vector ( 7 downto 0 ); signal u_vector : unsigned ( 7 downto 0 ); signal s_vector : signed ( 7 downto 0 ); signal int : integer range 0 to 255 ; std_ulogic_vector u_vector <= unsigned ( sul_vector ); s_vector <= signed ( sul_vector ); int <= to_integer ( unsigned ( sul_vector )); Die Umwandlung eines std_ulogic_vector in unsigned und signed geht einfach, da es sich nur die Interpretation der Bits ändert. Bei der Umwandlung in einen integer gibt es das Problem, dass std_ulogic_vector nur eine Ansammlung von Bits ist, ohne eine Wertigkeit vorzugeben. Die Umwandlung zu integer geschieht über einen Cast zu unsigned bzw. signed und dann die Konvertierung in einen integer . unsigned und signed -- Umwandlung von unsigned sul_vector <= std_ulogic_vector ( u_vector ); int <= to_integer ( u_vector ); -- Umwandlung von signed sul_vector <= std_ulogic_vector ( s_vector ); int <= to_integer ( s_vector ); Die Umwandlung funktioniert hier änhlich zu std_ulogic_vector . integer u_vector <= to_unsigned ( int , 8 ); s_vector <= to_signed ( int , 8 ); sul_vector <= std_ulogic_vector ( to_unsigned ( int , 8 )); Bei der Konvertierung eines integer s in einen Vektor sind entsprechende Konvertierungsfunktionen zu nutzen. Der Weg von integer zu std_ulogic_vector kann dabei je nach Anwendung über to_unsigned und to_signed führen.","tags":"programmierbare_logik","title":"VHDL Signaltypen"},{"url":"https://www.semiversus.com/dic/halbleiterelemente/statische_datenspeicher.html","text":"Allgemeines Bei statischen Speichern wird keine zyklische Erneuerung der Information benötigt, da der Zustand in der Speicherzelle stabil gespeichert wird. Festwertspeicher Masken ROM Bei einem Masken ROM (Read-Only-Memory) handelt es sich um einen Festwertspeicher, dessen Speicherinhalt durch den Fertigungsprozess über Masken fest angelegt wird. Diese Art von Speicher ist nur für sehr große Massenfertigung sinnvoll, da die Erstellung von individuellen Masken sehr teuer ist. Die Anwendung muss auch so ausgelegt sein, dass es keine Notwendigkeit von nachträglichen Updates gibt. Für den Großteil der heutigen Endkundenprodukte ist so etwas unvorstellbar geworden. Die Ansteuerung erfolgt durch die Wort- und Datenleitung. Eine Speicherzelle wird selektiert, indem die Wortleitung auf logisch 1 gesetzt wird. Wenn die Verbindung durch die Maske erzeugt wurde, wird über diese Verbindung die Datenleitung auch auf logisch 1 gezogen. Die Datenleitung bleibt auf logisch 0, wenn die Verbindung nicht vorhanden ist. Um ungewollte Rückwirkungen zu vermeiden werden Dioden benötigt, da meist mehrere Speicherzellen gleichzeitig angesprochen werden. Die Wortleitung selbst wird durch einen Adressdekoder gesteuert. OTP ROM Beim OTP (One-Time-Programmable) ROM handelt es sich um eine Speicherstruktur die einmal programmierbar ist. Der Aufbau ist vergleichbar mit dem Masken ROM, nur hier ist jede Verbindung anfangs vorhanden. Jede Verbindung ist so ausgelegt, dass bei einem hohen Strom die Verbindung verdampft, ähnlich einer Sicherung. So ist am Anfang jede Speicherzelle auf logisch 1 und kann durch den Schreibvorgang auf eine logisch 0 geändert werden. Dieser Vorgang ist jederzeit möglich, die Umkehrung (logisch 0 auf 1) jedoch nicht. Nicht-Flüchtiger Speicher EPROM Ein EPROM (Erasable Programmable ROM) ist ein Speicher, der gleich einem OTP ROM programmierbar ist. Der Speicherinhalt kann mittels UV-Licht gelöscht werden. Programmiervorgang Beim Programmieren wird eine erhöhte Spannung (je nach Bauart zwischen 12 Volt und 25 Volt) angelegt. Dadurch kommt es zu einem Lawinen-Durchbruch (oder Avalanche-Durchbruch). Dadurch können Elektronen die dünne Isolierschicht überwinden und sich im Floating Gate sammeln. Das Programmieren kann jederzeit wiederholt bzw. fortgesetzt werden, allerdings kann man nur Ladungen auf dem Floating Gate einbringen und diese nicht wieder abtransportieren. Es wird meist zwischen zwei verschiedenen Programmieralgorithmen unterschieden. Beim langsamen Programmieren wird die maximale Programmierzeit, die der Herstellers des Bausteins angibt, verwendet. Dies kann je nach Hersteller zwischen einigen 100µs bis einigen Millisekunden dauern. Beim schnellen Programmieren werden wesentlich kürzere Programmierzeiten verwendet (etwa 100µs). Nach einem Programmiervorgang wird das Ergebnis zurückgelesen und sollten nicht genug Ladungen auf das Floating Gate gelangt sein, wird dieser Vorgang wiederholt. Nachdem das erste Mal das richtige Ergebnis zurückgelesen wird, wird ein etwas längerer Programmiervorgang gestartet (etwa 300µs) um noch zusätzliche Ladungsträger auf das Floating Gate zu bringen. Damit ist der Programmiervorgang für diese Zelle abgeschlossen. Auslesen Der Transistor schaltet durch, wenn nun am Gate eine Spannung von etwa 5 Volt angelegt wird und das Floating Gate keine Ladungsträger enthält (wurde also nicht programmiert). Beim Durchschalten zieht der Transistor den Pegel der Datenleitung auf Massepotential. Wenn am Floating Gate Ladungsträger vorhanden sind, verschiebt sich die Schwellenspannung und die 5 Volt am Gate reichen nicht mehr aus, den Transistor durchzuschalten. Der Pegel der Datenleitung wird also nicht auf Masse gezogen und bleibt auf einem hohen Pegel. Löschen Um nun die Information zu Löschen bzw. den Speicherbaustein auf seinen Auslieferungszustand zurückzusetzen wird nun mittels UV Licht im Bereich von 250nm der Widerstand der Isolierschicht heruntergesetzt und damit können die Elektronen Richtung Substrat abfließen. Damit dies überhaupt möglich wird, ist ein Quarzglas im Chip notwendig. Nach dem Löschen wird dies meist mit einem nicht transparenten Aufkleber abgedeckt. EPROM mit Quarzfenster (Bild: yellowcloud CC BY 2.0) Der Löschvorgang dauert je nach Intensität zwischen 20 Minuten und mehreren Stunden. Da die Isolationsschicht sich bei jedem Löschvorgang verschlechtert geben die Hersteller meist eine Beschreibbarkeit (oder genauer Löschbarkeit) von einigen Hundert Zyklen an. Da die Isolationsschicht nicht ideal isoliert fließen über längere Zeit auch die Elektronen aus dem Floating Gate ab. Die Hersteller geben meist eine Zeit von ca. 10 Jahren an, in der ein EPROM seine Information behalten kann. Umwelteinflüsse (erhöhte Umgebungstemperatur, Röntgenstrahlung, ...) können diesen Vorgang beschleunigen. EEPROM Eine EEPROM (Electrically-Erasable PROM) Speicherzelle ist im Prinzip ähnlich wie ein EPROM aufgebaut. Die Isolationsschicht zwischen dem Floating Gate und Drain ist hier aber so dünn, dass es auch bei geringen Spannungen von ca. 12 Volt zu einem sogenannten Tunneleffekt kommt. Dieser quantenmechanische Effekt ermöglicht das Durchwandern von Elektronen durch die dünne Isolationsschicht in beide Richtungen. Es können also Elektronen auf das Floating Gate hinzugefügt oder abgetragen werden. Da der Transistor mit dem Floating Gate je nach gespeichertem Datum einen selbstsperrenden Zustand aufweisen kann, wird ein zweiter Transistor benötigt, um die Speicherzelle zu adressieren. Ein Programmiervorgang benötigt je nach Typ zwischen 1ms und 10ms. Die Wiederbeschreibbarkeit liegt meist bei maximal 100.000 Schreibvorgängen. Flash Eine Flash Speicherzelle entspricht einer EEPROM Speicherzelle, nur wird hier durch eine Änderung der Schaltung nicht mehr jede Speicherzelle einzeln löschbar. Die Speicherzellen werden zu sogenannten ''Pages'' zusammengefasst. Je nach Typ ist eine solche Page meist einige kByte groß. Durch diese Änderung wird der zweite Transistor zur Adressierung nicht mehr benötigt und es kann somit eine höhere Speicherdichte erreicht werden. Die Spannung zum Schreiben und Löschen (ca. 12V) wird heute meist durch integrierte Ladungspumpen realisiert. Die Beschreibbarkeit liegt meist bei einigen 100.000 Schreibvorgängen. SLC vs. MLC In einer Single-Level-Cell wird nur zwischen vorhandener und nicht vorhandener Ladung (also logisch 0 oder 1) unterschieden. Wenn man nun mehrere Zwischenstufen nutzt, kommt man zur sogenannten Multi-Level-Cell. Wenn man zwischen 4 Ladungszuständen unterscheiden kann, können 2 Bit pro Speicherzelle gespeichert werden. MLC Flash Speicher erhöhen die Speicherdichte (mehr Bit auf gleiche Fläche), die Transferrate (mehr Bit pro Zugriff). allerdings auch den Leistungsbedarf. Flüchtiger Speicher SRAM SRAM Zellen werden heut meist mittels 6 Transistoren in einer CMOS Technologie gefertigt. Die Information wird in einer bistabilen Kippstufe (M1-M4) gespeichert. Die beiden Transistoren M5 und M6 dienen zum Adressieren der Speicherzelle. Um die gespeicherte Information auszulesen, werden die beiden Leitungen %%BL%% und %%\\overline{BL}%% hochohmig gesetzt und die Transistoren M5 und M6 leiten. Dadurch ist der innere Zustand der Kippstufe auf den Leitungen %%BL%% und %%\\overline{BL}%% lesbar. Beim Schreiben werden die Leitungen %%BL%% und %%\\overline{BL}%% entsprechend der zu speichernden Information gesetzt und die Speicherzelle mittels M5 und M6 adressiert. Der innere Zustand wird durch die Bitleitungen überschrieben. Eine Sonderform stellt eine SRAM Zelle mit 4 Transistoren dar. Dabei werden die beiden p-Kanal FETs durch Widerstände ersetzt. Nachteilig ist die schlechte Fertigbarkeit in den heute üblichen Prozessen und der erhöhte Stromverbrauch. NVRAM Die hier beschriebene SRAM Zelle mit 6 Transistoren (oft kurz als 6T beschrieben) hat einen sehr kleinen Stromverbrauch (unter 1µA Standby für einen 32KibiByte Speicher). Um aus einem SRAM einen nicht-flüchtigen Speicher zu machen gibt es daher die Möglichkeit, den Speicher mit einer Bufferbatterie zu kombinieren. Dieser Speicher wird dann NVRAM (non-volatile random-acress-memory).","tags":"halbleiterelemente","title":"Statische Datenspeicher"},{"url":"https://www.semiversus.com/dic/robotik/suche.html","text":"","tags":"robotik","title":"Suchalgorithmen"},{"url":"https://www.semiversus.com/dic/grundlagen_der_digitaltechnik/synchrones_design.html","text":"Allgemeines Bei der Entwicklung digitaler Schaltwerke versucht man meist nach einer bestimmten Methodik vorzugehen, um bekannte Fehler ausschließen zu können. Im Folgenden werden die verschiedenen Schwierigkeiten beschrieben, die ohne Beachtung auftreten können. Anschließend wird der synchrone Schaltungsentwurf vorgestellt, der eine Methodik beschreibt, komplexe Schaltwerke deterministisch und sicher zu entwerfen und zu betreiben. Begriffe Setup- und Hold-Zeiten Das Datensignal eines Datensignals muss eine bestimmte Zeit vor der Flanke am Takteingang stabil anliegen. Diese Zeit wird Setup -Zeit genannt. Weiters muss das Datensignal nach der Flanke am Takteingang eine bestimmte Zeit stabil anliegen. Dies ist die Hold -Zeit. Wenn Setup- und Hold-Zeiten eingehalten werden, wird nach der vom Bauteil abhängigen Verzögerungszeit der Ausgang entsprechend geändert. Im Datenblatt ist diese Zeit meist als Propagationdelay bzw. %%t_{p}%% gekennzeichnet. Ändert sich das Datensignal innerhalb der Setup- und Hold-Zeit, spricht man von einer Setup- bzw. Hold-Zeit Verletzung. Bei einer Verletzung besteht die Wahrscheinlichkeit, dass es zu einem metastabilen Zustand des Flip-Flops kommt. Dabei bleibt der Ausgang in einem Zustand zwischen logisch 0 und 1 (dem metastabilen Zustand) und wechselt nach einer undefinierbaren Zeit entweder nach logisch 0 oder 1. Dabei ist es auch möglich, dass die normale Verzögerungszeit weit überschritten wird. Metastabilität Ein Flip-Flop kennt zwei stabilie Zustände. Diese werden als logisch 0 bzw. logisch 1 bezeichnet, entsprechen also dem Zustand, der am Ausgang Q dargestellt wird. Wird nun durch eine Taktflanke der Zustand des Eingangs übernommen, so befindet sich das Flip-Flop wieder in einem stabilen Zustand. Das ganze System kann auch folgendermaßen dargestellt werden: Die Kugel stellt den Zustand dar. Die logisch 0 und 1 ist der stabile Zustand links und rechts vom Hügel. Das ganze System ist labil, wenn sich die Kugel auf der Spitze des Hügels befindet. Nun ist es abhängig von zufälligen Ereignissen, wohin der Zustand des Flip-Flops kippt. Synchrones Design Beim synchronen Design versucht man die Schwierigkeiten, die sich durch die Metastabilität ergeben zu beheben, indem alle Flip-Flops auf einen gemeinsamen globalen Takt reagieren. Dazu wird außerdem sichergestellt, dass an den Eingängen der Speicherelementen stabile Signale anliegen, bevor die nächste Taktflanke kommt. Als Takt wird beim synchronen Design ein periodischer Rechtecksignal mit einer festen Frequenz verwendet. Um die maximale Frequenz zu bestimmen wird der kritische Pfad zwischen den Ausgängen der Speicherelementen und dem Eingang ebendieser gesucht. Die minimale Periodendauer (Kehrwert der maximalen Taktfrequenz) ist nun die Summe aus folgenden Zeit: Verzögerungszeit durch das Flip-Flop (von der Taktflanke bis zum Ausgang des Flip-Flops) Laufzeit durch den kritischen Pfad der Kombinatorik notwendige Setup Zeit der Flip-Flops Synchronisierung von asynchronen Signalen Da Eingänge der Schaltung in vielen Fällen nicht synchron zum globalen Takt sind, müssen diese synchronisiert werden. Wird keine Synchronisierung verwendet, kann es zur Verletzung von Setup- und Hold-Zeiten kommen und damit zu Metastabilität. Wenn bedingt durch die Metastabilität es zu einem verspäteten Stabilieseren am Ausgang des Flip-Flops kommt, so kann sich dies auf die weiteren Schaltungsteile auswirken und dort wieder zur Metastabilität und damit zu Fehlern kommen. Zur Synchronisierung werden ein- bzw. mehrere Flip-Flops hintereinander geschaltet. Mit jeder Stufe kann die Wahrscheinlichkeit der Metastabilität vermindert werden. In der Praxis reichen meist zwei hintereinandergeschaltete Flip-Flops aus. Schaltungsentwurf Um einen durchgängig synchronen Entwurf zu realisieren sind einige Dinge zu beachten, die im folgenden erläutert werden. Skew des Taktsignals Unter Clock-Skew versteht man den maximalen Zeitunterschied in der Ankunftszeit des Taktsignals aller Speicherelemente. Im Idealfall kommt bei jedem Speicherelement die Taktflanke zum exakt gleichen Moment. Ein Clock-Skew von 10ns bedeutet also, dass es zwei Speicherelemente mit 10ns Unterschied bei der Ankunft der Taktflanke gibt. Um den Clock-Skew zu minimieren sind folgende Punkte zu beachten: keine Kombinatorik in der Taktleitung Taktleitungen als Baumstruktur verteilen Buffer zur Verstärkung des Taktsignals symmetrisch in der Baumstruktur verteilen Asynchroner Set und Reset Alle Speicherelemente sollten nur über den synchronen Takteingang in einen neuen Zustand überführt werden. Bei der Verwendung von asynchronen Set und Reset Eingängen kann es auch wieder zur Metastabilität führen. Fan-Out beachten Fan-Out beschreibt das Verhältnis von Eingängen, die an einen Ausgang geschaltet werden. Dabei werden immer Gatter einer Logikfamilie verglichen. Ein Fan-Out von 10 bedeutet, dass 10 Eingänge von einem Ausgang angesteuert werden kann. Wird der Fan-Out überschritten, können die Verzögerungszeiten nicht mehr eingehalten werden, da es unter erhöhter Last länger dauert, bis sich der Logikpegel geändert hat.","tags":"grundlagen_der_digitaltechnik","title":"Synchrones Design"},{"url":"https://www.semiversus.com/dic/komplexe_digitale_systeme/synchronisation.html","text":"Allgemeines Unter Prozesssynchronisation (oder kurz Synchronisation) versteht man die Koordinierung des zeitlichen Ablaufs mehrerer nebenläufiger Prozesse. Der Zweck der Koordinierung ist zumeist einer der folgenden: Gemeinsamer Zugriff auf Daten. Dabei muss verhindert werden, dass durch gleichzeitigen Zugriff Inkonsistenzen in den Daten entstehen. Dies wird durch Mutex-Verfahren zum gegenseitigen Ausschluss realisiert. Gemeinsame Nutzung beschränkter Betriebsmittel wie zum Beispiel von Peripheriegeräten. Hierbei können ebenfalls Mutex-Verfahren eingesetzt werden, häufig werden aber komplexere Methoden des Schedulings benötigt. Übergabe von Daten bzw. Nachrichten von einem Prozess an einen Anderen, also Interprozesskommunikation. Steuerung von Unterprozessen durch Signale, insbesondere das Abbrechen von Prozessen oder das Warten darauf, dass sie terminieren. Semaphor Ein Semaphor ist eine Datenstruktur, die aus einer Ganzzahl und den Nutzungsoperationen „Reservieren/Probieren\" und „Freigeben\" besteht. Sie eignet sich insbesondere zur Verwaltung beschränkter (zählbarer) Ressourcen, auf die mehrere Prozesse zugreifen sollen, wie etwa Erzeuger und Verbraucher. Meist wird die Ganzzahl (Zähler) beim Start des Semaphors mit dem Zahlenwert der maximal verfügbaren Ressourcen initialisiert bzw. der maximalen Zahl der Prozesse, die gleichzeitig die Ressource nutzen können. Ein Prozess, der auf die Ressource zugreifen will, muss vorher die Operation „Reservieren/Probieren\" aufrufen, und danach, wenn er die Ressource nicht mehr benötigt, die Operation „Freigeben\". Bei jeder Reservierung wird der Zähler um 1 heruntergezählt, bei Freigabe wird er wieder um 1 erhöht. Der Zähler darf nicht unter 0 fallen: Wenn eine Reservierung bei Zählerstand 0 erfolgt, wartet der reservierende Prozess, bis ein anderer Prozess Ressourcen freigegeben hat. Es gibt auch Implementierungen, die ins Negative zählen, „wie viele Interessenten aktuell warten\". Kritischer Abschnitt Mit Hilfe von Semaphoren lassen sich auch kritische Abschnitte realisieren. Darunter wird ein Abschnitt eines Programms bezeichnet, in dem Ressourcen (z.B. Datenstrukturen, Verbindungen, Geräte usw.) verändert werden und der nicht parallel oder zeitlich verzahnt zu Programmabschnitten anderer Prozesse/Threads ausgeführt werden darf, in denen die gleichen Ressourcen ebenfalls verändert werden. Andernfalls kommt es zu inkonsistenten Zuständen der Betriebsmittel. Das folgende Beispiel zeigt die Inkrementierung einer Variable s durch zwei Prozesse. Dazu wird eine Kopie von s in ein Register geladen, um eins erhöht und wieder zurückgeschrieben. Im linken Teil wird der erste Prozess unterbrochen und der zweite Prozess kommt zur Ausführung. Die Variable ist nun nicht auf 2 sondern auf 1. Im rechten Teil sind die kritischen Abschnitte atomar ausgeführt (sprich nicht unterbrechbar). Kritischer Abschnitt (Bild: miracula_de CC0 1.0) Deadlock Deadlock oder Verklemmung bezeichnet einen Zustand, bei dem ein oder mehrere Prozesse auf Betriebsmittel warten, die dem Prozess selbst oder einem anderen beteiligten Prozess zugeteilt sind. Der Zustand eines Deadlocks kann folgendermaßen definiert werden: Eine Menge von Prozessen befindet sich in einem Deadlock, wenn jeder dieser Prozesse auf ein Ereignis wartet, das nur ein anderer Prozess aus dieser Menge verursachen kann. Es müssen vier Kriterien erfüllt werden, damit es in einem System zu einem Deadlock kommen kann: Die Betriebsmittel werden ausschließlich durch die Prozesse freigegeben (Da Ressourcenzugriff eines Prozesses nicht unterbrochen werden kann. No Preemption). Die Prozesse fordern Betriebsmittel an, behalten aber zugleich den Zugriff auf andere (Hold and Wait). Der Zugriff auf die Betriebsmittel ist exklusiv (Mutual Exclusion). Mindestens zwei Prozesse besitzen bezüglich der Betriebsmittel eine zirkuläre Abhängigkeit (Circular Wait). Bekannt und beschrieben wird dieses Problem auch als Philosophenproblem .","tags":"komplexe_digitale_systeme","title":"Synchronisation"},{"url":"https://www.semiversus.com/dic/programmierbare_logik/synchronisierung.html","text":"","tags":"programmierbare_logik","title":"Synchronisierung asynchroner Signale"},{"url":"https://www.semiversus.com/dic/hardwarenahe_programmierung/tastenentprellung.html","text":"Allgemeines Die bekannteste Form von Schaltern und Tastern arbeitet elektromechanisch, indem zwei Kontakte je nach Zustand entweder verbunden oder getrennt sind. Man spricht auch von den Zuständen geschlossen und offen . Im mechanischen Aufbau des Tasters wird oft eine Feder benutzt, um die Kontakte zu trennen. Im ungedrückten Zustand ist dieser Taster offen . Diese Konfiguration bezeichnet man als Normally open (kurz NO ) Taster. Im gegensatz dazu sind bei Tastern in der Konfiguration Normally closed ( NO )die Kontakte per Feder geschlossen und erst durch mechanische Betätigung werden die Kontakte getrennt. Bedingt durch den Aufbau und der Feder wechselt bei einer Betätigung der Zustand nicht unmittelbar von offen zu geschlossen (und umgekehrt) sonder es kommt zu einer mechanischen Schwingung, die diese Kontakte mehrfach aufeinander prellen lässt. Daher die Bezeichnung Tastenprellen oder genauer Kontaktprellen . Im folgenden Oszibild sieht man ein solches Prellen, welches in diesem Fall beim Loslassen der Taste aufgenommen wurde (0V entspricht geschlossen , 5V entspricht offen ): Im Bild sieht man das Prellen über eine Zeitdauer von ca. 1.5ms . Dies ist ein typischer Wert, kann aber je nach Bauart auch stark variieren. Das Problem beim Tastenprellen ist die Auswertung der Taste selbst. Zur Auswertung ob eine Taste gedrückt wurde wird nach einer Flanke gesucht, sprich ein Zustandswechsel von offen zu geschlossen (oder umgekehrt). Je nach Implementierung dieser Detektion kann durch das Prellen ein Tasterdruck mehrfach detektiert werden. Dies kann zu Problemen in der Anwendung kommen. Entprellen Es gibt verschiedene Möglichkeiten, einen Taster zu entprellen. Unterschieden wird zwischen Hardware- und Softwarelösungen. Mögliche Hardwarelösungen stehen zur Verfügung: Nicht prellende Taster verwenden (meist relativ aufwendig und dadurch teuer) Tiefpassfilterung und Schmitttrigger * Spezielle Entprellschaltungen oder ICs Man kann auf Hardwarelösungen aber auch ganz verzichten, wenn die Entprellung in der Software durchgeführt wird. Es gibt viele verschiedene Lösungen dies in Software zu realisieren. Hier werden drei Möglichkeiten gezeigt. Entprellen mittels Warten Die einfachste Art das Prellen abzufangen ist nach der ersten Detektion einer Flanke einfach eine bestimmte Zeit zu warten. Diese Zeit richtet sich nach der Dauer des Prellens der Taste. Im folgenden Beispiel wird die Funktion process_key in der Main Loop aufgerufen. Die Durchlaufszeit einer Iteration der Main Loop sollte dabei kürzer als einige Millisekunden sein, damit auch kurze Tastendrücke detektiert werden können. uint8_t process_key ( uint8_t key_state ) { static uint8_t old_key_state = 0 ; // old_key_state speichert den Zustand der vorhergehenden Iteration uint8_t result = 0 ; // Initialisere den Rückgabewert mit 0 if ( key_state != old_key_state ) { // Überprüfe Zustandsänderung if ( key_state == 1 ) { // Wenn der neue Zustand \"geschlossen\" ist result = 1 ; // gib 1 als Wert zurück } _delay_ms ( 5 ); // Werte 5 Millisekunden (blockierend!) } old_key_state = key_state ; // speichere den aktuellen Zustand für die nächste Iteration return result ; } Diese Implementierung hat ein großes Problem: Die Wartezeit von 5 Millisekunden, die den Prozessor für diese Zeit blockiert. Das Prinzip ließe sich übertragen auf eine Implementierung mit einem Timerinterrupt, der jede Millisekunde den Taster auf eine Zustandsänderung überprüft und die Wartezeit mit mehreren Interruptaufrufen umsetzt. Vorfilterung Wenn das Prellen selbst in der Software weggefiltert wird fällt die Detektierung der Flanke leichter und es entfällt damit auch das Warten wie im vorherigen Beispiel. Eine Vorfilterung lässt sich implementieren, indem man einen softwareinternen Zustand des Tasters realisiert, der erst nach einer bestimmten Anzahl an Zuständen der gleichen Art umgestellt wird. #define MIN_ITERATION_COUNT 20 uint8_t process_key ( uint8_t key_state ) { static uint8_t internal_key_state = 0 ; // softwareinterner Zustand static uint8_t count = 0 ; // Anzahl an Zuständen gleicher Art if ( key_state != internal_key_state ) { // Wenn sich der interne Zustand vom externen unterscheidet count ++ ; // Erhöhe den Zähler um eins if ( count == MIN_ITERATION_COUNT ) { // bis die Mindestanzahl erreicht wurde internal_key_state = key_state ; // Stelle den internen Zustand um return key_state ; // Gib 1 zurück, wenn der neue Zustand 1 ist (ansonsten 0) } } else { count = 0 ; // Wenn interner gleich externer Zustand ist setze Zähler auf 0 } return 0 ; // Gib 0 für alle anderen Fälle zurück } Nachbildung eines analogen Tiefpasses Das was ein analoger Tiefpass bei der hardwaremäßigen Entprellung macht kann auch durch Software nachgebildet werden. Dazu wird der Zustand des Tasters gemittelt. Wird ein bestimmter Schwellwert überschritten so wird der entsprechende Zustand softwareintern gesetzt. Bei der Unterschreitung eines niedrigeren Schwellwertes wird der Zustand wieder zurückgesetzt.","tags":"hardwarenahe_programmierung","title":"Tastenentprellung"},{"url":"https://www.semiversus.com/dic/programmierbare_logik/test_vhdl/test1.html","text":"Allgemeines Projektordner herunterladen und entpacken Insgesamt gibt es 29 Punkte Die einzelnen Punkte bauen meist nicht aufeinander auf. Statt langer Fehlersuche lieber auf das nächste Beispiel wechseln. Lichtsteuerung Vorbereitung Projekt led_control/led_control.xise öffnen Aufgabenstellung Es ist eine einfache Lichtsteuerung zu entwerfen. Diese Lichtsteuerung steuert eine LED an und wird mittels zwei Tasten bedient: button_toggle - Schaltet das Licht ein bzw. aus button_off - Schaltet das Licht in 5 Sekunden aus Entwurf der Zustandsmaschine 5 Punkte Zur Realisierung wird eine Zustandsmaschine genutzt. Bearbeite die Datei led_control_fsm.vhd Definiere die drei Zuständen OFF , LIGHT und DOZE Der Startzustand ist OFF Der Eingang toggle_i wechselt von OFF nach LIGHT bzw. von LIGHT oder DOZE nach OFF Der Eingang off_i wechselt von LIGHT nach DOZE , bei den anderen Zuständen hat er keine Auswirkung Der Eingang timeout_i bewirkt ein Wechsel von DOZE nach OFF , bei den anderen Zuständen hat er keine Auswirkung Der Ausgang led_o ist auf '1' , wenn die Zustandmaschine im Zustand LIGHT oder DOZE ist Der Ausgang timer_enable_o ist im Zustand DOZE auf '1' , ansonsten '0' Der Ausgang timer_clear_o ist im Zustand LIGHT auf '1' , ansonsten '0' Testbench Teste die Implementierung mittels der Testbench led_control_fsm_tb.vhd . Mittels F6 lässt sich der gesamte Bereich zoomen. Implementierung des Top Levels 5 Punkte Zur Verfügung stehen die Komponenten counter , button_dectect und led_control_fsm . Diese Komponenten werden genutzt, um im Top Level led_control.vhd die gewünschte Funktionalität zu realisieren. Die Instanz der Komponente button_detect mit dem Namen toggle_detect_component ist bereits erstellt button_i ist mit dem Eingang button_toggle_i verbunden detect_o ist mit dem (bereits definiertem) Signal toggle_detect verbunden Erstelle eine Instanz der Komponente button_detect mit dem Namen off_detect_component analog zu toggle_detect_component button_i ist mit dem Eingang button_off_i verbunden detect_o ist mit dem (bereits definiertem) Signal off_detect verbunden Erstelle eine Instanz der Komponente led_control_fsm mit dem Namen led_control_fsm_component toggle_i ist mit dem Signal toggle_detect verbunden off_i ist mit dem Signal off_detect verbunden timeout_i ist mit dem (bereits definiertem) Signal timeout verbunden led_o ist mit dem Ausgang led_o verbunden timer_enable_o ist mit dem (bereits definiertem) Signal timer_enable verbunden timer_clear_o ist mit dem (bereits definiertem) Signal timer_clear verbunden Erstelle eine Instanz der Komponente counter mit dem Namen timeout_component WIDTH in der generic map wird auf 28 gestellt (28 Bit) MAXIMUM wird auf CLK_TIMEOUT_DIVIDER gestellt (ist im generic Teil des Top Levels bereits definiert) enable_i ist mit dem Signal timer_enable verbunden reset_i ist mit dem Signal timer_clear verbunden value_o ist nicht verbunden ( open ) overflow_o ist mit dem Signal timeout verbunden Jede Komponente hat einen Takteingang clk , welcher mit dem globalen clk verbunden wird Testbench Teste die Implementierung mittels der Testbench led_control_tb.vhd . Erweiterung der Constraints Datei 2 Punkte In der Datei led_control.ucf ist nur das Signal clk definiert. Erweitere die Datei um folgende Zuordnungen button_toggle_i liegt an Pin G12 button_off_i liegt an Pin C11 led_o liegt an Pin M5 Test am Board 1 Punkt Synthetisiere das Projekt und teste das Ergebnis am Board Helligkeitssteuerung mittels PWM Vorbereitung Projekt led_pwm/led_pwm.xise öffnen Aufgabenstellung Die LED wird in diesem Beispiel mittels PWM angesteuert. Zwei Tasten steuern dabei die Helligkeit: button_brighter lässt die LED heller leuchten button_darker lässt die LED dunkler leuchten Insgesamt gibt es 8 Helligkeitsstufen (3 Bit). PWM Erzeugung 5 Punkte Ein PWM besteht aus einem Zähler, der ständig nach oben zählt. Bei einem Überlauf (im Bild mit N2 beschrieben) fängt der Zähler einfach bei 0 wieder an. Der Zählerstand wird verglichen mit einem vorgegebenen Pegel( N1 ) - sind diese gleich wird der Ausgang auf '0' gesetzt. Bei einem Zählerstand von 0 wird der Ausgang auf '1' gesetzt (es sei den der vorgegebene Pegel ist 0). PWM Signalerzeugung (Bild: Saure CC BY-SA 3.0) Bearbeite die Datei pwm_generator.vhd . Der interne Zähler counter_reg zählt bei jeder steigenden Taktflanke nach oben Der Überlauf wird bewusst genutzt (es findet keine besondere Überprüfung statt) Der interne Zähler wird mit level_i verglichen - sind beide gleich wird pwm_reg auf '0' gesetzt Der interne Zähler wird weiters mit 0 verglichen - ist dies der Fall wird pwm_reg auf '1' gesetzt Für die Umwandlung des std_ulogic_vector level_i in ein unsigned verwende unsigned(level_i) Für den Vergleich des internen Zählers mit 0 wandle die 0 mittels to_unsigned(0, WIDTH) in ein unsigned um Der Ausgang pwm_o wird vom Registers pwm_reg angesteuert Testbench Teste die Implementierung mittels der Testbench pwm_generator_tb.vhd . Helligkeitseinstellung 5 Punkte Um einen Pegel für die PWM vorzugeben benötigen wir eine Komponente den einen Pegel abhängig von Tastendrücken ändern kann. Diese Komponente hat folgende Eingänge: up_i - Wenn dieser Eingang gleich '1' ist wird der Pegel um eins erhöht. Ist der Pegel auf Maximum wird nichts geändert. down_i - Bei aktivem down_i wird der Pegel um eins erniedrigt. Ist der Pegel auf 0 wird nichts geändert. Die Ausgabe der Komponente ist der Ausgang level_o . Bearbeite die Datei level_adjust.vhd . Der Register level_reg zählt hinauf, wenn up_i gleich '1' ist bzw. hinunter wenn down_i gleich '1' ist Wenn level_reg am Maximum ist und up_i aktiv ist sollte der Wert sich nicht verändern Wenn level_reg am Minimum (0) ist und down_i aktiv ist sollte der Wert sich nicht verändern Testbench Teste die Implementierung mittels der Testbench level_adjust_tb.vhd . Implementierung des Top Levels 5 Punkte Zur Verfügung stehen die Komponenten button_dectect , pwm_generator und level_adjust . Diese Komponenten werden genutzt, um im Top Level led_pwm.vhd die gewünschte Funktionalität zu realisieren. Das Generic PWM_WIDTH ist eine Konstante die genutzt werden kann, um das Generic WIDTH von pwm_generator und level_adjust zu setzen. Das bei diesen 3 die Default Einstellung ist, wird es nicht unbedingt benötigt. Einige benötigte Signale sind bereits vordefiniert. Erstelle das Top Level anhand des folgenden Blockschaltbildes: Testbench Teste die Implementierung mittels der Testbench led_pwm_tb.vhd . Test am Board 1 Punkt Synthetisiere das Projekt und teste das Ergebnis am Board","tags":"test_vhdl","title":"VHDL Test (1)"},{"url":"https://www.semiversus.com/dic/programmierbare_logik/test_vhdl/test2.html","text":"Allgemeines Projektordner herunterladen und entpacken Insgesamt gibt es 29 Punkte Die einzelnen Punkte bauen meist nicht aufeinander auf. Statt langer Fehlersuche lieber auf das nächste Beispiel wechseln. Einschaltverzögerung Vorbereitung Projekt led_delay/led_delay.xise öffnen Aufgabenstellung Es ist eine einfache Einschaltverzögerung zu entwerfen. Diese Einschaltverzögerung steuert eine LED an und wird mittels zwei Tasten bedient: button_toggle - Schaltet das Licht ein bzw. aus button_on - Schaltet das Licht in 3 Sekunden ein Entwurf der Zustandsmaschine 5 Punkte Zur Realisierung wird eine Zustandsmaschine genutzt. Bearbeite die Datei led_delay_fsm.vhd Definiere die drei Zuständen OFF , LIGHT und DELAY Der Startzustand ist OFF Der Eingang toggle_i wechselt von LIGHT nach OFF bzw. von OFF oder DELAY nach LIGHT Der Eingang on_i wechselt von OFF nach DELAY , bei den anderen Zuständen hat er keine Auswirkung Der Eingang timeout_i bewirkt ein Wechsel von DELAY nach LIGHT , bei den anderen Zuständen hat er keine Auswirkung Der Ausgang led_o ist auf '1' , wenn die Zustandmaschine im Zustand LIGHT ist Der Ausgang timer_enable_o ist im Zustand DELAY auf '1' , ansonsten '0' Der Ausgang timer_clear_o ist im Zustand OFF auf '1' , ansonsten '0' Testbench Teste die Implementierung mittels der Testbench led_delay_fsm_tb.vhd . Mittels F6 lässt sich der gesamte Bereich zoomen. Implementierung des Top Levels 5 Punkte Zur Verfügung stehen die Komponenten counter , button_dectect und led_delay_fsm . Diese Komponenten werden genutzt, um im Top Level led_delay.vhd die gewünschte Funktionalität zu realisieren. Die Instanz der Komponente button_detect mit dem Namen toggle_detect_component ist bereits erstellt button_i ist mit dem Eingang button_toggle_i verbunden detect_o ist mit dem (bereits definiertem) Signal toggle_detect verbunden Erstelle eine Instanz der Komponente button_detect mit dem Namen on_detect_component analog zu toggle_detect_component button_i ist mit dem Eingang button_on_i verbunden detect_o ist mit dem (bereits definiertem) Signal on_detect verbunden Erstelle eine Instanz der Komponente led_delay_fsm mit dem Namen led_delay_fsm_component toggle_i ist mit dem Signal toggle_detect verbunden on_i ist mit dem Signal on_detect verbunden timeout_i ist mit dem (bereits definiertem) Signal timeout verbunden led_o ist mit dem Ausgang led_o verbunden timer_enable_o ist mit dem (bereits definiertem) Signal timer_enable verbunden timer_clear_o ist mit dem (bereits definiertem) Signal timer_clear verbunden Erstelle eine Instanz der Komponente counter mit dem Namen timeout_component WIDTH in der generic map wird auf 28 gestellt (28 Bit) MAXIMUM wird auf CLK_TIMEOUT_DIVIDER gestellt (ist im generic Teil des Top Levels bereits definiert) enable_i ist mit dem Signal timer_enable verbunden reset_i ist mit dem Signal timer_clear verbunden value_o ist nicht verbunden ( open ) overflow_o ist mit dem Signal timeout verbunden Jede Komponente hat einen Takteingang clk , welcher mit dem globalen clk verbunden wird Testbench Teste die Implementierung mittels der Testbench led_delay_tb.vhd . Erweiterung der Constraints Datei 2 Punkte In der Datei led_delay.ucf ist nur das Signal clk definiert. Erweitere die Datei um folgende Zuordnungen button_toggle_i wird durch den Taster BTN0 angesteuert button_on_i wird durch den Taster BTN1 angesteuert led_o ist die LED LD0 Pinout des BASYS2 Boards(Bild: Digilent Inc. BASYS2 Manual ) Test am Board 1 Punkt Synthetisiere das Projekt und teste das Ergebnis am Board Würfel Vorbereitung Projekt dice/dice.xise öffnen Aufgabenstellung Mittels sieben LEDs wird ein Würfel dargestellt. Eine Taste startet durch das Drücken einen Zufallsgenerator und beim Loslassen wird das Ergebnis angezeigt. Dieser Zufallsgenerator ist ein Zähler, der mit 50Mhz die 6 möglichen Zustände durchwechselt. Decoder testen 5 Punkte Der Decoder wandelt den Eingang value_i (3 Bit) in die entsprechende 7 LEDs Darstellung leds_o (7 Bit) um. Dabei wird folgende kodierung verwendet: LED6 LED5 LED4 LED3 LED2 LED1 LED0 Aus Aus Aus Ein Aus Aus Aus Aus Aus Ein Aus Ein Aus Aus Aus Ein Aus Ein Aus Ein Aus Ein Aus Ein Aus Ein Aus Ein Ein Ein Aus Ein Aus Ein Ein Ein Ein Ein Aus Ein Ein Ein Die erste Zeile entspricht der Darstellung bei value_i gleich \"000\" Ein wird mittels '1' kodiert, Aus mittels '0' Bei nicht definierten Zustände sollen alle LEDs aus sein Die Komponente ist in vier Ausführungen ( Architectures ) bereits in der Datei decoder.vhd beschrieben. Die Architectures lauten behave1 , behave2 , behave3 und behave4 . Erstelle in der Datei decoder_tb.vhd eine Testbench, die herausfindet, welche der vier Ausführungen funktioniert (es ist genau eine). Komponente shuffle 5 Punkte Erstelle die Komponente shuffle durch Bearbeitung der Datei shuffle.vhd nach folgender Skizze: Wenn enable_i auf '1' ist, soll der interne Zähler counter_reg bei einer steigenden Taktflanke hinaufzählen Der interne Zähler soll von 0 bis 5 zählen Das Register result_reg übernimmt bei einer steigenden Taktflanke den Wert von counter_reg , wenn enable_i gleich '0' ist Testbench Teste die Implementierung mittels der Testbench shuffle_tb.vhd . Implementierung des Top Levels 5 Punkte Zur Verfügung stehen die Komponenten shuffle , decoder . Diese Komponenten werden genutzt, um im Top Level dice.vhd die gewünschte Funktionalität zu realisieren. Testbench Teste die Implementierung mittels der Testbench dice_tb.vhd . Test am Board 1 Punkt Synthetisiere das Projekt und teste das Ergebnis am Board","tags":"test_vhdl","title":"VHDL Test (2)"},{"url":"https://www.semiversus.com/dic/programmierbare_logik/test_vhdl/test3.html","text":"Allgemeines Projektordner herunterladen und entpacken Insgesamt gibt es 29 Punkte Die einzelnen Punkte bauen meist nicht aufeinander auf. Statt langer Fehlersuche lieber auf das nächste Beispiel wechseln. Einschaltverzögerung Vorbereitung Projekt led_toggle/led_toggle.xise öffnen Aufgabenstellung Zwei LEDs sollen mittels zwei Taster angesteuert werden. button_toggle - Wechselt zwischen LED1 und LED2, bzw. schaltet LED1 ein, falls die LEDs ausgeschaltet waren. button_off - Schaltet die LEDs aus Entwurf der Zustandsmaschine 5 Punkte Zur Realisierung wird eine Zustandsmaschine genutzt. Bearbeite die Datei led_toggle_fsm.vhd Definiere die drei Zuständen OFF , LED1 und LED2 Der Startzustand ist OFF Der Eingang toggle_i wechselt von OFF nach LED1 bzw. wechselt von LED1 nach LED2 und umgekehrt Der Eingang off_i wechselt immer in den Zustand OFF Der Eingang off_i hat die höhere Priorität als der Eingang toggle_i Der Ausgang led1_o ist auf '1' , wenn die Zustandmaschine im Zustand LED1 ist Der Ausgang led2_o ist auf '1' , wenn die Zustandmaschine im Zustand LED2 ist Testbench Teste die Implementierung mittels der Testbench led_toggle_fsm_tb.vhd . Mittels F6 lässt sich der gesamte Bereich zoomen. Implementierung des Top Levels 5 Punkte Zur Verfügung stehen die Komponenten button_dectect und led_toggle_fsm . Diese Komponenten werden genutzt, um im Top Level led_toggle.vhd die gewünschte Funktionalität zu realisieren. Die Instanz der Komponente button_detect mit dem Namen toggle_detect_component ist bereits erstellt button_i ist mit dem Eingang button_toggle_i verbunden detect_o ist mit dem (bereits definiertem) Signal toggle_detect verbunden Erstelle eine Instanz der Komponente button_detect mit dem Namen off_detect_component analog zu toggle_detect_component button_i ist mit dem Eingang button_off_i verbunden detect_o ist mit dem (bereits definiertem) Signal off_detect verbunden Erstelle eine Instanz der Komponente led_toggle_fsm mit dem Namen led_toggle_fsm_component toggle_i ist mit dem Signal toggle_detect verbunden off_i ist mit dem Signal off_detect verbunden led1_o ist mit dem Ausgang led1_o verbunden led2_o ist mit dem Ausgang led2_o verbunden Jede Komponente hat einen Takteingang clk , welcher mit dem globalen clk verbunden wird Testbench Teste die Implementierung mittels der Testbench led_toggle_tb.vhd . Erweiterung der Constraints Datei 2 Punkte In der Datei led_toggle.ucf ist nur das Signal clk definiert. Erweitere die Datei um folgende Zuordnungen button_toggle_i wird durch den Taster BTN0 angesteuert button_off_i wird durch den Taster BTN1 angesteuert led1_o ist die LED LD0 led2_o ist die LED LD1 Pinout des BASYS2 Boards(Bild: Digilent Inc. BASYS2 Manual ) Test am Board 1 Punkt Synthetisiere das Projekt und teste das Ergebnis am Board Ampel mit Überwachung Vorbereitung Projekt lights/lights.xise öffnen Aufgabenstellung Es soll eine Ampel mit zwei Modis realisiert werden: Orange-Blinken (Orange Leuchte geht ein und aus) Wechsel zwischen Grün, Orange, Rot, Rot-Orange und wieder Grün Die Ausgänge für die drei Farben der Ampel werden mittels drei Bit Vektor dargestellt: Bit0 (ganz rechts) entspricht der grünen Leuchte Bit1 entspricht der orangen Leuchte Bit2 (ganz links) entspricht der roten Leuchte. So steht z.B. \"110\" für eine Ampel, bei der Rot und Orange leuchtet. Bei OFF soll nichts leuchten. Zusätzlich soll eine Überwachung vorhanden sein, die feststellt, ob es zu ungültigen Kombinationen gekommen ist (z.B. wenn Rot und Grün gleichzeitig leuchten). Die Überwachung würde in diesem Fall die Ampel Rot leuchten lassen. Überwachung 5 Punkte Die Komponente supervisor (deutsch Überwacher ) soll die Zustände der drei Lampen überprüfen. Dazu hat die Komponente den Eingang monitor_i und den Ausgang result_o . Liegt an monitor_i eine gültige Kombination an (z.B. \"001\" für Grün) soll diese Kombination am Ausgang result_o erscheinen Liegt eine ungültige Kombination an (z.B. \"101\" ) soll stattdessen die Kombination für Rot ausgegeben werden ( \"100\" ) Gültige Kombinationen sind alle Ausgaben der Zustände GREEN , ORANGE , RED , RED_ORANGE und OFF Die Komponente ist in vier Ausführungen ( Architectures ) bereits in der Datei supervisor.vhd beschrieben. Die Architectures lauten behave1 , behave2 , behave3 und behave4 . Erstelle in der Datei supervisor_tb.vhd eine Testbench, die herausfindet, welche der vier Ausführungen funktioniert (es ist genau eine). Komponente lights_fsm 5 Punkte Erstelle die Komponente lights_fsm durch Bearbeitung der Datei lights_fsm.vhd . Die Ampel wechselt nur den Zustand, wenn next_i gleich '1' ist Ist der Eingang mode_i gleich '0' soll die Ampel zwischen den Zuständen ORANGE und OFF wechseln Bei mode_i gleich '1' soll die Ampel zyklisch zwischen GREEN , ORANGE , RED , RED_ORANGE wechseln und anschließend bei GREEN wieder starten Ist die Ampel im Zustand GREEN , RED oder RED_ORANGE und mode_i ist '0' soll der nächste Zustand ORANGE sein Ist die Ampel im Zustand OFF und mode_i ist '1' soll der nächste Zustand ORANGE sein Der Startzustand ist ORANGE Testbench Teste die Implementierung mittels der Testbench lights_fsm_tb.vhd . Implementierung des Top Levels 5 Punkte Zur Verfügung stehen die Komponenten counter , light_fsm und supervisor . Diese Komponenten werden genutzt, um im Top Level lights.vhd die gewünschte Funktionalität zu realisieren. Mit dem counter soll ein 700 Millisekunden Takt generiert werden. Wieviel Takte des 50 Mhz Taktes sind dazu notwendig und wieviel Bits werden benötigt, um diesen Wert darstellen zu können? Trage diese Werte in der Default-Einstellung von COUNTER_WIDTH und COUNTER_MAXIMUM ein: entity lights is generic ( COUNTER_WIDTH : integer := 4 ; -- <<< TODO COUNTER_MAXIMUM : integer := 9 -- <<< TODO ); port ( clk : in std_ulogic ; -- 50 MHz clock mode_i : in std_ulogic ; leds_o : out std_ulogic_vector ( 2 downto 0 ) ); end entity ; Erstelle das Top Level anhand des folgenden Blockschaltbildes: Gegebenenfalls müssen noch Signale definiert werden. Testbench Teste die Implementierung mittels der Testbench lights_tb.vhd . Test am Board 1 Punkt Synthetisiere das Projekt und teste das Ergebnis am Board","tags":"test_vhdl","title":"VHDL Test (3)"},{"url":"https://www.semiversus.com/dic/programmierbare_logik/test_vhdl/test4.html","text":"Allgemeines Projektordner herunterladen und entpacken Insgesamt gibt es 20 Punkte Die einzelnen Punkte bauen meist nicht aufeinander auf. Statt langer Fehlersuche lieber auf das nächste Beispiel wechseln. Serielle Datenübertragung Vorbereitung Projekt transmitter.xise öffnen Aufgabenstellung Um Daten zu Übertragen wird oft die serielle Schnittstelle verwendet. In diesem Beispiel soll ein Transmitter entsprechend RS232 realisiert werden. RS232 Timingdiagramm (Bild: Gerald.deppe Public Domain) Zum Testen soll mittels der acht Umschaltern ( SW0 bis SW7 ) ein 8 Bit Datenwort definiert werden und durch Drücken des Tasters BTN0 wird dieses dann versendet . Zum Versenden wird der Pegel der Sendeleitung mittels LED angezeigt. Die Baudrate wird auf 1 Baud gestellt. uart_tx Komponente Zustandsmaschine 10 Punkte Die erforderliche Zustandsmaschine hat die Zustände IDLE , START , DATA und STOP Eingänge: send_i - startet die Übertragung Überlauf den Baudraten Generators - wechselt bei einer laufenden Übertragung zum nächsten Symbol Ausgänge: tx_o - das zu sendende Bit (bzw. Symbol) busy_o - zeigt eine laufende Übertragung an ( '1' wenn eine Übertragung läuft) Wenn die Zustandsmaschine im Zustand IDLE ist und send_i gleich '1' ist, dann wird in den Zustand START gewechselt. Vom Zustand START wird in den Zustand DATA gewechselt, sobald der Zähler für die Baudrate übergelaufen ist Im Zustand DATA läuft ein Bit Zähler und zählt die Bits von 0 bis 7 (LSB zuerst) Jedes Bit wird für die Dauer ausgegeben, die sich aus der Baudrate ergibt Nach dem 8. Datenbit wird in den Zustand STOP gewechselt Vom Zustand STOP wird in den Zustand IDLE gewechselt, sobald der Zähler für die Baudrate übergelaufen ist Ausgabe von tx_o Ist in IDLE und STOP auf '1' Ist in START auf '0' Entspricht während DATA dem zu übertragenden Datenbit Baudratengenerierung 2 Punkte Für die Baudratengenerierung wird der bestehende Zähler ( counter ) verwendet. Die Entity enthält die beiden Generics BAUDRATE_WIDTH und BAUDRATE_DIVIDER , die den Zähler konfigurieren. Bit Zähler 2 Punkte Um die einzelnen Datenbits zu zählen (während des Zustands DATA ) wird eine weitere Zählerinstanz verwendet. Diese Zählerinstanz zählt von 0 bis 7. Der Ausgang value_o des Bit Zählers ist vom Typ std_ulogic_vector . Dieser muss zuerst in einen unsigned und dann mittels to_integer in einen Integer gewandelt werden, um mittels Indexzugriff das gewünschte Bit aus dem data_i Vektor zu holen (z.B. data_i(0) holt Bit 0 des Vektors). Blockschaltbild Dieses Blockschaltbild zeigt die einzelnen Komponenten der uart_tx Komponente. Die resultierende VHDL Beschreibung sollte äquvivalent zu diesem Blockschaltbild sein. Testbench Teste die Implementierung mittels der Testbench uart_tx_tb.vhd . Implementierung des Top Levels 3 Punkte Zur Verfügung stehen die Komponenten button_dectect und uart_tx . Diese Komponenten werden genutzt, um im Top Level transmitter.vhd die gewünschte Funktionalität zu realisieren. Einige benötigte Signale sind bereits vordefiniert. Erstelle das Top Level anhand des folgenden Blockschaltbildes: Testbench Teste die Implementierung mittels der Testbench transmitter_tb.vhd . Erweiterung der Constraints Datei 2 Punkte In der Datei transmitter.ucf ist nur das Signal clk definiert. Erweitere die Datei um folgende Zuordnungen button_send_i liegt an Pin G12 switches_data_i(0) liegt an Pin P11 switches_data_i(1) liegt an Pin L3 switches_data_i(2) liegt an Pin K3 switches_data_i(3) liegt an Pin B4 switches_data_i(4) liegt an Pin G3 switches_data_i(5) liegt an Pin F3 switches_data_i(6) liegt an Pin E2 switches_data_i(7) liegt an Pin N3 led_tx_o liegt an Pin M5 led_busy_o liegt an Pin M11 Pinout des BASYS2 Boards(Bild: Digilent Inc. BASYS2 Manual ) Test am Board 1 Punkt Synthetisiere das Projekt und teste das Ergebnis am Board","tags":"test_vhdl","title":"VHDL Test (4)"},{"url":"https://www.semiversus.com/dic/bussysteme/test_bussysteme.html","text":"Inhalt Kanalkodierung Buskonzepte Fehlersicherung Parität Hamming-Abstand und -Code CAN Bus I²C Bus (Beispiel bei ADXL345 hinzugefügt) Frühere Tests Bei folgenden Tests werden teilweise Inhalte geprüft, die für den Test nicht relevant sind (USB, CANOpen) Test 1 , Musterlösung Test 2 , Musterlösung Test 3 , ohne Musterlösung Testablauf schriftlich, 30 Minuten Bleistift und Radiergummi mitnehmen! Kein Taschenrechner oder andere Hilfsmittel","tags":"bussysteme","title":"Test - Bussysteme"},{"url":"https://www.semiversus.com/dic/grundlagen_der_digitaltechnik/test_digitaltechnik.html","text":"Inhalt Automatentheorie Erstellung, Auswertung und Überprüfung von allgemeinen Automaten Graphische - und tabellenartige Darstellung Transistionen Digitale Automaten Timing, Asynchrones/Synchrones Design Begriffe Hazards Metastabilität Frühere Tests Hinweis Bei früheren Tests war Datenintegrität (Prüfsummen und Paritäten) enthalten. Test 1 , Musterlösung Test 2 , Musterlösung Test 3 , Musterlösung Testablauf schriftlich, 30 Minuten 31 Punkte (0-15 Punkte: Nicht genügend, 16-19: Genügend, 20-23: Befriedigend, 24-27: Gut, 28-31: Sehr gut) Bleistift und Radiergummi mitnehmen!","tags":"grundlagen_der_digitaltechnik","title":"Test - Allgemeine Digitaltechnik"},{"url":"https://www.semiversus.com/dic/hardwarenahe_programmierung/test_hardwarenahe_programmierung.html","text":"Inhalt C für Mikrocontroller IO mittels Portpins Interrupts RS232 und UART Timer ADC Frühere Tests Hinweis Bei früheren Tests war das Stoffgebiet teilweise anders! Test 1 , ohne Musterlösung Test 2 , Musterlösung Test 3 , Musterlösung Testablauf schriftlich, 30 Minuten Bleistift und Radiergummi mitnehmen!","tags":"hardwarenahe_programmierung","title":"Test - Hardwarenahe Programmierung"},{"url":"https://www.semiversus.com/dic/grundlagen_der_digitaltechnik/test_kombinatorik.html","text":"Inhalt Kombinatorik Erstellen einer Wahrheitstabelle mittels textueller Beschreibung Erstellen und Auswerten eines KV-Diagramms mit 3 oder 4 Variablen (DNF) Boolesche Funktionen als Schaltungen darstellen Umformen und Vereinfachen von Boole'schen Gleichungen Wichtige Schaltnetze Sequentielle Logik Funktionsweise der verschiedenen Speicherelemente Impulsdiagramme für verschiedene Speicherelemente zeichnen Unterschiede zwischen den Speicherelementen erklären Skriptum Kombinatorik Wichtige Schaltnetze Sequentielle Logik Frühere Tests Test 1 , Musterlösung Test 2 , Musterlösung Test 3 , Musterlösung Testablauf schriftlich, 15 Minuten Bleistift und Radiergummi mitnehmen!","tags":"grundlagen_der_digitaltechnik","title":"Test - Kombinatorik und Sequentielle Logik"},{"url":"https://www.semiversus.com/dic/rechnerarchitektur/test_rechnerarchitektur.html","text":"Inhalt Theorie Rechnerarchitektur Adressierungsarten Befehlssatz Aufbau eines Prozessors Wichtige Grundbegriffe (Von-Neumann - Harvard, CISC - RISC, ...) Atmel AVR DLX Prozessor Caching Praxis Assemblerprogrammierung Analysieren bestehender Programme (Funktion, Ausführungszeit, Programmgröße) Schreiben von Assemblerroutinen Erlaubte Unterlage: Zusammenfassung AVR Befehlssatz (wird zum Test ausgeteilt) Praxis Rechnerarchitektur Logisim Prozessor Praxis Caching Direktes Mapping Frühere Tests Test 1 , Musterlösung Test 2 , Musterlösung Test 3 , keine Musterlösung Testablauf schriftlich, 45 Minuten ca. 23 Punkte Bleistift und Radiergummi mitnehmen! Zusätzliches Papier ist nicht notwendig. Keine weiteren Hilfsmittel erlaubt (kein Taschenrechner, usw.)","tags":"rechnerarchitektur","title":"Test - Rechnerarchitektur"},{"url":"https://www.semiversus.com/dic/halbleiterelemente/test_transistor.html","text":"Inhalt Bipolarer Transistor Verwendung als Schalter Rechenbeispiele Schalten von induktiven Lasten Unipolarer Transistor Funktionsweise der verscheidenen Typen, Aufbau des Halbleiters Arbeiten mit den Kennlinienfeldern Rechenbeispiele aus dem Unterricht Testablauf schriftlich, 15 Minuten Bleistift, Radiergummi und Taschenrechner mitnehmen!","tags":"halbleiterelemente","title":"Test Transistor"},{"url":"https://www.semiversus.com/dic/grundlagen_der_digitaltechnik/timing.html","text":"Allgemeines Bisher wurden die Elemente der kombinatorischen Schaltnetze und der sequentiellen Schaltwerke so betrachtet, dass jede Änderung eines diskreten Zustandes (logisch 0 oder 1) unmittelbar zu einer Änderung führt. Für reale Bauelemente gilt dies nicht, da jede Änderung mit einer bestimmten Verzögerung behaftet ist. Diese Verzögerungen kommen teils durch die Ausbreitungsgeschwindigkeit selbst oder durch Ladevorgänge innerhalb der Bauteile. Ausbreitungsgeschwindigkeit Die Ausbreitungsgeschwindigkeit von Licht im Vakuum ist 299 792 458 Meter pro Sekunde. Elektronen bzw. genauer gesagt die Auswirkung einer Elektronenbewegung innerhalb eines Leiters bewegt sich annähernd mit Lichtgeschwindigkeit. So benötigt ein Impuls ca. 0.33 Nanosekunden für eine Strecke von 10 Zentimeter. Gatterlaufzeit Die Verzögerung durch ein einzelnes logisches Gatter wird Gatterlaufzeit (oder Englisch \" propagation delay \") genannt und bewegt sich je nach verwendeter Technologie des Bausteins zwischen etwa 100ps bis 100ns. Logikfamilie Leistung pro Gatter Gatterlaufzeit Low-Power-Schottky-TTL (LS-TTL) 2mW 10ns Advanced-Low-Power-Schottky-TTL (ALS-TTL) 1mW 4ns Emittergekoppelte Logik (ECL) 35mW 2ns High-Speed-ECL 50mW 0.4ns High-Speed CMOS (HC) 0.5mW/MHz 10ns (spannungsabhängig) Kritischer Pfad Der kritische Pfad ist jener Pfad, der die größte Gesamtverzögerung aufweist. Im folgenden ist dieser Pfad rot eingezeichnet: Der kritische Pfad weist hier eine Verzögerung von 2ns + 5ns + 5ns, also 12ns auf. Definitionen im Timingdiagramm Anstiegs- und Abfallzeiten Die Signalanstiegszeit (engl. Rise Time ) beschreibt die Dauer eines Wechsels von logisch 0 auf logisch 1. Die Zeit wird gemessen zwischen dem Durchgang bei 10 und 90 Prozent Pegel des High -Pegels. Das gleiche gilt für die Signalabfallzeit (engl. Fall Time ). Da je nach Technologie der Wechsel von logisch 0 auf 1 langsamer oder schneller als der umgekehrte Wechsel sein kann, werden diese Zeiten auch getrennt angegeben. Verzögerungszeiten Die Verzögerungszeit (engl. Propagation Delay ) beschreibt die Zeit zwischen einer Änderung am Eingang und der dazugehörigen Änderung am Ausgang des Gatters. Die Zeit wird zwischen den beiden 50 Prozent Durchgängen gemessen. Hazards Bei einem Hazard handelt es sich um einen Störimpuls, der durch Verzögerungen der Signalausbreitung innerhalb einer kombinatorischen Schaltung entsteht. Je nach Ursache unterscheidet man zwischen Logik-Hazards und Funktions-Hazards . Wenn die Ursache für den Hazard gefunden ist, kann dieser durch entsprechende Maßnahmen beseitigt werden. Logik Hazards Definition: Falls bei einer kombinatorischen Schaltung die Änderung eines einzigen Einganges zu einem Störimpuls am Ausgang führt, spricht man von einem logischen Hazard . Beispiel Multiplexer Am Beispiel eines Multiplexers sieht man das Auftreten eines Static-1 Hazards. Ein Static-1 Hazard ist ein Störimpuls bei einem Signal, welches rein kombinatorisch bei einer bestimmten Änderung eines Einganges vor und nach der Änderung logisch 1 ist. Der Hazard tritt nur auf, wenn A und B logisch 1 sind und S von logisch 1 auf 0 wechselt. Die Schaltung ist mittels Disjunktiver Normalform aufgebaut. Zuerst werden die einzelnen Minterme mittels AND -Verknüpfung gebildet und diese werden dann mittels OR -Verknüpfung zusammengefasst. Zeichnet man das KV-Diagramm auf, ergibt sich folgendes Bild: Man sieht die zwei unabhängige Minterme %%A\\overline{S}%% und %%BS%%. Wird das Signal S gewechselt, wechseln auch die zuständigen Minterme. Dies ist ein Zeichen dafür, dass ein Hazard auftreten kann . Damit ein logischer Hazard überhaupt auftreten kann, müssen folgende drei Bedingungen erfüllt sein: Das Eingangssignal muss sich in mindestens zwei Pfade auftrennen. Die verschiedenen Pfade müssen unterschiedliche Laufzeiten aufweisen. Die Pfade müssen über logische Verknüpfungen wieder an einem Ausgang zusammengefasst werden. Durch zusätzliche Gatter können logische Hazards abgefangen werden. Wir haben gesehen, dass der Hazard beim Wechsel zwischen den beiden Mintermen auftritt (bei A und B gleich logisch 1). Um nun diesen Fall abzufangen fügen wir einen weiteren Minterm AB hinzu: Dieser zusätzliche Primimplikant ist aus rein kombinatorischer Sicht redundant, er verhindert aber den Logik-Hazard . Funktionaler Hazard Definition: Falls bei einer kombinatorischen Schaltung die gleichzeitige Änderung an zwei oder mehr Eingängen zu einem Störimpuls am Ausgang führt, spricht man von einem funktionalen Hazard . Wenn wir in unserem Beispiel den Eingang A auf logisch 1 setzen und dann die Eingänge B und C gleichzeitig von 0 auf 1 ändern, kann es zu einem funktionalen Hazard kommen. Im KV-Diagramm sieht man diesen Wechsel. Der Weg kann über eine logische 0 oder 1 führen. Funktionale Hazards kann man in den meiste Fällen nicht durch Hinzufügen von redundanten Schaltelementen vermeiden.","tags":"grundlagen_der_digitaltechnik","title":"Timing in der Digitaltechnik"},{"url":"https://www.semiversus.com/dic/komplexe_digitale_systeme/tutorial1.html","text":"Allgemeines Unterlagen der Tuxcadamy Dieses Tutorial baut auf den Unterlagen der Tuxcadamy auf. Auch Aufgabenstellungen sind teilweise dort übernommen worden. Die Unterlagen stehen unter der CC-BY-SA Lizenz und somit auch dieses Tutorial. Eine Kopie der Unterlagen kann man hier herunterladen. Entstehungsgeschichte zu Linux 30 Minuten Lies Kapitel 1.1 und 1.2 (Seite 13 bis 16) über die Entstehungsgeschichte von Linux. Beantworte folgende Fragen: Was hat Linux mit Unix zu tun? Was hat Linus Torvalds mit Linux zu tun? Opensource Lizenzen 60 Minuten Lies Kapitel 1.3 (Seite 16 bis 20) und gib Antworten auf die Übungen am Ende des Kapitels. Recherchiere im Internet über die Vor- und Nachteile von Opensource Lizenzen Welche Vor- und Nachteile hat es für Anwender, Hobby-Programmierer und Firmen? Gruppendiskussion 20 Minuten Diskutiere in der Gruppe über die Vor- und Nachteile. Themen sollten sein: Qualität der Software: Closed Source - Open Source Können Firmen wirtschaftlich arbeiten, wenn sie ihre Arbeit jedem zur Verfügung stellen? Was spricht beim Thema Sicherheit für und gegen Open Source? Die Ausarbeitung sollte deine Meinung zu den einzelnen Fragen beantworten.","tags":"komplexe_digitale_systeme","title":"Tutorial 1 - Übersicht über Linux"},{"url":"https://www.semiversus.com/dic/komplexe_digitale_systeme/tutorial2.html","text":"Unterlagen der Tuxcadamy Dieses Tutorial baut auf den Unterlagen der Tuxcadamy auf. Auch Aufgabenstellungen sind teilweise dort übernommen worden. Die Unterlagen stehen unter der CC-BY-SA 4.0 Lizenz und somit auch dieses Tutorial. Eine Kopie der Unterlagen kann man hier herunterladen. Allgemeines Panel-info Definition durch Wikipedia - Shell In der Informatik bezeichnet man als Shell die Software, die den Benutzer mit dem Computer verbindet. Die Shell ermöglicht zum Beispiel, Kerneldienste zu nutzen und sich über Systemkomponenten zu informieren oder sie zu bedienen. Der Begriff „Shell\" (englisch für „Hülle\" oder „Außenhaut\") stammt von Muschelschalen und beschreibt eine Oberfläche zwischen dem Anwender und dem Inneren (den Kernel-Komponenten). Bei Betriebssystemen gibt es zwei Arten von Shells, die Kommandozeile (englisch C ommand- L ine I nterface CLI) und die grafischen Benutzeroberflächen (englisch G raphical U ser I nterface GUI). Jedoch ist in der Umgangssprache meist der Kommandozeileninterpreter als Shell gemeint. Vorbereitung Starte DICbian und logge dich mittels dem Benutzernamen dic und dem Passwort dic ein. Übung Arbeite dich durch die Kapitel 3 (Seite 39 bis 45), Kapitel 4 (Seite 47 bis 54) und Kapitel 6 (Seite 71 bis 98) und beantworte die jeweiligen Übungen. Beispiel für eine Übung aus den Unterlagen (Bild: Tuxcadamy CC BY-SA 4.0) Editor Ein einfacher Editor für Linux ist nano . Dieser ist auf den meisten Linux Systemen installiert und lässt sich leicht über die Kombinationen mit STRG bedienen. Weiter Infos über nano gibt es hier . Die wichtigsten Tastenkombinationen für nano : STRG + o bzw. F3 - Datei speichern STRG + x bzw. F2 - Datei schließen Nano Editor im Einsatz (Bild: ubuntuusers.de CC BY-NC-SA 2.0 DE) System herunterfahren Wenn man DICbian in der Virtualbox herunterfahren möchte muss man sich erst als Superuser anmelden. Dies wird mittels su gemacht (Passwort ist htl ). Anschließend kann man mittels poweroff das System herunterfahren. Herunterfahren von DICbian","tags":"komplexe_digitale_systeme","title":"Tutorial 2 - Einstieg in die Shell"},{"url":"https://www.semiversus.com/dic/komplexe_digitale_systeme/tutorial3.html","text":"Unterlagen der Tuxcadamy Dieses Tutorial baut auf den Unterlagen der Tuxcadamy auf. Auch Aufgabenstellungen sind teilweise dort übernommen worden. Die Unterlagen stehen unter der CC-BY-SA 4.0 Lizenz und somit auch dieses Tutorial. Eine Kopie der Unterlagen kann man hier herunterladen. Vorbereitung Für die folgende Übung benötigen wir die Datei frosch.txt auf der virtuellen Maschine. Dazu gibt es zwei Möglichkeiten: Download mittels wget oder Einrichten eines gemeinsamen Ordners. Es wird also nur ein Weg der zwei genannten benötigt. Download mittels wget wget ist ein Kommandozeilentool um Dateien mittels http:// Protokoll herunterzuladen. wget hat einen riesigen Funktionsumfang, wir benötigen aber nur das notwendigste: wget http://semiversus.com/dic/komplexe_digitale_systeme/frosch.txt Wenn eine Internetverbindung besteht sollte die Datei heruntergeladen werden und im aktuellen Verzeichnis abgelegt werden. Einrichten eines gemeinsamen Ordners Im VirtualBox Manager wird DICbian ausgewählt und in der Toolbar auf Ändern geklickt. Unter dem Punkt Gemeinsame Ordner wird ein entsprechender Eintrag hinzugefügt. DICbian neu starten Einloggen als normaler Nuter ( dic mit Passwort dic ) Superuser werden (mittels su in der Kommandozeile und Passwort htl ) Gemeinsamen Ordner mounten mittels mount -t vboxsf dic /mnt (wobei dic der Name des Eintrags für den gemeinsamen Ordner ist Nun ist der gemeinsame Ordner unter /mnt verfügbar Wechsle in das entsprechende Verzeichnis und kopiere die Datei ins Home -Verzeichnis ( ~ ) Übung Arbeite dich durch das Kapitel 7 (Seite 99 bis 104) und beantworte die jeweiligen Übungen.","tags":"komplexe_digitale_systeme","title":"Tutorial 3 - Reguläre Ausdrücke"},{"url":"https://www.semiversus.com/dic/komplexe_digitale_systeme/tutorial4.html","text":"Unterlagen der Tuxcadamy Dieses Tutorial baut auf den Unterlagen der Tuxcadamy auf. Auch Aufgabenstellungen sind teilweise dort übernommen worden. Die Unterlagen stehen unter der CC-BY-SA 4.0 Lizenz und somit auch dieses Tutorial. Eine Kopie der Unterlagen kann man hier herunterladen. Übung Arbeite dich durch das Kapitel 8 (Seite 105 bis 132) und beantworte die jeweiligen Übungen.","tags":"komplexe_digitale_systeme","title":"Tutorial 4 - Standardkanäle und Filterkommandos"},{"url":"https://www.semiversus.com/dic/komplexe_digitale_systeme/tutorial5.html","text":"Noch nicht freigeschaltet Wird erst später freigeschaltet","tags":"komplexe_digitale_systeme","title":"Tutorial 5"},{"url":"https://www.semiversus.com/dic/komplexe_digitale_systeme/tutorial6.html","text":"Noch nicht freigeschaltet Wird erst später freigeschaltet","tags":"komplexe_digitale_systeme","title":"Tutorial 6"},{"url":"https://www.semiversus.com/dic/bussysteme/uebersicht.html","text":"Inhalt Allgemeines Allgemeine Einführung Kanalkodierung Bussysteme RS232 CAN I²C (mit Übungen) Datenintegrität Datenintegrität und Prüfsummen Tests Schriftliche Tests","tags":"bussysteme","title":"Bussysteme"},{"url":"https://www.semiversus.com/dic/digitale_signalverarbeitung/uebersicht.html","text":"Inhalt Signale Lineare, Zeitinvariante Systeme Faltung Tests Test 1 , keine Musterlösung","tags":"digitale_signalverarbeitung","title":"Digitale Signalverarbeitung"},{"url":"https://www.semiversus.com/dic/grundlagen_der_digitaltechnik/uebersicht.html","text":"Inhalt Kombinatorik Kombinatorik KV-Diagramme Wichtige Schaltnetze Sequentielle Logik Sequentielle Logik Automatentheorie (mit Übungen) Timing in der Digitaltechnik Synchrones Design Tests Kombinatorik und sequentielle Logik Digitaltechnik","tags":"grundlagen_der_digitaltechnik","title":"Grundlagen der Digitaltechnik"},{"url":"https://www.semiversus.com/dic/halbleiterelemente/uebersicht.html","text":"Inhalt Bipolarer Transistor Grundlagen des bipolaren Transistor Bipolarer Transistor als Schalter Unipolarer Transistor Grundlagen des unipolaren Transistors Unipolarer Transistor als Schalter Anwendungen Ausgangstreiber Speicher Datenspeicher Übersicht Statische Datenspeicher Dynamische Datenspeicher Übung \"Expertenrunde Speicher\" Tests Schriftliche Tests","tags":"halbleiterelemente","title":"Halbleiterelemente"},{"url":"https://www.semiversus.com/dic/hardwarenahe_programmierung/uebersicht.html","text":"Inhalt Allgemeines Tastenentprellung AVR Allgemeines zu Atmel AVR IO mittels Portpins Interrupts Externe Interrupts UART Timer ADC Tests Schriftliche Tests","tags":"hardwarenahe_programmierung","title":"Hardwarenahe Programmierung"},{"url":"https://www.semiversus.com/dic/komplexe_digitale_systeme/uebersicht.html","text":"Inhalt Linux Tutorial Installation von Virtualbox mit DICbian Unterlagen der Tuxcadamy (stehen unter der CC-BY-SA Lizenz). Weitere Infos zur Tuxcadamy Tutorial 1 - Übersicht über Linux Tutorial 2 - Einstieg in die Shell Tutorial 3 - Reguläre Ausdrücke Tutorial 4 - Standardkanäle und Filterkommandos Anwendungen Raspberry Pi Echtzeitbetriebsysteme Übersicht Scheduling Prozesssynchronisation Tests Test 1 , ohne Musterlösung","tags":"komplexe_digitale_systeme","title":"Komplexe digitale Systeme"},{"url":"https://www.semiversus.com/dic/mikrocontroller/uebersicht.html","text":"Inhalt Einführung C Einführung C Aufbau von Fest- und Gleitkommazahlen Bitmanipulation (mit Übungen) C Programmierung für Embedded Systems Hardwareabstraktion Beschreibung der Megacard HAL ( Template ) Beispiel Safe (mit Musterlösung) Tests Test 1 - Push Fast Game Test 2 - Time Keep Game Test 3 - Küchenwecker","tags":"mikrocontroller","title":"Mikrocontroller"},{"url":"https://www.semiversus.com/dic/programmierbare_logik/uebersicht.html","text":"Inhalt Programmierbare Logische Anordnungen VHDL Einführung Grundlagen Signaltypen Operatoren Nebenläufigkeit process Statment VHDL Beschreibung für Grundkomponenten Register Synchronisierung asynchroner Signale Synchrone Flankerkennung Zähler Zustandsmaschine Modellierungsarten Übungen Übung 1 - Kombinatorische Umsetzung eines BCD auf 7 Segment Dekoders Übung 2 - Blinken einer LED Übung 3 - Toggeln einer LED mittels Taster Übung 4 - Unterteilung eines Design in Komponenten Übung 5 - Stoppuhr (universeller Zähler und Zustandsautomat) Übung 6 - Clicker (kleines Geschwindigkeitsspiel) Übung 7 - Testbench Tests Programmierbare Logik Bausteine VHDL","tags":"programmierbare_logik","title":"Programmierbare Logik"},{"url":"https://www.semiversus.com/dic/robotik/projektmanagment/uebersicht.html","text":"Inhalt GitHub/GitLab","tags":"projektmanagment","title":"Projektmanagment"},{"url":"https://www.semiversus.com/dic/robotik/python/uebersicht.html","text":"Tutorial Vorbereitungen Erste Beispiele Datentypen Hausübungen VSCode und erste Übung TODO Tests Mustertest ( Musterlösung )","tags":"python","title":"Python"},{"url":"https://www.semiversus.com/dic/rechnerarchitektur/uebersicht.html","text":"Allgemeines Funktionale Einheiten Programmiermodell Logisim Prozessor Atmel AVR Architektur und Assembler (mit Übungen) Tests Schriftliche Tests","tags":"rechnerarchitektur","title":"Rechnerarchitektur"},{"url":"https://www.semiversus.com/dic/programmierbare_logik/test_pla/uebersicht.html","text":"Inhalt Programmierbare Logische Anordnungen Beispiele aus dem Unterricht Frühere Tests Test von 2011/2012 , Musterlösung Test von 2012/2013 , Musterlösung Testablauf schriftlich, 15 Minuten Bleistift und Radiergummi mitnehmen! Übungsbeispiel PLA Beispiel Übungsblatt","tags":"test_pla","title":"Test - Programmierbare Logik"},{"url":"https://www.semiversus.com/dic/programmierbare_logik/test_vhdl/uebersicht.html","text":"Inhalt Reproduktion (VHDL Grundlagen) entity , architecture signals und die Typen std_ulogic , std_ulogic_vector , unsigned und integer process und concurrent statments Transfer (Aufbau von Designs) Kombinatorische Elemente: Addierer , Multiplexer , Vergleicher , usw. Sequentielle Elemente: Flip Flops mit/ohne Enable Analogie zwischen Schaltung und VHDL Modell Reflexion (Analyse von Designs) Ermittlung der Anzahl an verwendeten Flip Flops Verbesserungen des kritischen Pfads Testablauf am Computer, 2 Stunden (Durchführung als Übungsprojekt, nicht als Test) ca. 30 Punkte Frühere Tests Test 1 ( Musterlösung ) Test 2 ( Musterlösung ) Test 3 ( Musterlösung ) Test 4 ( Musterlösung )","tags":"test_vhdl","title":"Test - VHDL"},{"url":"https://www.semiversus.com/dic/uebersicht.html","text":"Digitale Systeme und Computersysteme Grundlagen der Digitaltechnik Programmierbare Logik Mikrocontroller Hardwarenahe Programmierung Halbleiterelemente Bussysteme Rechnerarchitektur Digitale Signalverarbeitung Komplexe digitale Systeme Robotik und Embedded Systems Projektmanagment Python RaspberryPi Suchalgorithmen Korrekturen Es haben sich mit der Zeit sicher einige Fehler hier eingeschlichen. Egal, ob sachliche Unkorrektheit bzw. Tipp- und Rechtschreibfehler - ich bin für jeden Hinweis dankbar! Bisher habe ich von folgenden Personen Korrekturhinweise bekommen: Patrick Zgubic - viele Korrekturen im Bereich Digitale Signalverarbeitung Florian Burtscher (@ Github , @ Stackoverflow , Homepage ) - Korrekturen im Bereich Digitale Signalverarbeitung Herbert Hart - Korrekturen im Bereich Digitale Signalverarbeitung Claus-Peter Bergmeier ( Email ) - Hinweise zu defektem Downloadlink des Logisim Prozessors. Er arbeitet selbst auch an einem eigenen Logisim Prozessor! Weitere Personen haben mir Korrekturen zugeschickt, bleiben aber lieber ohne Hinweis. Vielen Dank für eure Mitarbeit! Links Eine kleine Übersicht über Seiten, die mir zur Recherche dienten (neben den üblichen Verdächtigen wie Wikipedia und Co.): rn-wissen.de mosfetkiller.de nmp24.de mikrocontroller.net stiny-leonhard.de Zugang für Schüler Für Schüler gibt es einen Bereich mit Beurteilungen. Benutzername ist dic , Passwort wird im Unterricht bekanntgegeben. 5AHEL DIC 5AHEL und 5BHEL Robotik","tags":"dic","title":"Unterrichtsmaterial"},{"url":"https://www.semiversus.com/dic/mikrocontroller/uebersicht_c.html","text":"Übersicht Einen guten Übersicht über C Programmierung bietet das Open Book C von A bis Z aus dem Verlag Galileo Computing und das Wikibook C-Programmierung . Um die allgemeinen Beispiele leicht testen zu können, stehen Online Compiler zur Verfügung: Sourcelair Codepad IDEOne Die Übungen mit der Megacard werden mittels AVR Studio 5 durchgeführt. Das Installationspaket kann über die Atmel -Homepage heruntergeladen werden. \"Hello World\" Beispiel #include <stdio.h> int main () { printf ( \"Hello World!\" ); return 0 ; } Jedes Programm benötigt eine Funktion mit dem Namen main . Diese Funktion gibt einen Wert zurück, der den Erfolg der Ausführung anzeigt. Der Wert 0 wird meist als erfolgreiche Ausführung interpretiert, andere Werte können Fehler oder vorzeitige Abbrüche darstellen. Der Funktion main können vom Betriebssystem auch Parameter mitgegeben werden . Bei Microcontroller-Anwendungen ist dies üblicherweise nicht der Fall. Die Funktion printf wird verwendet um Ausgaben auf die Standardausgabe zu machen. Die Standardausgabe ist abhängig von der Art des Programmes. Bei Kommandozeilenprogrammen wird die Ausgabe direkt auf der Kommandozeile angezeigt. Bei Microcontrollern ist dies Implementierungsabhängig. Hier kann die serielle Schnittstelle oder ein Display genutzt werden. Um dieses Quellcode nun auszuführen bedarf es mehrerer Schritte, welche grob so zusammengefasst werden können: Präprozessor : Anweisungen an den Präprozessor werden Direktiven genannt und haben ein '#' vorangstellt. Im obigen Beispiel wird mittels #include die Datei stdio.h in diese Datei hineinkopiert. Kompilierung : Die Ausgabe des Präprozessors wird nun kompiliert, d.h. der C Quellcode wird in Maschinensprache übersetzt. Das Ergebnis wird Objektcode genannt. Linken : Da jede C Quellcode-Datei einzeln in eine Objektcode-Datei umgewandelt wurde, wird nun durch das Linken eine ausführbare Datei erstellt, die die einzelnen Funktionen und Verweise der Objektcode-Dateien zu einer gemeinsamen Datei zusammenführt. Ausführen : Beim Ausführen ruft das Betriebssystem oder der Startup-Code des Microcontrollers die Funktion main auf. In der Literatur sieht man oft als Ergebnis der Kompilierung eine Assemblerdatei. Der Assembler setzt diese Assemblerdatei dann in Maschinencode um. Die meisten aktuellen Compiler machen diesen Zwischenschritt nur mehr indirekt. Präprozessor Direktiven #include Direktive Mittels #include werden Dateien an der Stelle der #include Anweisung eingefügt. Die #include Anweisung ermöglicht das unter C übliche Modulkonzept, um Teile eines Programmes gekapselt in einem Modul zu verwalten. Ein Modul besteht dabei aus einer \" .c \" Datei ( Source ), die die Implementierung enthält und einer dazugehörigen \" .h \" Datei ( Header ), die die Funktionen und Variablen definiert, die das Modul exportiert, d.h. an andere Programmteile zur Verfügung stellt. #define Direktive #define hat verschiedene Anwendungen. Es wird verwendet um Symbole , Konstanten und Makros zu definieren. Die Unterscheidung, ob man auf eine Lösung mittels #define Direktive zurückgreift oder es mittels C Konstrukten außerhalb des Präprozessors löst, ist nicht einfach zu beantworten und erst mit der Erfahrung sieht man sinnvolle Einsatzmöglichkeiten. Symbol Ein Symbol kann definiert werden um es für eine bedingte Kompilierung zu nutzen. Dazu werden die Direktiven #ifdef , #ifndef , #else und #endif verwendet. #define DEBUG #ifdef DEBUG // Code der kompiliert wird, wenn DEBUG definiert wurde #else // Code der kompiliert wird, wenn DEBUG nicht definiert wurde #endif Konstante Durch die Definition einer Konstante wird einem Bezeichner eine Konstante zugewiesen. Der Präprozessor ersetzt dann bei jedem Vorkommen des Bezeichners diesen durch die Konstante. #define PI 3.1415 #define MESSAGE \"Hello World!\" float angle = PI ; printf ( MESSAGE ); Konstanten können auch ohne Präprozessor mittels const erzeugt werden. Makro Ein Makro ist eine Ersetzung mittels einer Funktion und deren Argumente. #define MEAN (a,b) ( (a+b)/2 ) printf ( \"Der Durchschnitt von 5 und 11 ist %d.\" , MEAN ( 5 , 11 ) ); Das Makro MEAN ist unabhängig vom Datentyp, da es sich um eine reine Textersetzung handelt. Dieses Makro kann auch mit einer C Funktion implementiert werden. Der Unterschied ist das Laufzeitverhalten, da ein Funktionsaufruf zusätzlich Zeit benötigt. Trotzdem ist die Verwendung von Makros nur für Programmierer mit Praxiserfahrung empfehlenswert. Ersetzung mittels C Funktion (mittels int Datentypen): int mean ( int a , int b ) { return ( a + b ) / 2 ; } Variablen Um innerhalb eines Programmes mit Variablen arbeiten zu können, müssen diese definiert werden. Bei der Definition wird einem Bezeichner ein Datentyp zugewiesen. Ganzzahlen Um Ganzzahlen (Zahlen ohne Nachkomma) zu definieren, gibt es in C folgende Datentypen: char : üblicherweise 1 Byte short int bzw. short : kleinerer Zahlenbereich als int int : meist 16 oder 32 Bit long int bzw. long : größerer Zahlenbereich als int Eine Variable kann vorzeichenbehaftet sein oder vorzeichenlos sein. Um eine vorzeichenlose Variable zu definieren muss unsigned vorgestellt werden (z.B. unsigned int ). Durch signed kann eine Variable explizit vorzeichenbehaftet definiert werden. Wenn eine Variable nicht explizit mittels signed oder unsigned ausgezeichnet wird, ist die Variable vorzeichenbehaftet. Die Größe des Zahlenbereichs der einzelnen Datentypen ist Plattform- und Compilerabhängig. So kann ein int 16 Bit (0-65535) oder 32 Bit (0-4294967295) groß sein. Die tatsächliche Größe eines Typs ist in der Datei limits.h abgelegt. Beispiele: int c ; // c ist ein (vorzeichenbehafteter) Integer unsigned long speed = 0 ; // speed ist ein vorzeichenloser long Integer und wird mit 0 initialisiert. char minimum , maximum = 10 ; // minimum und maximum sind Variablen vom Datentyp char. // maximum wird mit 10 initialisiert (minimum ist uninitialisiert). Plattformunabhängigkeit Steht ein C99 kompatibler C-Compiler zur Verfügung (gilt mittlerweile für den Großteil der Compiler) hilft die Verwendung der Datei stdint.h . Mittels #include werden neue Datentypen definiert, die eine bestimmte Größe haben. Dadurch werden unter anderem folgende Datentypen zur Verfügung gestellt: uint8_t , uint16_t , uint32_t und uint64_t : Vorzeichenlose Datentypen mit 8, 16, 32 bzw. 64 Bit int8_t , int16_t , int32_t und int64_t : Vorzeichenbehaftete Datentypen mit 8, 16, 32 bzw. 64 Bit Fließkommazahlen Fließkommazahlen sind Zahlen mit Nachkommastellen bzw. sehr große Zahlen. Intern wird die Mantisse und der Exponent getrennt gespeichert. C stellt dafür folgende zwei Datentypen zur Verfügung: float : Zahlen mit einfacher Genauigkeit (32Bit) double : Zahlen mit doppelter Genauigkeit (64Bit) Fließkommazahlen sind immer vorzeichenbehaftet. Fließkommazahlen können auch die Sonderwerte positiv unendlich , negativ unendlich und NaN ( Not a Number ) annehmen.","tags":"mikrocontroller","title":"Einführung C Programmierung"},{"url":"https://www.semiversus.com/dic/programmierbare_logik/uebung1.html","text":"Übungsaufgabe In dieser Übung wird das BASYS2 Board verwendet Für weitere Fragen zum Board bitte das Manual konsultieren. In dieser Übung nutzen wir vier Schalter des BASYS2 Boards (SW0 bis SW3) um damit eine 4 Bit Zahl einzugeben. Im FPGA soll eine Kombinatorik entworfen werden, um mittels dieser 4 Bit Zahl eine 7 Segment Anzeige anzusteuern. SW3 SW2 SW1 SW0 Ausgabe auf der 7 Segment Anzeige Aus Aus Aus Aus 0 Aus Aus Aus Ein 1 Aus Aus Ein Aus 2 Aus Aus Ein Ein 3 Aus Ein Aus Aus 4 Aus Ein Aus Ein 5 Aus Ein Ein Aus 6 Aus Ein Ein Ein 7 Ein Aus Aus Aus 8 Ein Aus Aus Ein 9 Vorbereitung Projektordner herunterladen und entpacken Projekt seven_segments.xise öffnen Top Level seven_segments.vhd seven_segments.vhd ist das Top Level Design und definiert die oberste Ebene, d.h. diese Entity beschreibt mit ihrer port -Direktive die Pins des FPGA Bausteins. library ieee ; use ieee.std_logic_1164. all ; entity seven_segment is port ( switches_i : in std_ulogic_vector ( 3 downto 0 ); an_o : out std_ulogic_vector ( 3 downto 0 ); segments_o : out std_ulogic_vector ( 6 downto 0 ) -- segments \"ABCDEFG\" ); end entity ; architecture behave of seven_segment is begin with switches_i select segments_o <= \"0000001\" when \"0000\" , -- display 0 \"1001111\" when \"0001\" , -- display 1 -- ... \"1111111\" when others ; an_o <= \"0111\" ; end architecture ; Pinout Die Signale switches_i , an_o und segments_o finden sich im folgenden Pinout des BASYS2 Boards: Pinout des BASYS2 Boards(Bild: Digilent Inc. BASYS2 Manual ) Das Pinout wird in der Datei seven_segments.ucf beschrieben. Für dieses VHDL Modell sieht es wie folgt aus: NET \"switches_i(3)\" LOC = \"B4\" ; NET \"switches_i(2)\" LOC = \"K3\" ; NET \"switches_i(1)\" LOC = \"L3\" ; NET \"switches_i(0)\" LOC = \"P11\" ; NET \"an_o(3)\" LOC = \"K14\" ; # driver for left most display NET \"an_o(2)\" LOC = \"M13\" ; NET \"an_o(1)\" LOC = \"J12\" ; NET \"an_o(0)\" LOC = \"F12\" ; # driver for right most display NET \"segments_o(6)\" LOC = \"L14\" ; # segment A NET \"segments_o(5)\" LOC = \"H12\" ; # segment B NET \"segments_o(4)\" LOC = \"N14\" ; # segment C NET \"segments_o(3)\" LOC = \"N11\" ; # segment D NET \"segments_o(2)\" LOC = \"P12\" ; # segment E NET \"segments_o(1)\" LOC = \"L13\" ; # segment F NET \"segments_o(0)\" LOC = \"M12\" ; # segment G 7-Segment Anzeige In der folgenden Abbildung sieht man die Anordnung der einzelnen Segmente: 7-Segment Anzeige des BASYS2 Boards(Bild: Digilent Inc. BASYS2 Manual ) Aufgabe 1 - Erweitern der kombinatorischen Beschreibung with switches_i ( 3 downto 0 ) select segments_o <= \"0000001\" when \"0000\" , -- digit 0 \"1001111\" when \"0001\" , -- digit 1 -- ... \"1111111\" when others ; Die kombinatorische Beschreibung ist nicht vollständig. Das Ziel ist es die Kombinatorik entsprechend um die Anzeige der Werte 2 bis 9 zu erweitern. Aufgabe 2 - Test auf dem Board Das Projekt soll synthetisiert und auf dem Board getestet werden. Aufgabe 3 - Erweiterung um die Darstellung von Hexadezimalzahlen SW3 SW2 SW1 SW0 Ausgabe auf der 7 Segment Anzeige Ein Aus Ein Aus A Ein Aus Ein Ein B Ein Ein Aus Aus C Ein Ein Aus Ein D Ein Ein Ein Aus E Ein Ein Ein Ein F Überlege dir, wie die einzelnen Segmente angesteuert werden sollen, um die Buchstaben A bis F darzustellen. Teste das Design auf dem BASYS2 Board","tags":"programmierbare_logik","title":"VHDL Übung 1 - Kombinatorische Logik"},{"url":"https://www.semiversus.com/dic/programmierbare_logik/uebung2.html","text":"Übungsaufgabe In dieser Übung wird das BASYS2 Board verwendet Für weitere Fragen zum Board bitte das Manual konsultieren. In dieser Übung wollen wir eine LED blinken lassen. Dazu nutzen wir den 50Mhz Takt, den das BASYS2 Board liefert. Vorbereitung Projektordner herunterladen und entpacken Projekt blink.xise öffnen Top Level blink.vhd library ieee ; use ieee.std_logic_1164. all ; use ieee.numeric_std. all ; entity blink is port ( clk : in std_ulogic ; -- 50 MHz clock led_o : out std_ulogic ); end entity ; architecture behave of blink is begin led_o <= '1' ; end architecture ; Aufgabe 1 - Erstellen der UCF Datei Der Takt clk befindet sich am Pin B8 . Die LED ( led_o ) ist am Pin M5 angeschlossen. Erweitere dazu die Datei blink.ucf (siehe Übung 1 - UCF Datei als Beispiel). Aufgabe 2 - Implementierung des Zählers Um nun eine LED blinken zu lassen benötigen wir einen Zähler. Wenn 50 Millionen Taktzyklen gezählt sind ist eine Sekunde vergangen. Dazu ändern wir die architecture wie folgt ab: architecture behave of blink is signal counter_reg : unsigned ( 31 downto 0 ) := ( others => '0' ); signal led_reg : std_ulogic := '0' ; begin counter_proc : process ( CLK ) begin if rising_edge ( CLK ) then if counter_reg = 50000000 then counter_reg <= ( others => '0' ); led_reg <= not led_reg ; else counter_reg <= counter_reg + 1 ; end if ; end if ; end process ; led_o <= led_reg ; end architecture ; Aufgabe 3 - Überprüfung der Funktionsweise Synthetisiere das Design und lade es auf das Board. Kontrolliere die korrekte Funktion. Aufgabe 4 - Timing Constraints setzen Es gibt im Moment keine Vorgaben an die Taktfrequenz. Um eine solche Vorgabe zu machen, müssen wir einen Timing Constraint setzen. Wir erweitern dazu die Datei blink.ucf um folgende zwei Zeilen, um einen Takt von 50 Mhz zu spezifizieren. NET \"clk\" TNM_NET = CLK ; TIMESPEC TS_CLK = PERIOD \"clk\" 50 MHz HIGH 50 % ; Nachdem wir nun das Projekt synthetisieren betrachten wir die Design Summary : Aufgabe 5 - Auswählbare Blinkfrequenz Erweiterung von blink.ucf um folgende Zeile: NET \"switch_i\" LOC=\"P11\"; Hinzufügen eines Eingangs in der Entity entity blink is port ( clk : in std_ulogic ; -- 50 MHz clock switch_i : in std_ulogic ; led_o : out std_ulogic ); end blink ; Nun soll die Blinkperiode bei switch_i gleich 0 eine Sekunde sein, bei 1 eine Zehntelsekunde.","tags":"programmierbare_logik","title":"VHDL Übung 2 - Blink"},{"url":"https://www.semiversus.com/dic/programmierbare_logik/uebung3.html","text":"Übungsaufgabe In dieser Übung wird das BASYS2 Board verwendet Für weitere Fragen zum Board bitte das Manual konsultieren. In dieser Übung wollen wir den Zustand einer LED mittels Tastendruck wechseln. Beim Start ist die LED aus, nach einem Tastendruck soll die LED ein sein, nach einem weiteren Tastendruck soll die LED wieder aus sein. Vorbereitung Projektordner herunterladen und entpacken Projekt toggle.xise öffnen Aufgabe 1 - Erste Implementierung architecture behave of toggle is signal led_reg : std_ulogic := '0' ; begin toggle_proc : process ( CLK ) begin if rising_edge ( CLK ) then if button_i = '1' then led_reg <= not led_reg ; end if ; end if ; end process ; led_o <= led_reg ; end architecture ; Aufgabe 2 - Verbesserung des Design Welches Problem ist in Aufgabe 1 aufgetreten? Wie kann es gelöst werden?","tags":"programmierbare_logik","title":"VHDL Übung 3 - Toggle"},{"url":"https://www.semiversus.com/dic/programmierbare_logik/uebung4.html","text":"Übungsaufgabe In dieser Übung wird das BASYS2 Board verwendet Für weitere Fragen zum Board bitte das Manual konsultieren. In dieser Übung wird die Unterteilung in mehrere Komponenten gezeigt. Vorbereitung Projektordner herunterladen und entpacken Projekt structural.xise öffnen Aufgabe 1 - Zeichne eine Schaltung für display.vhd In der Datei display.vhd werden die vier 7-Segment Anzeigen angesteuert. Dazu wird das Display mittels \"Multiplex\" angesteuert, sprich jeds einzelme 7-Segment Anzeige ist nur abwechselnd nur kurze Zeit aktiv. Durch den schnellen Wechsel bekommt das träge Auge des Menschen eine scheinbar \"stehende\" Anzeige zu sehen. Aufgabe 2 - CLK_DIVIDER CLK_DIVIDER ist ein Generic mit dem eine Komponente parametrisiert werden kann. Erweitere die Einbindung vom display in structural.vhd wie folgt: display_component : entity work . display generic map ( CLK_DIVIDER => 50000 ) port map ( digit0_i => \"0011\" , digit1_i => \"0010\" , digit2_i => \"0001\" , digit3_i => \"0000\" , clk => clk , segments_o => segments_o , an_o => an_o ); Damit ist die Geschwindigkeit, in der die Anzeigen gemultiplext werden parametrisierbar. Was passiert, wenn CLK_DIVIDER die Werte 50 oder 1 zugewiesen wird? Was bei den Werten eine Million oder 50 Millionen? Aufgabe 3 - Implementierung eines 16 Bit Zählers In der Datei structural.vhd soll ein 16 Bit Zähler implementiert werden, der mit 100 Hertz zählt. Nutze dazu die signals pre_counter_reg als Vorteiler und counter_reg als 16 Bit Zähler. Die beiden Zähler können mittels zwei process Anweisungen implementiert werden oder auch beide gemeinsam in einer process Anweisung. Im folgenden Beispiel wird auch die Aufteilung des 16 Bit Zählregisters auf die jeweils 4 Bit Eingänge digit0_i bis digit3_i gezeigt. architecture behave of structural is signal pre_counter_reg : integer range 0 to 500000 := 0 ; -- 50Mhz/500.000=100Hz signal counter_reg : unsigned ( 15 downto 0 ) := ( others => '0' ); begin -- -- < Hier > Implementierung der Zähler --- display_component : entity work . display port map ( digit0_i => std_ulogic_vector ( counter_reg ( 3 downto 0 )), digit1_i => std_ulogic_vector ( counter_reg ( 7 downto 4 )), digit2_i => std_ulogic_vector ( counter_reg ( 11 downto 8 )), digit3_i => std_ulogic_vector ( counter_reg ( 15 downto 12 )), clk => clk , segments_o => segments_o , an_o => an_o ); end architecture ; Aufgabe 4 - Rücksetzen des Zählers mittels button_i In der Toplevel-Entity ist ein Eingang button_i vorgesehen, der noch nicht verwendet wurde. Beim Drücken des Buttons soll der 16 Bit Zähler zurückgesetzt werden.","tags":"programmierbare_logik","title":"VHDL Übung 4 - Strukturelles Design"},{"url":"https://www.semiversus.com/dic/programmierbare_logik/uebung5.html","text":"Übungsaufgabe In dieser Übung wird das BASYS2 Board verwendet Für weitere Fragen zum Board bitte das Manual konsultieren. Entwurf einer universeller Zählerkomponente Erkennung eines Tastendrucks Implementierung einer Zustandsmaschine Aufbau eines Top Levels Die Stoppuhr entspricht in ihrer Bedienung einer klassichen digitalen Stoppuhr. Zwei Tasten reichen für die Bedienung aus: Start/Stop - die Zeitnehmung wird gestartet bzw. gestopped Reset/Lap - die Zeitnumung wird zurückgesetzt bzw. die Zwischenzeit angezeigt Die vier 7-Segment Anzeigen werden für die Ausgabe der Zeit verwendet (hier 0 Minuten, 13 Sekunden und 5 Zehntelsekunden): Vorbereitung Projektordner herunterladen und entpacken Projekt stopwatch.xise öffnen Entwicklung einer universellen Zählerkomponente Spezifikation Der Zähler soll folgende Spezifikation erfüllen (immer synchron zur steigenden Taktflanke von clk ): Wenn enable_i auf 0 ist soll der Zähler nicht zählen Wenn enable_i auf 1 ist soll der Zähler sich um eins erhöhen Wenn der Zählerstand MAXIMUM erreicht soll der Zähler (im nächsten Schritt) auf 0 gesetzt werden Solange reset_i auf 1 ist, soll der Zählerstand auf 0 gesetzt werden Ein gesetzes reset_i hat eine höhere Priorität als ein gesetzes enable_i value_o entspricht dem internen Zählerstand overflow_o ist 1 , wenn der interne Zählerstand bei MAXIMUM steht und enable_i auf 1 ist (kombinatorisch verknüpft) Implementierung Öffne counter.vhd Erweitere das Design entsprechend der folgenden Spezifikation (an den mit TODO markierte Stellen) Test mittels Testbench Wechsle im Design Tab bei View nach Simulation Wähle die Testbench counter_tb (Datei counter_tb.vhd ) Starte die Simulation mittels Simulate Behavioral Model Beim Durchlaufen der Testbench werden etwaige Fehler des Design angezeigt. Eine erfolgreiche Testbench endet ohne Fehlerausgaben: Tastendruck Erkennung Spezifikation Tasteneingänge sind asynchron zum globalen Takt, deswegen müssen sie einsynchronisiert werden. Nachdem der Eingang synchronisiert ist benötigt man im allgemeinen eine synchrone Flankenerkennung, d.h. bei einer steigenden Flanke soll der Ausgang detect_o für einen Taktzyklus lang auf 1 sein. Eine fallende Flanke soll ignoriert werden. Timingdiagramm Implementierung Bearbeite dazu die Datei button_detect.vhd . Die beiden Register button_reg1 und button_reg2 dienen der Einsynchronisierung des asynchronen Signals von button_i . Test mittels Testbench Wechsle im Design Tab bei View nach Simulation Wähle die Testbench button_detec_tb (Datei button_detect_tb.vhd ) Starte die Simulation mittels Simulate Behavioral Model Beim Durchlaufen der Testbench werden etwaige Fehler des Design angezeigt. Eine erfolgreiche Testbench endet ohne Fehlerausgaben (siehe Test des universellen Zählers ). Zustandsmaschine für die Stoppuhr Spezifikation Die Zustandsmaschine für die Stoppuhr soll im ersten Schritt drei Zustände umfassen: CLEARED Zeit läuft nicht Stoppuhr steht auf \"0:00:0\" Mittels Start/Stopp soll die Zeitnehmung starten *Reset/Lap+ hat keine Auswirkung RUNNING Zeit läuft Zeigt die aktuelle Zeit an Mittels Start/Stopp soll die Zeitnehmung gestoppt werden Reset/Lap hat keine Auswirkung STOPPED Stoppuhr läuft nicht Zeigt die (gestoppte) Zeit an Mittels Start/Stopp soll die Zeitnehmung fortgesetzt werden Mittels Reset/Lap soll die Zeit auf \"0:00:0\" zurückgesetzt werden Die Zustandmaschine hat zwei Eingaben (Taster Start/Stopp und Reset/Lap ). Die Ausgabe clear_o setzt die Zähler zurück. Solange enable_o auf '1' ist laufen die Zähler. Zustandsdiagramm Zeichne das Zustandsdiagramm. Wähle einen passenden Zustandsmaschinentyp aus ( Mealy oder Moore ). Implementierung Vervollständige die Vorlage von stopwatch_fsm . Dort sind die Zustände CLEARED , RUNNING und STOPPED als Typ definiert. Die Behandlung des Zustands CLEARED und die Ausgabe von clear_o ist als Beispiel bereits implementiert. Der Ausgang mode_o wird erst später benötigt und soll vorerst nur '0' ausgeben. architecture behave of stopwatch_fsm is type state_t is ( CLEARED , RUNNING , STOPPED ); signal state : state_t := CLEARED ; begin fsm_process : process ( clk ) begin if rising_edge ( clk ) then case state is when CLEARED => if ss_i = '1' then state <= RUNNING ; end if ; when RUNNING => -- TODO when others => -- includes STOPPED -- TODO end case ; end if ; end process ; clear_o <= '1' when state = CLEARED else '0' ; enable_o <= '0' ; -- <<< TODO mode_o <= '0' ; end architecture ; Test mittels Testbench Teste die Zustandmaschine mittels der Testbench stopwatch_fsm_simple_tb (Achte auf das simple im Name!). Integration aller Komponenten im Top Level Mit den erstellten Komponenten wird nun ein Stoppuhr-Design aufgebaut. Dazu erweitern wird das Top Level Design in stopwatch.vhd . Tastendruckerkennung` Die Komponente button_dect wird verwendet, um das Signal button_ss_i und button_rl_i einzusynchronisieren und auf eine steigende Flanke zu überprüfen. Dazu wird folgende Komponente in der architecture von stopwatch.vhd hinzugefügt: button_ss_detect_component : entity work . button_detect port map ( clk => clk , button_i => button_ss_i , detect_o => button_ss_detect ); Analoges Vorgehen für die Taste button_rl_i . Zustandsmaschine Die Zustandmaschine wird nun auch entsprechend eingebunden. Erstelle eine Instanz von stopwatch_fsm mit dem Namen stopwatch_fsm_component Verbinde den Eingang clk mit dem Signal clk Verbinde den Eingang ss_i mit dem Signal button_ss_detect Verbinde den Eingang rl_i mit dem Signal button_rl_detect Verbinde den Ausgang mode_o mit nichts ( open ) Verbinde den Ausgang clear_o mit dem Signal clear Verbinde den Ausgang enable_o mit dem Signal enable Vorteiler Um Zehntelsekunden zu erzeugen wird ein Vorteiler mit dem Faktor 5 Millionen verwendet. prescale_component : entity work . counter generic map ( WIDTH => 23 , MAXIMUM => 5000000 ) port map ( clk => clk , reset_i => clear , enable_i => enable , value_o => open , overflow_o => tenth_second_enable ); Diese counter wird über das generic map als Zähler mit 23 Bit und Maximum bei 5 Millionen definiert Der Ausgang value_o wird nicht verwendet (wird durch open signalisiert) overflow_o steuert das Signal tenth_second_enable an (ist nun alle 5 Millionen Takte für einen Takt high) enable_i wird durch enable angesteuert (Ausgang der Zustandsmaschine) reset_i wird durch clear angesteuert (Ausgang der Zustandsmaschine) Zehntelsekunde Erstelle eine weitere Instanz eines Zählers( tenth_second_component ) analog zu prescale_component WIDTH und MAXIMUM müssen nicht extra definiert werden ( generic map kann wegfallen), da diese Werte der Standardeinstellung entsprechen enable_i wird durch tenth_second_enable angesteuert reset_i wird durch clear angesteuert value_o steuert digit0 an overflow_o steuert second_enable an Sekunde Erstelle eine weitere Instanz eines Zählers( second_component ) analog zu tenth_second_component enable_i wird durch second_enable angesteuert value_o steuert digit1 an overflow_o steuert ten_second_enable an Zehner Sekunde Erstelle eine weitere Instanz eines Zählers( ten_second_component ) analog zu tenth_second_component MAXIMUM wird auf 5 gestellt (Sekunden gehen bis 59) - dazu wird die generic map genutzt enable_i wird durch ten_second_enable angesteuert value_o steuert digit2 an overflow_o steuert minute_enable an Minute Erstelle eine weitere Instanz eines Zählers( minute_component ) analog zu tenth_second_component enable_i wird durch minute_enable angesteuert value_o steuert digit3 an overflow_o wird nicht verwendet (mit open verbunden) display hinzufügen display_component : entity work . display port map ( clk => clk , digit0_i => digit0 , digit1_i => digit1 , digit2_i => digit2 , digit3_i => digit3 , dots_i => \"1010\" , segments_o => segments_o , an_o => an_o ); Test auf der Hardware Wechsle in die Implementierungsansicht und synthetisiere das Top Level Desgin stopwatch . Teste die Funktionsweise auf dem Basys2 Board aus. Erweiterung um Zwischenzeitnehmung Spezifikation Im letzen Schritt gibt es eine Erweiterung des bestehenden Designs: Die Zwischenzeitnehmung. Im Zustand RUNNING wird durch Drücken von Reset/Lap in den Zustand LAP gwechselt werden In LAP wird nicht die aktuelle Zeit angezeigt, sondern eine zwischengespeicherter Zeit Im Zustand LAP wird durch Drücken von Reset/Lap wieder zurück in den Zustand RUNNING gewechselt werden Im Zustand LAP wird durch Drücken von Start/Stopp in den Zustand LAP_STOPPED gewechselt werden Im Zustand LAP_STOPPED läuft die Zeit nicht weiter, es wird weiterhin die zwischengespeicherte Zeit angezeigt Im Zustand LAP_STOPPED wird durch Drücken von Reset/Lap in den Zustand STOPPED gewechselt Implementierung Die Eingänge digit0 bis digit3 der display_component werden nun nicht mehr über die Zähler angesteuert sondern mittels Register ( digit0_reg , ... ist bereits definiert). Dieses Register soll die Eingänge digit0 , ... übernehmen, wenn das Signal mode auf '1' ist (Ausgang der Zustandsmaschine). Füge dazu einen process im Top Level ein. Erweitere die Zustandsmaschine um die zusätzlichen Zustände und steuere mode_o entsprechend der Spezifikation an. Test mittels Testbench Für die überarbeitete Zustandsmaschine steht eine Testbench bereit ( stopwatch_fsm_tb ). Test auf der Hardware Wechsle in die Implementierungsansicht und synthetisiere das Top Level Desgin stopwatch . Teste die Funktionsweise auf dem Basys2 Board aus.","tags":"programmierbare_logik","title":"VHDL Übung 5 - Stoppuhr"},{"url":"https://www.semiversus.com/dic/programmierbare_logik/uebung6.html","text":"Übungsaufgabe In dieser Übung wird das BASYS2 Board verwendet Für weitere Fragen zum Board bitte das Manual konsultieren. Definition einer Zustandmaschine Integration der Komponenten im Top Level Vorbereitung Projektordner herunterladen und entpacken Projekt clicker.xise öffnen Aufbau des Top Levels Spezifikation Im ersten Schritt soll ein Design erstellt werden, das über zwei Tasten angesteuert wird: tap - Mit dieser Taste wird das Spiel gestartet und während des Spiels werden die Tastendrücke gezählt reset - Diese Taste führt zum Spielanfang Das Spiel kennt drei Zustände: CLEARED - Der initiale Zustand, alle Zähler werden gelöscht. Der Tastendruck von reset führt immer hierher. RUNNING - Das Spiel läuft für 60 Sekunden. Die Anzahl der Tastendrücke von tap wird mitgezählt. STOPPED - Nach den 60 Sekunden werden die Zähler angehalten (und somit das Ergebnis angezeigt) Für dieses Spiel lassen sich viele Komponenten von Übung 5 (Stoppuhr) wiederverwenden. Implementierung Im folgenden Bild ist die gesamte Schalung und das Zustandsdiagramm zu sehen. Das Ziel ist eine Implementierung im Top Level. Orientierung bietet Übung 5 .","tags":"programmierbare_logik","title":"VHDL Übung 6 - Clicker"},{"url":"https://www.semiversus.com/dic/programmierbare_logik/uebung7.html","text":"Übungsaufgabe In dieser Übung geht es um Testbenches. Vorbereitung Projektordner herunterladen und entpacken Projekt testbench.xise öffnen Schreiben der Testbench Spezifikation Die Komponente shifter soll folgender Spezifikation entsprechen Die Komponente hat einen Ausgangsvektor leds_o mit 4 Bit Breite Nach dem Reset bzw. nach der Initialisierung wird \"0001\" auf leds_o ausgegeben. Ist während einer steigenden Taktflanke an clk_i der Eingang up_i aktiv sollen die Ausgänge in folgender Reihenfolge wechseln: \"0010\" , \"0100\" , \"1000\" und dann wieder \"0001\" Ist während einer steigenden Taktflanke an clk_i der Eingang down_i aktiv sollen die Ausgänge in folgender Reihenfolge wechseln: \"1000\" , \"0100\" , \"0010\" und dann wieder \"0001\" down_i hat die höhere Priorität wie up_i Ist weder up_i noch down_i aktiv, soll sich der Ausgang nicht verändern Der Eingang reset_i führt einen asynchronen Reset aus und dies hat die höchste Priorität Schreiben der Testbench Erweitere die Datei shifter_tb.vhd . Mittels assert können Bedingungen geprüft werden. Mittels wait for kann für eine bestimmte Zeit gewartet werden. Beispiel: wait for 10 ns ; assert leds_o = \"0001\" report \"Nach dem Reset sollte der Ausgang auf 0001 sein\" ; Der Teil mit report ist optional. Ein wait for 0 ns wertet einmal alle Signale aus, dies hilft oft direkt nach dem Start der Simulation (unmittelbar nach dem Start sind alle Signale uninitialised - 'U' ). Prüfen der Testbench Für die Komponente shifter stehen vier verschiedene Implementierungen zur Verfügung ( architectures ). Die Testbench soll erkennen, welcher der vier Implementierungen funktioniert. Die Testbenches heißen behave1 , behave2 , behave3 und behave4 .","tags":"programmierbare_logik","title":"VHDL Übung 7 - Testbench"},{"url":"https://www.semiversus.com/dic/grundlagen_der_digitaltechnik/uebung_automatentheorie.html","text":"Graphische Darstellung des Getränke-Automaten Stelle das Beispiel des Getränke-Automaten graphisch dar Automat mittels Logisim Realisiere mittels Logisim den folgenden Automaten: Eingabealphabet Σ={E0,E1,E2}={ 00 , 01 , 10 } Eingabe wird über die beiden Leitungen e1 und e0 realisiert. Ausgabealphabet Γ={A0, A1}={ 01 , 10 } Ausgabe wird über die beiden Leitungen a1 und a0 realisiert. Zustandsmenge Z={Z0,Z1,Z2}={ 00 , 01 , 10 } Der Zustand wird über die beiden D-Flip-Flop z1 und z0 realisiert. Zustandsübertragungsfunktion δ E0 E1 E2 Z0 Z0 Z0 Z1 Z1 Z2 Z2 Z2 Z2 Z0 Z1 Z2 Ausgabefunktion ω E0 E1 E2 Z0 A0 A0 A0 Z1 A0 A1 A0 Z2 A1 A1 A1","tags":"grundlagen_der_digitaltechnik","title":"Übung zur Automatentheorie"},{"url":"https://www.semiversus.com/dic/rechnerarchitektur/uebung_avr_assembler.html","text":"Allgemeines Die Übungen sollten gut kommentiert werden. Ein Programm kann hinsichtlich Programmgröße oder Ausführungsgeschwindigkeit optimiert werden. Als Hilfe eignet sich die Kurzübersicht der AVR Assembler Befehle. Daten vertauschen Daten liegen im SRAM ab Adresse 0x60 bis zur Adresse 0x15F. Ziel des Assembler Programmes ist es, diesen Datenbereich zu \"drehen\" -> Der Wert in Adresse 0x60 wird mit dem Wert in Adresse 0x15F vertauscht, anschließend der Wert in Adresse 0x61 mit dem Wert in Adresse 0x15E, usw. . Hinweise Nutze die Register X und Y zur indirekten Adressierung Funktioniert das Programm auch, wenn man das Ende des Datenbereiches (0x15F) nach hinten oder vorne verschiebt? Beachte den Fall, dass eine ungerade Anzahl von Bytes vertauscht werden! Wie groß ist das Programm und wie viel Taktzyklen werden für die Ausführung benötigt? Multiplikation aller Elemente eines Arrays Im SRAM liegen ab Adresse 0x60 insgesamt 32 16-Bit Werte (auf 0x60 liegt das höherwertigere Byte). Diese sollen alle mit 5 mulitpliziert werden und an der ursprünglichen Stelle im SRAM wieder abgelegt werden. Hinweise Nutze das Y oder Z Register zur indirekten Adressierung (Anwendung von ldd) Für die Multiplikation m=n 5 gilt m=n 4+n, wobei sich Multiplikationen mit dem Faktor zwei durch linksschieben lösen lassen Das Schieben und Addieren von 16 Bit Werten wird aufgeteit in zwei 8 Bit Operationen mit Berücksichtigung des Übertrags Wie groß ist das Programm und wie viel Taktzyklen werden für die Ausführung benötigt? Alarmanlage An Port A sind drei Alarmsensoren angeschlossen (Bit 0 - 2). Wird ein Alarm ausgelöst, soll die entsprechende LED an Port C (Bit 0 - 2, High-aktiv) aufleuchten, um den Sensor zu signalisieren. Der Alarm wird mittels einem Taster auf Port A (Bit 3) zurückgesetzt. Der Taster sowie die Alarmsensoren benötigen einen aktivierten Pull-Up am Eingang und sind aktiv (bzw. sollen den Alarm auslösen), wenn sie auf Massepotential sind (Low-aktiv). Hinweise Nutze eine Main-Loop um die Eingänge dauernd zu überprüfen Weise die Funktion im Simulator und auf der Megacard nach Wenn ein Sensor ausgelöst hat und später ein zweiter auslöst soll auch dieser angezeigt werden. Erweiterung 1: Der Alarm soll nur zurückgesetzt werden können, wenn kein Alarmsensor mehr aktiv ist Erweiterung 2: An Port C (Bit 3) wird ein Relais angesteuert (High-aktiv), um einen Alarmsirene anzusteuern. Wird einmal Alarm ausgelöst, soll dieses Relais anziehen. Beim Deaktivieren des Alarms soll es wieder abfallen. Expertenaufgabe: Fibonacci Erstelle eine Subroutine, die rekursiv die n-te Fibonacci Zahl berechnet. Dabei gilt: fib(0)=1 fib(1)=1 fib(n)=fib(n-1)+fib(n-2) Hinweise Nutze den Stack um die Parameter und Ergebnisse zu übertragen Nutze das Register Y als Kopie des Stackpointers, um auf Daten relativ zum Stackpointer zuzugreifen (sog. Stackframe-Pointer) Mittels Displacment Adressierung kannst du nun auf die Parameter, die am Stack liegen zugreifen Analyse 1 .include \"m16def.inc\" clr R16 loop: out PORTB , R16 inc R16 mov R17 , R16 andi R17 , 0x0F cpi R17 , 0x0A brlo loop ldi R17 , 0x06 add R16 , R17 cpi R16 , 0xA0 brlo loop end: rjmp end Was macht das Programm, wieviele Takte benötigt es für die Ausführung (bis zum Label end ) und wie groß ist das Programm? Hinweise Das Programm nutzt die BCD (Binary Coded Decimals) Darstellung einer Zahl Bei der Laufzeitanalyse ist wichtig, die genau Anzahl der Schleifendurchläufe zu kennen Beachte, dass die branch -Befehle je nach Erfüllung der Bedingung unterschiedlich viele Taktzyklen benötigt Analyse 2 .include \"m16def.inc\" clr XH ldi XL , 0x60 clr R17 ldi R18 , 8 loop: cpi R18 , 0 breq end dec R18 ld R16 , X + cp R16 , R17 brlo loop mov R17 , R16 rjmp loop end: rjmp end Der Speicherinhalt vor der Ausführung des Programmes: 0x5F 0x60 0x61 0x62 0x63 0x64 0x65 0x66 0x67 0x68 0x69 0x00 0x03 0x01 0x0e 0x03 0x05 0x16 0x00 0x05 0x15 0x20 Wie groß ist das Programm und wie viel Taktzyklen benötigt es? Wie schaut der Speicher nach der Durchführung aus? Was machen die Register R16, R17 und R18? Versuche in einem Satz zu formulieren, was das Programm macht. Analyse 3 .include \"m16def.inc\" clr XH ldi XL , 0x60 clr R17 start: ld R16 , X + cpi R16 , 0x00 breq end cpi R16 , 0x61 breq vowelcount cpi R16 , 0x65 breq vowelcount cpi R16 , 0x69 breq vowelcount cpi R16 , 0x6F breq vowelcount cpi R16 , 0x75 brne start vowelcount: inc R17 rjmp start end: rjmp end Der Speicherinhalt vor der Ausführung des Programmes: 0x5F 0x60 0x61 0x62 0x63 0x64 0x65 0x66 0x67 0x68 0x00 0x70 0x6C 0x61 0x74 0x65 0x61 0x75 0x00 0xAA Wie groß ist das Programm und wie viel Taktzyklen benötigt es? Wie schaut der Speicher nach der Durchführung aus? Beschreibe in einem Satz die Funktion. Welchen Wert hat nach der Ausführung das Register R16, R17 und X? Hinweis Das Programm nutzt die ASCII Darstellung von Zeichen.","tags":"rechnerarchitektur","title":"Übung AVR Assembler"},{"url":"https://www.semiversus.com/dic/robotik/projektmanagment/uebung_github.html","text":"","tags":"projektmanagment","title":"Übung Github"},{"url":"https://www.semiversus.com/dic/bussysteme/uebung_i2c.html","text":"Aufgabe ADXL345 In dieser Übung wird der Beschleunigungssensor ADXL345 von Analog Devices angesteuert. Die angaben stammen aus dem entsprechenden Datenblatt . Die 7-Bit Adresse des Bausteins wird für diese Übung mit 001 1101 (0x1D) angenommen. Register Der Baustein verfügt intern über mehrere Register. Jeder Register ist ein Byte groß. Registerübersicht (Bild: Datenblatt ADXL345 ©Analog Devices) In der folgenden Abbildung sieht man insgesamt vier Übertragungsarten: Schreiben eines Bytes in ein Register Schreiben mehrerer Byte in mehrere Register Lesen eines Bytes aus einem Register Lesen mehrere Bytes aus mehreren Registern Lesen und Schreiben einzelner sowie mehrer Bytes (Bild: Datenblatt ADXL345 ©Analog Devices) Hinweise zum Bild: Dieses START ist entweder ein repeated START oder ein STOP mit anschließendem START Der graue schattierte Bereich markiert die Phasen, in denen die entsprechende Komponente den Buszustand beobachtet Beispiel Beschreiben des Registers OFSX (0x1E) mit dem Wert 0x02: Lesen der Register THRES_ACT und THRES_INACT (0x24 und 0x25) Aufgabenstellung Skizziere folgende Übertragungen am I²C Bus: Beschreiben des Registers DUR mit dem Wert 0x05 Bechreiben der Registers OFSX , OFSY , OFSZ mit den Werten [0x17, 0x2A, 0x04] (mit nur einem Zugriff) Lesen des Registers ACT_TAP_STATUS (angenommener Inhalt ist 0x10 ) Lesen der Register DATAX0 bis DATAY1 (angenommener Inhalt ist [0x08, 0xE3, 0x01, 0xA7] , mit nur einem Zugriff)","tags":"bussysteme","title":"I²C Übungsaufgaben"},{"url":"https://www.semiversus.com/dic/mikrocontroller/uebung_safe.html","text":"Übungsaufgabe In dieser Übung wird die Megacard verwendet In diesem Beispiel soll ein Tresor (engl. Safe ) implementiert werden. Dazu werden die vier Tasten S0 - S3 genutzt, um den Code einzutippen ( S0 entspricht Ziffer '1', S1 entspricht '2', usw.). Vorbereitung Projektordner herunterladen und entpacken Projekt safe.avrgccproj öffnen Spezifikation Der Code hat vier Stellen (mit den Ziffern 1 bis 4) Nach dem Reset ist der Code \"1234\" Zustand CLOSED : Nach dem Reset befindet sich die Applikation im Zustand CLOSED Das Display zeigt den Text \"CLOSED\" in der ersten Zeile, die zweite Zeile ist leer Wird einer der Taster S0 bis S3 gedrückt wird der entsprechende Tastendruck gespeichert und pro Ziffer ein * in der zweiten Zeile angezeigt Nach dem vierten Tastendruck wird der eingegebene Code ausgewertet Bei falscher Codeeingabe: In der ersten Zeile wird \"WRONG\" und der zweiten Zeile \"CODE\" ausgegeben Nach zwei Sekunden oder einem Tastendruck wird in den Zustand CLOSED gewechselt Bei richtiger Codeeingabe In der ersten Zeile wird \"OPENED\" ausgegeben, die zweiten Zeile ist leer Nach drei Sekunden wird in den Zustand CLOSED gewechselt Wird innerhalb der drei Sekunden ein Taster gedrückt wird dies als erste Ziffer für den neuen Code verwendet und ein neuer Code kann eingegeben werden Eingabe eines neuen Codes: In der ersten Zeile steht \"NEW CODE\", die zweite Zeile zeigt den bisher eingegebenen Code (z.B. \"41\") Sind alle vier Ziffern eingegeben wechselt die Applikation nach zwei Sekunden in den Zustand CLOSED Hinweise zur Implementierung Speicherung des Codes Der vierstellige Code kann auf verschiedene Arten gespeichert werden. Es bieten sich zwei Möglichkeiten an: Speicherung im Array und Speicherung als Integer. Speicherung im Array Es wird ein Array der Länge vier genutzt, um die einzelnen Ziffern zu speichern. Es werden zwei Arrays benötigt: eines zur Speicherung des geforderten Codes und eines, das den Code während der Eingabe speichert. Der und entsprechend mit dem Standardcode initialisiert (\"1234\"). uint8_t code_stored [ 4 ] = { 1 , 2 , 3 , 4 }; uint8_t code_actual [ 4 ]; Tippt der Anwender den Code ein wird jede Ziffer an der entsprechenden Stelle im Array gespeichert: code_actual [ index ] = key ; // index gibt die aktuelle Codepostion an, key die zu speichernde Ziffer Um den Code anschließend zu vergleichen: if ( code_actual [ 0 ] == code_stored [ 0 ] && code_actual [ 1 ] == code_stored [ 1 ] && code_actual [ 2 ] == code_stored [ 2 ] && code_actual [ 3 ] == code_stored [ 3 ]) { // Code ist richtig } else { // Code ist falsch } Beim Array Vergleich muss jeder Wert einzeln geprüft werden Es funktioniert nicht einen Vergleich von code_actual==code_stored zu machen. Da code_actual und code_stored jeweils Arrays und damit Zeiger auf eine Speicherstelle sind werden auch nur diese Zeiger verglichen. Und diese werden immer auf unterschiedliche Positionen im Speicher zeigen! Speicherung als Integer Der Code kann aber auch direkt als Integer gespeichert werden. Wieder sind zwei Variablen notwendig: eine zur Speicherung des geforderten Codes und eine, die den Code während der Eingabe speichert. uint16_t code_stored = 1234 ; uint16_t code_actual ; Die größte zu darzustellende Zahl ist 4444, welche mit einem 16 Bit Integer dargestellt werden kann (%%2&#94;{16}=65535%%). Tippt der Anwender eine neue Ziffer ein wird die aktuelle Zahl mit 10 multipliziert und die eingetippte Ziffer hinzuaddiert. Durch die Multiplikation mit 10 wird der bisher eingegebene Code um eine Dezimalstelle nach links geschoben. code_actual = code_actual * 10 + key ; // key beinhaltet die zu speichernde Ziffer Die Überprüfung des Codes wird nun wesentlich einfacher: if ( code_actual == code_stored ) { // Code ist richtig } else { // Code ist falsch } Ausgaben am LC Display Eine LCD Ausgabe entweder je nach Zustand bei jedem safe_process gemacht werden oder bei einem Zustandswechsel. Im folgenden Beispiel sieht man die Ausgabe des Zustands WRONG_CODE . Bei jedem safe_process wird über hal_lcd_printf die Ausgabe \"WRONG CODE\" gemacht. Das Leerzeichen hinter \"WRONG\" ist beabsichtigt, da zuvor in dieser Zeile \"CLOSED\" steht und dies um einen Buchstaben länger ist als \"WRONG\". Das Leerzeichen überschreibt somit den letzten Buchstaben von \"CLOSED\". Wenn eine Taste gedrückt wurde oder der Timer abgelaufen ist wird das Display mittels hal_lcd_clear gelöscht. void safe_process ( void ) { uint8_t key = hal_key_get (); // handle keys (0 - no key is pressed, 1 to 4 - corresponding key was pressed) switch ( safe_state ) { // ... other cases case WRONG_CODE : hal_lcd_printf ( 0 , 0 , \"WRONG \" ); hal_lcd_printf ( 1 , 0 , \"CODE\" ); if ( key || timer_safe == 0 ) { safe_state = CLOSED ; hal_lcd_clear (); } break ; } Musterlösung Ein Implementierung dieser Übung befindet sich hier zum Download: Musterlösung","tags":"mikrocontroller","title":"Übung Safe"},{"url":"https://www.semiversus.com/dic/mikrocontroller/uebung_tresor.html","text":"Aufgabenstellung Es ist mittels der Megacard und der vorgegebenen Hardwareabstraktion ein Codeschloss zu implementieren. Die Ausgabe erfolgt über das direkt an der Megacard angeschlossene Display Die Eingabe erfolgt über die vier Taster S0 bis S3 Für die Implementierung wird folgende herangehensweise empfohlen: Zeiche den Zustandsdiagramm händisch auf Gib den Zustände Namen, die man als C Code Enumerationen verwenden kann (z.B. STATE_WRONG_INPUT ) Nimm das Beispiel des Weckers als Vorlage Konzentriere dich anfangs auf die reine Eingabe und Überprüfung des Codes. Erweitere dann die Implementierung um die Zustände \"Neuer Code 1\" bis \"Neuer Code 4\". Funktionsweise Direkt nach dem Einschalten soll der Code 1234 sein (entspricht dem Drücken der Tasten S0, S1, S2 und S3). Startzustand Das Display gibt CLOSED aus Ein Drücken der Tasten S0 bis S3 bewirkt die Codeeingabe der ersten Stelle. Nun wird in den nächsten Zustand gewechselt (Codeeingabe 1). Codeeingabe 1 Das Display gibt CLOSED und in der zweiten Zeile * aus Ein Drücken der Tasten S0 bis S3 bewirkt die Codeeingabe der zweiten Stelle. Nun wird in den nächsten Zustand gewechselt (Codeeingabe 2). Codeeingabe 2 Das Display gibt CLOSED und in der zweiten Zeile ** aus Ein Drücken der Tasten S0 bis S3 bewirkt die Codeeingabe der dritten Stelle. Nun wird in den nächsten Zustand gewechselt (Codeeingabe 3). Codeeingabe 3 Das Display gibt CLOSED und in der zweiten Zeile *** aus Ein Drücken der Tasten S0 bis S3 bewirkt die Codeeingabe der vierten Stelle. Der eingegebene Code wird jetzt überprüft und in den Zustand \"Offen\" oder \"Falsche Eingabe\" gewechselt. Falsche Eingabe Das Display gibt WRONG und in der zweiten Zeile CODE aus Nach zwei Sekunden oder bei einem Tastendruck wird in den Startzustand gewechselt Offen Das Display gibt OPEN aus Wird für 3 Sekunden keine Taste gedrückt wechselt das System in den Startzustand Wird eine der Tasten S0 bis S3 gedrückt wird damit die erste Stelle eines neuen Code eingegeben. Das System wechselt in den Zustand \"Neuer Code 1\" Neuer Code 1 Das Display gibt NEW CODE und in der zweiten Zeile die bereits eingegebene Stelle des Codes aus (z.B. 3 ) Wird für 3 Sekunden keine Taste gedrückt, wird kein neuer Code eingestellt und das System wechselt in den Startzustand Wird eine der Tasten S0 bis S3 gedrückt wird damit die zweite Stelle des neuen Code eingegeben. Das System wechselt in den Zustand \"Neuer Code 2\" Neuer Code 2 Das Display gibt NEW CODE und in der zweiten Zeile die bereits eingegebene Stelle des Codes aus (z.B. 30 ) Wird für 3 Sekunden keine Taste gedrückt, wird kein neuer Code eingestellt und das System wechselt in den Startzustand Wird eine der Tasten S0 bis S3 gedrückt wird damit die dritte Stelle des neuen Code eingegeben. Das System wechselt in den Zustand \"Neuer Code 3\" Neuer Code 3 Das Display gibt NEW CODE und in der zweiten Zeile die bereits eingegebene Stelle des Codes aus (z.B. 302 ) Wird für 3 Sekunden keine Taste gedrückt, wird kein neuer Code eingestellt und das System wechselt in den Startzustand Wird eine der Tasten S0 bis S3 gedrückt wird damit die vierte Stelle des neuen Code eingegeben. Das System wechselt in den Zustand \"Neuer Code 4\" Neuer Code 4 Das Display gibt NEW CODE und in der zweiten Zeile die bereits eingegebene Stelle des Codes aus (z.B. 3021 ) Nach zwei Sekunden oder bei einem Tastendruck wird der neue Code übernommen und in den Startzustand gewechselt","tags":"mikrocontroller","title":"Aufgabe Tresor"},{"url":"https://www.semiversus.com/dic/programmierbare_logik/zaehler.html","text":"","tags":"programmierbare_logik","title":"Zähler"},{"url":"https://www.semiversus.com/dic/programmierbare_logik/zustandsmaschine.html","text":"","tags":"programmierbare_logik","title":"Zustandsmaschine"},{"url":"https://www.semiversus.com/blog/nesolution.html","text":"Optimierung von Systemen kann sehr schnell zu einer komplexen Aufgabe werden. Schwierig wird es, wenn Variablen nicht mehr getrennt voneinander optimiert werden können, sondern einander beeinflussen. Die Standardansätze der Optimierung reichen oft nicht aus, wenn das zu optimierende System eine oder mehrere der folgenden Eigenschaften hat: Lokale Minima/Maxima Abhängige Variablen Sehr große Anzahl an Variablen Abbruch zu jedem Zeitpunkt, mit dem bis dorthin besten Ergebnis Evolutionäre Algorithmen finden für solche Systeme Lösungen auf eine effiziente Art und Weise. Der Ablauf entspricht dem Namen nach der Evolutionstheorie und wiederholt sich in folgender Reihenfolge: Reproduktion - bestehende Lösungen bilden die Basis für neue Lösungen Mutation - die einzelnen Lösungen werden zufällig verändert Selektion - die einzelnen Lösungen werden bewertet und die besten ausgewählt Nesolution Das Projekt Nesolution (auf Github) nutzt die Emulation einer Spielkonsole um mittels eines evolutionären Algorithmus Spiele mit einem vorgegebenen Ziel zu spielen. Dazu werden Tastenfolgen als Muster gespeichert und durch den Emulator abgespielt. Während der Emulation wird mit einer Bewertungsfunktion das Ergebnis beurteilt. Beim Start wird mit einem leeren Muster der Tastenfolgen gestartet. Davon werden Kopien gemacht, die jeweils zufällig verändert werden. Jede dieser veränderten Kopien wird nun emuliert und bewertet. Zum Schluss wird die Kopie mit dem besten Ergebnis als Basis für die nächste Iteration genutzt. Das Projekt steht als freie Software unter Github zur Verfügung.","tags":"2017_01_10_nesolution","title":"Künstliche Intelligenz spielt Super Mario"},{"url":"https://www.semiversus.com/blog/spectra_physics.html","text":"Spectra-Physics Standort Rankweil/Vorarlberg (Österreich) hat immer wieder Stellen für Elektronik/Softwareentwicklung offen (hier die offenen Stellen ). Da die Stellenanzeigen meist sehr allgemein gehalten sind, möchte ich die Aufgabengebiete unserer Abteilung beschreiben. Unser Team Unser Team besteht aus Fachleuten mit Spezialisierung in einem oder mehreren Fachbereichen. Im folgenden werden die einzelnen Fachbereiche beschrieben. Selten wird jemand in allen Fachbereichen Erfahrung gesammelt haben. Die unscharfe Abgrenzung der Fachbereiche mag für manche ungewohnt wirken - ich finde, es ist unsere größte Stärke. Die meisten in unserem Team haben dadurch viel Wissen in Fachbereichen aufgebaut, die ihnen anfangs unvertraut waren. Ich bin seit neun Jahren bei Spectra-Physics und bin hauptsächlich mit Firmware bzw. Softwareerstellung für Embedded Systems beschäftigt. Die Aufgabengebiete sind meist sehr fließend zwischen Firmware/Softwareentwicklung, reiner Elektronikentwicklung (Schaltplan/Layout), Entwicklung von Designs für programmierbare Logiken, Inbetriebnahme von Prototypen und Serienüberführung. Elektronik in einem Laser Einfachste Lasersysteme bestehen aus einem Mikrocontroller (typischerweise Atmel AVR) und kommunizieren mittels RS485 und einem proprietären Protokoll mit dem PC. Das proprietäre Protokoll ist seit mehreren Jahren im Einsatz, und es sind viele Tools rund um das Protokoll entstanden, die das Entwicklerleben vereinfachen. Komplexe Lasersysteme bestehen aus einem Linux System auf ARM Basis und mehreren (bis zu 20) Mikrocontroller für die einzelnen Komponenten. Dazu kommt meist ein FPGA für die Steuerung und Kontrolle schneller Signale. Für die Entwicklung der Mikrocontroller steht ein Grundgerüst mit vielen Softwaremodulen zur Verfügung. Programmiersprache ist C, je nach Anwendung auch mal Assembler oder C++. Die Entwicklung ist stark durch Automatisierung des Build Prozesses getrieben. Dazu gehören neben der vollständigen Distributionserstellung in einem Schritt auch Unit Tests. Ein Softwareentwicklungsprozess wurde erarbeitet und hat sich an vielen Stellen etabliert, an anderen Stellen sind noch Anpassungen notwendig. Auf dieser Ebene arbeiten ca. fünf Fachleute zusammen. Es hat sich ein einheitlicher Programmierstil geprägt, der die Einarbeitung in Projekte und den Wissensaustausch erleichtert. Die Applikationslogik bei komplexeren Systemen läuft auf dem bereits genannten Linux Embedded System und wird dort in Python programmiert. Verwendet wird Python 3.5 mit aktuellen Sprachmitteln wie etwa asyncio. Die Applikation baut auf einer eigenen Bibliothek auf, die einen Großteil der Funktionalität abbildet. Ein großer Vorteil von Python ist hier die Unabhängigkeit von Hardware. So ist man unabhängig davon, ob die Applikation schlussendlich auf einem Desktopcomputer oder einem Embedded System entwickelt wird beziehungsweise laufen soll. Profilling hilft, zeitkritische Stellen zu erkennen, um diese dann in C oder Cython zu implementieren. So stellen wir sicher, dass auch komplexe Systeme eine niedrige Prozessorlast sowie eine schnelle Reaktionszeit haben. Herausforderungen Neben der genannten Firmware/Softwareentwicklung ist die Elektronikentwicklung selbst ein großer Teil unseres Arbeitsalltags. Dies beginnt mit Schaltplanentwürfen und geht bis zur Entwicklung von Testständen für serienreife Produkte. Spannend an Lasersystemen finde ich persönlich die Vielfalt an notwendiger Elektronik: Spannungen von einigen Kilovolt, die in Nanosekunden geschalten werden Ströme von bis zu 100 Ampere, deren Welligkeit kleiner 50 Milliampere sein muss, um keine Einbussen bei der Strahlqualität zu haben Laserpulsfolgen von 60 Megahertz und mehr, die entsprechend verarbeitet werden müssen Messung und Regelung von Temperaturen auf 0,01 Grad Celsius genau Vielfältige Sensorik (Photodioden, Umgebungseinflüsse, ...) und Aktorik (Gleichspannungs- und Schrittmotoren, motorisierte Spiegel, ...) 8- und 32-Bit Mikrocontroller, FPGAs und Software für Desktopcomputer Sämtliche Entwicklungen geschehen immer unter Berücksichtigung der Anforderung für medizinische Geräte oder industrielle Anwendungen. Die gesammelten Erfahrungen in diesen Bereichen haben großen Einfluss auf unsere Entwicklungsprozesse und damit unsere tägliche Praxis. Ein weiteres Steckenpferd ist die Entwicklung von Designs für FPGAs. Wenn diskrete Elektronik zu komplex und der schnellste Mikrocontroller zu langsam ist, werden FPGAs verwendet, um unsere Anforderungen an zeitkritische Signalverarbeitung zu erfüllen. Wir programmieren in VHDL und verwenden typischerweise Bausteine von Altera. Insgesamt kann ich für mich sagen, dass ich viele spannende Jahre hier verbracht habe und Tag für Tag Neues lernen kann. Ich bin stolz auf unser Team und auf unsere Produkte. Wer weitere Fragen zur Arbeit bei Spectra Physics hat, kann sich gerne bei mir direkt melden. Sollte die Stelle in Kürze vergeben sein einfach trotzdem eine Initiativbewerbung starten. Wenn beim Lesen des ein oder anderen Absatzes die Finger voller Tatendrang zu kribbeln anfingen, bist du bei uns richtig ;-)","tags":"2016_12_30_spectra_physics","title":"Elektronik- und Softwareentwicklung bei Spectra-Physics"},{"url":"https://www.semiversus.com/blog/microchip_tipsntricks.html","text":"Es gibt diese einfachen Tricks Pins zu sparen, Prozessorresourcen zu optimieren oder einfach Kosten zu sparen. Eine schöne Sammlung dieser Tricks rund um Mikrocontroller hat Microchip zusammengestellt: Compiled Tips 'N Tricks Guide","tags":"2016_11_13_microchip","title":"Microchip Tips'n Tricks"},{"url":"https://www.semiversus.com/blog/linuxtag.html","text":"Am 26. November 2016 ist es wieder soweit: Linuxtag in Vorarlberg! Ich werde dort zwei Vorträge halten: Lightning Talk über Nesolution - Computeralgorithmen spielen Nintendo Vortrag über statische Webseitenerstellung Folgende Infos stammen von der Infoseite unter https://www.linuxday.at : Der LinuxDay in Vorarlberg ist im 4 Ländereck von Deutschland, Schweiz, Liechtenstein und Österreich mit bis zu 500 Besuchern die größte Veranstaltung zu Linux und Freier Software . Er wird von der Linux User Group Vorarlberg in Zusammenarbeit mit der HTL Dornbirn (link is external) organisiert. Der LinuxDay ist bereits eine feste Institution in der Bodensee-Region. Tatsächlich ist es bereits der 18. in Serie und damit wohl eine der dienstältesten Veranstaltungen zu Freier Software, die immer noch regelmäßig stattfindet und gut besucht wird. Geboten wird ein reiches Sortiment an voneinander unabhängigen Vorträgen. In zwei parallelen Vortragsreihen erfahren Anwender, Linuxprofis bzw. Entscheidungsträger aus Wirtschaft und öffentlicher Verwaltung Wissenswertes über Freie und Open Source Software. Zusätzlich werden 2016 erstmalig auch Workshops stattfinden. Während der gesamten Veranstaltung können Besucher ihren zusätzlichen Wissensdurst an zahlreichen Informationsständen international bekannter Projekte und regionaler Dienstleister stillen. Ein Restaurant mit günstigen Preisen lädt zum Fachsimpeln und zum Verweilen ein. Der Eintritt ist frei!","tags":"2016_10_22_linuxtag","title":"Linuxtag in Dornbirn/Vorarlberg"},{"url":"https://www.semiversus.com/blog/algorithm.html","text":"Bei jeder Konferenz das gleiche Bild: Kurz vor dem Start eines Vortrags wird deutlich darauf hingewiesen, dass niemand stehen müsste, wenn alle Plätze in den Reihen gefüllt würden. Teilweise gibt es große Lücken und man fragt sich wieso. Das Problem ist ein menschliches - viele Teilnehmende sind bereits länger hier und fanden einen quasi freien Raum vor und da setzt man sich eben irgendwo hin. So langsam füllt sich der Raum, da aber das eigene Notebook, Getränke und der Snack zwischendurch bereits ausgebreitet wurden ist ein Platzwechsel sehr mühsam. Für Softwarekonferenzen habe ich folgenden Algorithmus zur Platzvergabe entwickelt. Solange alle diesem Algorithmus bei der Platzsuche folgen werden die verfügbare Sitzplätze optimal ausgenutzt. class PythonesqueHuman ( Human ): def find_seat ( self , room ): for row in room . rows : if row [ 0 ] . isSeatFree (): seat_index = 0 elif row [ - 1 ] . isSeatFree (): seat_index = len ( row ) - 1 else : continue self . takeSeat ( row , seat_index ) direction = 1 if seat_index < len ( row ) / 2 else - 1 while row [ seat_index + direction ] . isSeatFree () and seat_index != int ( len ( row ) / 2 ): seat_index += direction self . takeSeat ( row , seat_index ) return raise EnvironmentError ( \"No seat left in this room\" )","tags":"2016_04_03_algorithm","title":"Algorithmus zur Belegung der Sitzplätze"},{"url":"https://www.semiversus.com/blog/paradise_island.html","text":"Die Längen der Außengrenzen von Österreich, Deutschland und der Schweiz sind in einem wesentlichen Teil nicht festgelegt. Dieser wesentliche Teil betrifft die Grenzen rund um bzw. durch den Bodensee. Es ist die einzige Gegend in Europa in der zwischen den Nachbarstaaten keine Grenzen definiert sind. Zu welchen Auswüchse dies führt zeigt dieser Podcast Beitrag über Paradise Island von SWR2 Wissen. Prädikat: Höhrenswert! Generell kann ich den Podcast von SWR2 Wissen sehr empfehlen. Der Beitrag Paradise Island ist aber ein besonderer.","tags":"2016_04_01_paradise_island","title":"Wem gehört Paradise Island?"},{"url":"https://www.semiversus.com/blog/snofru.html","text":"Das Spiel (hier zum Download ) habe ich im Alter von 14 geschrieben und ist eine Sokoban-Variante (siehe Wikipedia ). Ich dachte eigentlich, dass das Spiel verschollen ist, doch Internet sei Dank hab ich es wieder gefunden. Das Spiel ist ziemlich einfach gestrickt. Man steuert eine Spielfigur mittels Pfeiltasten durch ein Labyrinth mit Hindernissen in Form von verschiebbaren Steinen und herumlaufenden Soldaten. Archive.org GameStar 7/1998 (Bild: Maniacfan , Urheberrechtlich geschützt durch GameStar ) Wer Archive.org nicht kennt, sollte es sich unbedingt anschauen. Ein Projekt zum Archivieren des Internets - und das nicht nur einmal, sondern in vielen Kopien zu verschiedenen Zeiten: Hier ist die früheste Version meiner Homepage . Und weil beim Archivieren des Internets wahrscheinlich nicht genug Daten anfallen archivieren sie auch viele frei zugängliche CDs, DVDs usw. Das Spiel wurde damals auf der beiliegenden CD zur GameStar 7/1998 veröffentlicht - und diese CD gibts auch auf Archive.org zum Download. Das Spiel Viele Dinge würde ich heute anders machen: Das Spiel läuft auf nur einer Plattform (Windows) Es wurde in VisualBasic programmiert Es ist nicht frei skalierbar Es ist nicht Open Source sondern Shareware... Der Gameplot entspricht der Damsel in Distress ( Youtube - sehenswert). Die Daten für die einzelnen Levels sind in der Datei Game.dat gespeichert. Jede Zeile entspricht einem Level. Es gab sogar einen Leveleditor, aber nur in der Vollversion für 50 Schilling (inflationsangepasst wären das heute 6-7€). Das Einkommen durch das Spiel hat für den Lebensunterhalt nicht gereicht und so hab ich dann die Schule fertig gemacht...","tags":"2016_03_31_snofru","title":"Der Tempel des Snofru"},{"url":"https://www.semiversus.com/blog/foreigner.html","text":"Dieser Ausschnitt hängt seit einer Ewigkeit auf meiner Pinnwand. Es hat einen seltsamen Reiz diesen Kommentar zu lesen. Ich habe den Namen der schreibenden Person unkenntlich gemacht, das originale Kommentar ist aber nach wie vor online abzurufen.","tags":"2016_03_30_foreigner","title":"Wenn Muttersprache weh tut..."},{"url":"https://www.semiversus.com/blog/reflection_meets_tree.html","text":"Der Baum ist mir früher schonmal aufgefallen und die Verletzung ist recht ungewöhnlich. Ich bin mir nicht sicher, ob nicht eine \"mechanische\" Beschädigung vorangegangen ist, aber das was der Baum mitmacht ist sicher nicht fein. Die Hinterseite eines Verkehrsspiegels ist in diesem Fall refelektierend ausgeführt (dumme Idee!) und wenn die Sonne richtig steht bündeln sich die Sonnenstrahlen auf einem gemeinsamen Punkt - und dort steht dann der Baum. Hier der Baum im Detail: Und hier der Überltäter:","tags":"2016_03_29_reflection_meets_tree","title":"Reflection meets tree"},{"url":"https://www.semiversus.com/blog/logisches_xor.html","text":"In C gibt es vier bitweise Operatoren (Details dazu im Skriptum ): UND Operator - & ODER Operator - | Exklusiv ODER Operator - &#94; INVERTIERUNG - ~ Neben den bitweisen Operatoren gibt es noch die logischen Verknüpfungen, die den bitweisen entsprechen: UND Verknüpfung - && ODER Verknüpfung - || INVERTIERUNG - ! Hier fehlt offensichtlich die Exklusive ODER Verknüpfung - wieso gibt es kein &#94;&#94; ? Eine gute Antwort findet sich auf dieser Seite von Ben Pfaff. Und hier eine kurze Zusammenfassung: Eine logische Exklusiv ODER Verknüpfung ist sehr selten. Die Kurzschlussauswertung wird nicht ermöglicht - Ist bei einer UND Verknüpfung der erste Term falsch muss der zweite nicht mehr überprüft werden. Das gleiche gilt bei ODER mit dem ersten Term wahr. Bei Exklusiv ODER geht dies nicht. Und wenn ich es doch mal benötige? Eine logische Exklusiv ODER Verknüpfung lässt sich wie folgt realisieren: if ( ! a != ! b ) { ... } Mittels logischer Invertierung ! wird der entsprechende Term auf 0 (falsch) oder 1 (wahr) gebracht. Wenn diese logischen Terme unterschiedlich sind ist die Gesamtaussage wahr.","tags":"2016_02_15_logisches_xor","title":"Wieso gibt es kein logisches XOR in C?"},{"url":"https://www.semiversus.com/blog/anniversary.html","text":"Wieso Jubiläen immer nur nach ganzen Jahren feiern? Wieso nicht bei einer Million Sekunden Lebenszeit? Oder bei Tausend Wochen? Dieses Spreadsheet (LibreOffice Calc Sheet) macht es möglich. Einfach das Datum und die Uhrzeit bei \"Geburt\" eintragen, Namen anpassen und ausdrucken. Interessant ist die logarithmische Verteilung: Hat man eine Million Sekunden bereits nach elf einhalb Tagen erlebt, braucht man für 10 Millionen Sekunden bereits fast vier Monate. 100 Millionen Sekunden sind nach knapp 3 Jahren erreicht und bei einer Milliarde Sekunden ist man fast 32 Jahre alt. Das Spreadsheet enthält die Jubiläen für Sekunden, Minuten, Stunden, Tage und Wochen. Es startet bei einer Million Sekunden und endet beim letzten relevanten Jubiläum vor Erreichung der hundert Jahre - 5.000 Wochen (95.6 Jahre).","tags":"2016_02_11_anniversary","title":"Jubiläumsplan"},{"url":"https://www.semiversus.com/blog/radioparadise.html","text":"Die meisten Webradios scheitern an mindestens einem der folgenden Punkte: Kostenlos, gute Qualität, keine Werbung, ... oder gute Musik. Ein Webradio das ich sehr empfehlen kann ist Radio Paradise . Finanziert wird Radio Paradise mittels Unterstützung durch die Hörer.","tags":"2016_02_08_radioparadise","title":"Webstream Radio Paradise"},{"url":"https://www.semiversus.com/blog/korrelation.html","text":"Abschreiben als solches zu erkennen ist keine einfache Sache, da der Aufwand massiv mit der Anzahl der zu vergleichenden Arbeiten steigt. Bei 5 Arbeiten sind insgesamt 10 Vergleiche zu machen: Die erste Aufgabe wird mit den vier anderen verglichen, dann die zweite Arbeit mit den drei verbleibenden, usw. Mit wdiff habe ich ein Tool gefunden, um einfache Textvergleiche machen zu können. Die Anzahl der Vergleiche ergibt sich dabei mittels den Binomialkoeffizienten zu: %%N_{Vergleiche}={N_{Arbeiten} \\choose 2}=\\frac{N_{Arbeiten}!}{(N_{Arbeiten}-2)!\\cdot 2!}%% Anzahl der Arbeiten Anzahl der Vergleiche 5 10 10 45 15 105 20 190 25 300 30 435 In der Informatik spricht man auch von einer Laufzeitkomplexität von %%\\mathcal O(n&#94;2)%%, sprich mit doppelter Anzahl an Arbeiten steigt die Anzahl der Vergleiche um (etwas mehr als) das Vierfache. Nutzen von Tools Bei einer Hausaufgabe habe ich nun das konkrete \" Problem \" 25 Arbeiten miteinander zu vergleichen. Es handelt sich um eine Programmieraufgabe in C. Der Vergleich von zwei Textdateien lässt sich mittels diff bewerkstelligen. Was ich aber brauche ist eine Statistik, die mir angibt, wie groß die Korrelation zwischen zwei Dateien ist, sprich wie groß der Anteil an Gemeinsamkeiten ist. Bei dem Vergleich sollten Zeilenumbrüche, Leerzeichen, usw. keine Rolle spielen. Das Tool der Wahl ist wdiff . Die Option -s liefert eine entsprechende Statistik. $> wdiff -s arbeit1.c arbeit2.c ... arbeit1.c: 126 Wörter 48 38 % gleich 13 10 % gelöscht 65 52 % verändert arbeit2.c: 140 Wörter 48 34 % gleich 7 5 % eingefügt 85 61 % verändert Der Vergleich von arbeit1.c mit arbeit2.c liefert ein anderes Ergebnis als der umgekehrte Vergleich und hängt vorallem mit der unterschiedlichen Anzahl an Gesamtworten zusammen. Zum Vergleich von 25 Arbeiten müssen nun 300 dieser Aufrufe gemacht werden. Dazu dient folgendes bash -Skript: files = ` ls *.c ` for work1 in $files ; do for work2 in $files ; do if [ $work1 == $work2 ] ; then continue fi echo -n $work1 $work2 wdiff -s $work1 $work2 | tail -n 1 | cut -d: -f2 done done Das Skript nutzt zwei Schleifen, um jede Datei mit jeder zu vergleichen. Bei der Ausgabe von wdiff werden nicht benötigte Teile weggeschnitten. Auswertung Die Ausführung führt dann zu folgendem Ergebnis (ein Ausschnitt): ... arbeit20.c arbeit13.c 209 Wörter 47 22 % gleich 12 6 % eingefügt 150 72 % verändert arbeit20.c arbeit14.c 116 Wörter 113 97 % gleich 0 0 % eingefügt 3 3 % verändert arbeit20.c arbeit15.c 315 Wörter 54 17 % gleich 11 3 % eingefügt 250 79 % verändert arbeit20.c arbeit16.c 209 Wörter 39 19 % gleich 0 0 % eingefügt 170 81 % verändert arbeit20.c arbeit17.c 290 Wörter 54 19 % gleich 13 4 % eingefügt 223 77 % verändert ... Es fällt der zweite Eintrag auf: 97% Übereinstimmung. Da muss sehr viel Zufall im Spiel sein, oder auch nicht. Ein direkter Vergleich mittels Meld zeigt: Die Liste nach Korrelation sortiert zeigt folgendes Ergebnis: Es zeigen sich zwei \" Cluster \": arbeit14.c und arbeit20.c unterscheiden sich durch genau drei \"Wörter\", arbeit6.c , arbeit15.c und arbeit17.c unterscheiden sich auch nur durch ein paar \"Wörter\". Zusammenfassung wdiff ist ein mächtiges Tool für Textvergleiche. Man sollte wahrscheinlich nicht zu pedantisch werden, um als Lehrer Kopien zu entdecken. Ich wünsche und fordere eine Zusammenarbeit und Wissensaustausch bei Schülern - eine reine Kopie kann ich aber nicht unterstützen.","tags":"2016_01_31_korrelation","title":"Interessante Korrelation entdecken mittels wdiff"}]}