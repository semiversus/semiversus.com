<!DOCTYPE html><html lang=de> <head><title>Tastenentprellung</title><link rel=icon href=https://www.semiversus.com/favicon.ico><meta charset=utf-8><meta name=description content="Allgemeines Die bekannteste Form von Schaltern und Tastern arbeitet elektromechanisch, indem zwei Kontakte je nach Zustand entweder verbunden oder getrennt sind. Man spricht auch von den Zuständen geschlossen und offen. Im mechanischen Aufbau des Tasters wird oft eine Feder benutzt, um die Kontakte zu trennen. Im ungedrückten Zustand ..."><meta name=author content="Günther Jena"><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=google-site-verification content=O-3LVEziPiVrCYqFCwbLmB3s7lNG__cPMLLAr_RUxbA><meta name=msvalidate.01 content=70DFF0E672B42811AA384CC455C9406C><link rel=stylesheet href=https://www.semiversus.com/theme/css/semiversus.min.css?f7108c59><script async src=https://www.semiversus.com/theme/js/semiversus.min.js?c02fe949></script></head> <body data-spy=scroll data-target=#sidebar data-offset=30> <div id=wrap> <nav class="navbar navbar-inverse"> <div class=container> <div class=navbar-header> <button type=button class="navbar-toggle collapsed" data-toggle=collapse data-target=.navbar-collapse> <span class=icon-bar></span><span class=icon-bar></span><span class=icon-bar></span> </button> <a href=https://www.semiversus.com/index.html class=navbar-brand>SEMIVERSUS</a> </div> <div class="navbar-collapse collapse"> <ul class="nav navbar-nav"> <li><a href=https://www.semiversus.com/index.html>Blog</a></li> <li><a href=https://www.semiversus.com/dic/uebersicht.html>Unterricht</a></li> <li><a href=https://www.semiversus.com/projekte/projekte.html>Projekte</a></li> <li><a href=https://www.semiversus.com/about.html>Über mich</a></li> </ul> <form class="navbar-form navbar-right" role=search action=https://www.semiversus.com/search.html onsubmit="return validateForm(this.elements['q'].value);"> <input type=text class=form-control placeholder=Suche name=q id=tipue_search_input></form> <ul class="nav navbar-nav navbar-right socialicons"> <li><a href=https://www.linkedin.com/in/guenther-jena data-toggle=tooltip data-placement=bottom title=LinkedIn.com/Günther-Jena><span class="linkedin icon hidden-xs"></span><span class="hidden-sm hidden-md hidden-lg">Linkedin</span></a></li> <li><a href=https://www.xing.com/profile/Guenther_Jena2 data-toggle=tooltip data-placement=bottom title=Xing.com/Günther-Jena><span class="xing icon hidden-xs"></span><span class="hidden-sm hidden-md hidden-lg">Xing</span></a></li> <li><a href=https://stackoverflow.com/users/166605/g%C3%BCnther-jena data-toggle=tooltip data-placement=bottom title=Stackoverflow.com/Semiversus><span class="stackoverflow icon hidden-xs"></span><span class="hidden-sm hidden-md hidden-lg">Stack Overflow</span></a></li> <li><a href=https://github.com/semiversus data-toggle=tooltip data-placement=bottom title=Github.com/Semiversus><span class="github icon hidden-xs"></span><span class="hidden-sm hidden-md hidden-lg">Github</span></a></li> <li><a href=https://www.semiversus.com/semiversus.atom.xml class=rss data-toggle=tooltip data-placement=bottom title="RSS Feed"><span class="rss icon hidden-xs"></span><span class="hidden-sm hidden-md hidden-lg">RSS Feed</span></a></li> </ul> </div> </div> </nav> <div class=container> <div class=visible-print-block>Semiversus | Tastenentprellung</div> <ol class="breadcrumb hidden-print"><li><a href=https://www.semiversus.com/dic/uebersicht.html>Unterrichtsmaterial</a></li><li><a href=https://www.semiversus.com/dic/hardwarenahe_programmierung/uebersicht.html>Hardwarenahe Programmierung</a></li><li><strong>Tastenentprellung</strong></li></ol> <div class=row> <div class=col-md-8 role=main> <header><h1>Tastenentprellung<div class="pull-right hidden-print"><a href=https://www.semiversus.com/dic/hardwarenahe_programmierung/tastenentprellung.md class="btn btn-default btn-xs" data-toggle=tooltip data-placement=bottom title="Quelltext zu dieser Seite">Quelltext</a></div></h1></header> <h2 id=allgemeines>Allgemeines</h2> <p>Die bekannteste Form von Schaltern und Tastern arbeitet elektromechanisch, indem zwei Kontakte je nach Zustand entweder verbunden oder getrennt sind. Man spricht auch von den Zust&auml;nden <em>geschlossen</em> und <em>offen</em>.</p> <p>Im mechanischen Aufbau des Tasters wird oft eine Feder benutzt, um die Kontakte zu trennen. Im <em>ungedr&uuml;ckten</em> Zustand ist dieser Taster <em>offen</em>. Diese Konfiguration bezeichnet man als <em>Normally open</em> (kurz <em>NO</em>) Taster. Im gegensatz dazu sind bei Tastern in der Konfiguration <em>Normally closed</em> (<em>NO</em>)die Kontakte per Feder <em>geschlossen</em> und erst durch mechanische Bet&auml;tigung werden die Kontakte getrennt.</p> <p>Bedingt durch den Aufbau und der Feder wechselt bei einer Bet&auml;tigung der Zustand nicht unmittelbar von <em>offen</em> zu <em>geschlossen</em> (und umgekehrt) sonder es kommt zu einer mechanischen Schwingung, die diese Kontakte mehrfach aufeinander prellen l&auml;sst. Daher die Bezeichnung <em>Tastenprellen</em> oder genauer <em>Kontaktprellen</em>.</p> <p>Im folgenden Oszibild sieht man ein solches Prellen, welches in diesem Fall beim Loslassen der Taste aufgenommen wurde (0V entspricht <em>geschlossen</em>, 5V entspricht <em>offen</em>):</p> <p><img alt=Tastenprellen src=https://www.semiversus.com/dic/hardwarenahe_programmierung/tastenprellen.png></p> <p>Im Bild sieht man das Prellen &uuml;ber eine Zeitdauer von ca. 1.5ms . Dies ist ein typischer Wert, kann aber je nach Bauart auch stark variieren.</p> <p>Das Problem beim Tastenprellen ist die Auswertung der Taste selbst. Zur Auswertung ob eine Taste gedr&uuml;ckt wurde wird nach einer Flanke gesucht, sprich ein Zustandswechsel von <em>offen</em> zu <em>geschlossen</em> (oder umgekehrt). Je nach Implementierung dieser Detektion kann durch das Prellen ein Tasterdruck mehrfach detektiert werden. Dies kann zu Problemen in der Anwendung kommen.</p> <h2 id=entprellen>Entprellen</h2> <p>Es gibt verschiedene M&ouml;glichkeiten, einen Taster zu entprellen. Unterschieden wird zwischen Hardware- und Softwarel&ouml;sungen.</p> <p>M&ouml;gliche Hardwarel&ouml;sungen stehen zur Verf&uuml;gung: <em> Nicht prellende Taster verwenden (meist relativ aufwendig und dadurch teuer) </em> Tiefpassfilterung und Schmitttrigger * Spezielle Entprellschaltungen oder ICs</p> <p>Man kann auf Hardwarel&ouml;sungen aber auch ganz verzichten, wenn die Entprellung in der Software durchgef&uuml;hrt wird.</p> <p>Es gibt viele verschiedene L&ouml;sungen dies in Software zu realisieren. Hier werden drei M&ouml;glichkeiten gezeigt.</p> <h3 id=entprellen-mittels-warten>Entprellen mittels Warten</h3> <p>Die einfachste Art das Prellen abzufangen ist nach der ersten Detektion einer Flanke einfach eine bestimmte Zeit zu warten. Diese Zeit richtet sich nach der Dauer des Prellens der Taste.</p> <p>Im folgenden Beispiel wird die Funktion <code>process_key</code> in der Main Loop aufgerufen. Die Durchlaufszeit einer Iteration der Main Loop sollte dabei k&uuml;rzer als einige Millisekunden sein, damit auch kurze Tastendr&uuml;cke detektiert werden k&ouml;nnen.</p> <div class=codehilite><pre><span></span><span class=kt>uint8_t</span> <span class=nf>process_key</span><span class=p>(</span><span class=kt>uint8_t</span> <span class=n>key_state</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>static</span> <span class=kt>uint8_t</span> <span class=n>old_key_state</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=c1>// old_key_state speichert den Zustand der vorhergehenden Iteration</span>
  <span class=kt>uint8_t</span> <span class=n>result</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>               <span class=c1>// Initialisere den R&uuml;ckgabewert mit 0</span>

  <span class=k>if</span> <span class=p>(</span><span class=n>key_state</span><span class=o>!=</span><span class=n>old_key_state</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// &Uuml;berpr&uuml;fe Zustands&auml;nderung</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>key_state</span><span class=o>==</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>           <span class=c1>// Wenn der neue Zustand "geschlossen" ist</span>
      <span class=n>result</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span>                   <span class=c1>// gib 1 als Wert zur&uuml;ck</span>
    <span class=p>}</span>
    <span class=n>_delay_ms</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>                 <span class=c1>// Werte 5 Millisekunden (blockierend!)</span>
  <span class=p>}</span>

  <span class=n>old_key_state</span><span class=o>=</span><span class=n>key_state</span><span class=p>;</span>        <span class=c1>// speichere den aktuellen Zustand f&uuml;r die n&auml;chste Iteration</span>

  <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
<span class=p>}</span>
</pre></div> <p>Diese Implementierung hat ein gro&szlig;es Problem: Die Wartezeit von 5 Millisekunden, die den Prozessor f&uuml;r diese Zeit blockiert.</p> <p>Das Prinzip lie&szlig;e sich &uuml;bertragen auf eine Implementierung mit einem Timerinterrupt, der jede Millisekunde den Taster auf eine Zustands&auml;nderung &uuml;berpr&uuml;ft und die Wartezeit mit mehreren Interruptaufrufen umsetzt.</p> <h3 id=vorfilterung>Vorfilterung</h3> <p>Wenn das Prellen selbst in der Software weggefiltert wird f&auml;llt die Detektierung der Flanke leichter und es entf&auml;llt damit auch das Warten wie im vorherigen Beispiel.</p> <p>Eine Vorfilterung l&auml;sst sich implementieren, indem man einen softwareinternen Zustand des Tasters realisiert, der erst nach einer bestimmten Anzahl an Zust&auml;nden der gleichen Art umgestellt wird.</p> <div class=codehilite><pre><span></span><span class=cp>#define MIN_ITERATION_COUNT 20</span>

<span class=kt>uint8_t</span> <span class=nf>process_key</span><span class=p>(</span><span class=kt>uint8_t</span> <span class=n>key_state</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>static</span> <span class=kt>uint8_t</span> <span class=n>internal_key_state</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=c1>// softwareinterner Zustand</span>
  <span class=k>static</span> <span class=kt>uint8_t</span> <span class=n>count</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>              <span class=c1>// Anzahl an Zust&auml;nden gleicher Art</span>

  <span class=k>if</span> <span class=p>(</span><span class=n>key_state</span><span class=o>!=</span><span class=n>internal_key_state</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// Wenn sich der interne Zustand vom externen unterscheidet</span>
    <span class=n>count</span><span class=o>++</span><span class=p>;</span>                           <span class=c1>// Erh&ouml;he den Z&auml;hler um eins</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>count</span><span class=o>==</span><span class=n>MIN_ITERATION_COUNT</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// bis die Mindestanzahl erreicht wurde</span>
      <span class=n>internal_key_state</span><span class=o>=</span><span class=n>key_state</span><span class=p>;</span>    <span class=c1>// Stelle den internen Zustand um</span>
      <span class=k>return</span> <span class=n>key_state</span><span class=p>;</span>                <span class=c1>// Gib 1 zur&uuml;ck, wenn der neue Zustand 1 ist (ansonsten 0)</span>
    <span class=p>}</span>
  <span class=p>}</span>
  <span class=k>else</span> <span class=p>{</span>
    <span class=n>count</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>                           <span class=c1>// Wenn interner gleich externer Zustand ist setze Z&auml;hler auf 0</span>
  <span class=p>}</span>

  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>                            <span class=c1>// Gib 0 f&uuml;r alle anderen F&auml;lle zur&uuml;ck</span>
<span class=p>}</span>
</pre></div> <h3 id=nachbildung-eines-analogen-tiefpasses>Nachbildung eines analogen Tiefpasses</h3> <p>Das was ein analoger Tiefpass bei der hardwarem&auml;&szlig;igen Entprellung macht kann auch durch Software nachgebildet werden.</p> <p>Dazu wird der Zustand des Tasters gemittelt. Wird ein bestimmter Schwellwert &uuml;berschritten so wird der entsprechende Zustand softwareintern gesetzt. Bei der Unterschreitung eines niedrigeren Schwellwertes wird der Zustand wieder zur&uuml;ckgesetzt.</p> </div> <div class=col-md-4 role=complementary> <nav class="well well-sm" data-spy=affix data-offset-top=0 id=sidebar> <ul class=nav><li><a href=#allgemeines>Allgemeines</a></li><li><a href=#entprellen>Entprellen</a><ul class=nav><li><a href=#entprellen-mittels-warten>Entprellen mittels Warten</a></li><li><a href=#vorfilterung>Vorfilterung</a></li><li><a href=#nachbildung-eines-analogen-tiefpasses>Nachbildung eines analogen Tiefpasses</a></li></ul></li></ul> </nav> </div> </div> </div> </div> <footer class="footer hidden-print"><div class=container><p class="text-muted credit">Günther Jena 2011 - 2020 | Letztes Update am 20.9.2020 (Rev. <a href=https://github.com/semiversus/semiversus.github.io-source/commit/ffdbb85>ffdbb85</a>) <a href=https://plus.google.com/111972313670421914746/about rel=author class=hidden>Google+</a><a href=https://creativecommons.org/licenses/by-sa/3.0/de/ class=pull-right><img src=https://www.semiversus.com/theme/img/cc_by_sa.svg alt="Licence CC-BY-SA"></a></p></div></footer> <script type=text/javascript>
        var s = document.createElement('script');
        s.type = 'text/javascript';
        s.src = 'https:' == document.location.protocol ? 'https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML' : 'http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; 
        s[(window.opera ? "innerHTML" : "text")] =
            "MathJax.Hub.Config({" + 
            "    config: ['MMLorHTML.js']," + 
            "    jax: ['input/TeX','input/MathML','output/HTML-CSS','output/NativeMML']," +
            "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," + 
            "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
            "    tex2jax: { " +
            "        inlineMath: [ ['%%','%%'] ], " +
            "        processEscapes: false }, " +
            "    'HTML-CSS': { " +
            "        styles: { '.MathJax .mo, .MathJax .mi': {color: 'black ! important'}} " +
            "    } " +
            "}); ";
        (document.body || document.getElementsByTagName('head')[0]).appendChild(s);
    </script> </body> </html>