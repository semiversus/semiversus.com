<!DOCTYPE html><html lang=de> <head><title>VHDL Signaltypen</title><link rel=icon href=https://www.semiversus.com/favicon.ico><meta charset=utf-8><meta name=description content="Allgemeines Um eine digitale Schaltung beschreiben zu können benötigt man Leitungen, um einzelne Komponenten miteinander zu verbinden. Leitungen entsprechen bei VHDL sogennanten Signalen (Schlüsselwort signal). Um in VHDL ein Signal zu definiere muss das Signal einen bestimmten Signaltyp haben. Der einfachste Signaltyp ist bit. Dieser Signaltyp kennt ..."><meta name=author content="Günther Jena"><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=google-site-verification content=O-3LVEziPiVrCYqFCwbLmB3s7lNG__cPMLLAr_RUxbA><meta name=msvalidate.01 content=70DFF0E672B42811AA384CC455C9406C><link rel=stylesheet href=https://www.semiversus.com/theme/css/semiversus.min.css?f7108c59><script async src=https://www.semiversus.com/theme/js/semiversus.min.js?c02fe949></script></head> <body data-spy=scroll data-target=#sidebar data-offset=30> <div id=wrap> <nav class="navbar navbar-inverse"> <div class=container> <div class=navbar-header> <button type=button class="navbar-toggle collapsed" data-toggle=collapse data-target=.navbar-collapse> <span class=icon-bar></span><span class=icon-bar></span><span class=icon-bar></span> </button> <a href=https://www.semiversus.com/index.html class=navbar-brand>SEMIVERSUS</a> </div> <div class="navbar-collapse collapse"> <ul class="nav navbar-nav"> <li><a href=https://www.semiversus.com/index.html>Blog</a></li> <li><a href=https://www.semiversus.com/dic/uebersicht.html>Unterricht</a></li> <li><a href=https://www.semiversus.com/projekte/projekte.html>Projekte</a></li> <li><a href=https://www.semiversus.com/about.html>Über mich</a></li> </ul> <form class="navbar-form navbar-right" role=search action=https://www.semiversus.com/search.html onsubmit="return validateForm(this.elements['q'].value);"> <input type=text class=form-control placeholder=Suche name=q id=tipue_search_input></form> <ul class="nav navbar-nav navbar-right socialicons"> <li><a href=https://www.linkedin.com/in/guenther-jena data-toggle=tooltip data-placement=bottom title=LinkedIn.com/Günther-Jena><span class="linkedin icon hidden-xs"></span><span class="hidden-sm hidden-md hidden-lg">Linkedin</span></a></li> <li><a href=https://www.xing.com/profile/Guenther_Jena2 data-toggle=tooltip data-placement=bottom title=Xing.com/Günther-Jena><span class="xing icon hidden-xs"></span><span class="hidden-sm hidden-md hidden-lg">Xing</span></a></li> <li><a href=https://stackoverflow.com/users/166605/g%C3%BCnther-jena data-toggle=tooltip data-placement=bottom title=Stackoverflow.com/Semiversus><span class="stackoverflow icon hidden-xs"></span><span class="hidden-sm hidden-md hidden-lg">Stack Overflow</span></a></li> <li><a href=https://github.com/semiversus data-toggle=tooltip data-placement=bottom title=Github.com/Semiversus><span class="github icon hidden-xs"></span><span class="hidden-sm hidden-md hidden-lg">Github</span></a></li> <li><a href=https://www.semiversus.com/semiversus.atom.xml class=rss data-toggle=tooltip data-placement=bottom title="RSS Feed"><span class="rss icon hidden-xs"></span><span class="hidden-sm hidden-md hidden-lg">RSS Feed</span></a></li> </ul> </div> </div> </nav> <div class=container> <div class=visible-print-block>Semiversus | VHDL Signaltypen</div> <ol class="breadcrumb hidden-print"><li><a href=https://www.semiversus.com/dic/uebersicht.html>Unterrichtsmaterial</a></li><li><a href=https://www.semiversus.com/dic/programmierbare_logik/uebersicht.html>Programmierbare Logik</a></li><li><strong>VHDL Signaltypen</strong></li></ol><nav class=hidden-print><ul class=pager> <li class=previous><a href=https://www.semiversus.com/dic/programmierbare_logik/grundlagen.html>&larr; VHDL Grundbegriffe</a></li><li class=next><a href=https://www.semiversus.com/dic/programmierbare_logik/operatoren.html>VHDL Operatoren &rarr;</a></li></ul></nav> <div class=row> <div class=col-md-8 role=main> <header><h1>VHDL Signaltypen<div class="pull-right hidden-print"><a href=https://www.semiversus.com/dic/programmierbare_logik/signaltypen.md class="btn btn-default btn-xs" data-toggle=tooltip data-placement=bottom title="Quelltext zu dieser Seite">Quelltext</a></div></h1></header> <h2 id=allgemeines>Allgemeines</h2> <p>Um eine digitale Schaltung beschreiben zu k&ouml;nnen ben&ouml;tigt man Leitungen, um einzelne Komponenten miteinander zu verbinden. <em>Leitungen</em> entsprechen bei VHDL sogennanten Signalen (Schl&uuml;sselwort <code>signal</code>). Um in VHDL ein Signal zu definiere muss das Signal einen bestimmten Signaltyp haben.</p> <p>Der einfachste Signaltyp ist <code>bit</code>. Dieser Signaltyp kennt die beiden Werte <code>0</code> und <code>1</code>. Dies mag f&uuml;r digitale Schaltungen auf den ersten Blick ausreichend erscheinen, es gibt aber einige Situationen, in denen diese beiden Werte nicht ausreichen.</p> <p>Signale werden wie folgt definiert:</p> <div class=codehilite><pre><span></span><span class=k>signal</span> <span class=o>&lt;</span><span class=n>name</span><span class=o>&gt;</span> <span class=o>:</span> <span class=o>&lt;</span><span class=n>typ</span><span class=o>&gt;</span><span class=p>;</span> <span class=c1>-- Signal &lt;name&gt; ist vom Typ &lt;typ&gt; und wird nicht initialisert</span>
<span class=k>signal</span> <span class=o>&lt;</span><span class=n>name</span><span class=o>&gt;</span> <span class=o>:</span> <span class=o>&lt;</span><span class=n>typ</span><span class=o>&gt;</span> <span class=o>:=</span> <span class=o>&lt;</span><span class=n>default</span><span class=o>&gt;</span><span class=p>;</span> <span class=c1>-- Signal &lt;name&gt; ist vom Typ &lt;typ&gt; und wird mit &lt;default&gt; initialisiert</span>
</pre></div> <h2 id=standard-logic-1164>Standard Logic 1164</h2> <p>Die der Bibliothek <em>Standard Logic 1164</em> werden Signaltypen definiert, die mehr als <code>0</code> und <code>1</code> darstellen k&ouml;nnen. Um diese Bibliothek in einer VHDL Datei zu verwenden sind folgende zwei Zeilen notwendig:</p> <div class=codehilite><pre><span></span><span class=k>library</span> <span class=nn>ieee</span> <span class=p>;</span>
<span class=k>use</span> <span class=nn>ieee.std_logic_1164.</span><span class=k>all</span><span class=p>;</span>
</pre></div> <p>Diese Typen haben 9 Werte (d.h. werden sie auch <em>9-wertige Logik</em> genannt)</p> <ul> <li><code>U</code>: <em>undefiniert</em> - wird f&uuml;r nichtinitalisierte Signale in der Simulation verwendet</li> <li><code>X</code>: <em>unbekannt</em> (starker Treiber) - wenn zwei Ausg&auml;nge miteinander verbunden werden, die gegeneinander treiben (<code>0</code> und <code>1</code>)</li> <li><code>0</code>: <em>logische Null</em> (starker Treiber)</li> <li><code>1</code>: <em>logische Eins</em> (starker Treiber)</li> <li><code>Z</code>: <em>hochohmig</em></li> <li><code>W</code>: <em>unbekannt</em> (schwacher Treiber)</li> <li><code>L</code>: <em>logische Null</em> (schwacher Treiber)</li> <li><code>H</code>: <em>logische Eins</em> (schwacher Treiber)</li> <li><code>-</code>: <em>unwichtig</em> (vgl. <em>don't care</em> in KV-Diagrammen)</li> </ul> <p>Werden mehrere Ausg&auml;nge zusammengeschalten setzen sich starke Treiber gegen&uuml;ber schwachen durch. Ein <code>U</code> setzt sich gegen&uuml;ber aller anderen Werten durch. Die Funktion, die die Aufl&ouml;sung beschreibt nennt sich <code>resolution</code>-Funktion.</p> <div class="panel panel-warning"> <div class=panel-heading><em>Resolved</em> Signale</div> <div class=panel-body> <p>Innerhalb eines FPGAs gibt es nie die Notwendigkeit mehrer Ausg&auml;nge <strong>direkt</strong> miteinander zu verbinden. Man hat immer die M&ouml;glichkeit, dies &uuml;ber eine Kombinatorik zu tun.</p> </div> </div> <h3 id=std_logic-und-std_ulogic><code>std_logic</code> und <code>std_ulogic</code></h3> <p>Der Signaltyp <code>std_logic</code> wird in der Bibliothek <em>Standard Logic 1164</em> definiert und nutzt die oben gezeigte 9-wertige Logik. Der Signaltype <code>std_logic</code> ist <em>resolved</em>, d.h. es ist m&ouml;glich mehrere Ausg&auml;nge direkt miteinander zu verbinden. Dies kann eine Fehlersuche erschweren, wenn versehentlich ein Signal von zwei Treibern angesteuert wird. Je nach Synthese- Tool wird kein Fehler angezeigt.</p> <p>Um nun zu verhindern, dass versehentlich zwei Treiber ein Signal ansteuern gibt es den Signaltyp <code>std_ulogic</code>. Das <em>U</em> steht dabei f&uuml;r <em>unresolved</em> - es wird also bei mehreren Treibern nicht aufgel&ouml;st. Das Synthese-Tool gibt also auf alle F&auml;lle einen Fehler aus.</p> <p>Was spricht f&uuml;r <code>std_logic</code>?</p> <ul> <li>Viele bestehende Beispiele und L&ouml;sungen verwenden <code>std_logic</code></li> <li>Generierte VHDL Beschreibungen enthalten oft <code>std_logic</code></li> </ul> <p>Was spricht f&uuml;r <code>std_ulogic</code>?</p> <ul> <li>Es ist nicht versehentlich m&ouml;glich, mit mehreren Treibern ein Signal anzusteuern</li> <li>Simulationen sind (manchmal) schneller, da es die <em>Resolution</em>-Funktion nicht ben&ouml;tigt</li> </ul> <p>Eine Umwandlung von <code>std_logic</code> zu <code>std_ulogic</code> und umgekehrt ist jederzeit m&ouml;glich.</p> <div class="panel panel-info"> <div class=panel-heading>In diesem Skriptum wird <code>std_ulogic</code> verwendet</div> <div class=panel-body> <p>Alle gezeigten Beispiele mit <code>std_ulogic</code> lassen sich auch mittels <code>std_logic</code> realisieren.</p> </div> </div> <h3 id=definition-eines-signals-mit-std_ulogic>Definition eines Signals mit <code>std_ulogic</code></h3> <div class=codehilite><pre><span></span><span class=k>signal</span> <span class=n>led_reg</span> <span class=o>:</span> <span class=kt>std_ulogic</span> <span class=o>:=</span> <span class=sc>'0'</span><span class=p>;</span> <span class=c1>-- Hier wird das Signal led_reg als std_ulogic definiert und mit '0' initialisiert</span>
</pre></div> <h2 id=busse-mittels-std_ulogic_vector_1>Busse mittels <code>std_ulogic_vector</code></h2> <p>In vielen Anwendungen werden mehrere Signale zu einem <em>Bus</em> zusammengefasst. Dazu wird der Signaltyp <code>std_ulogic_vector</code> verwendet.</p> <p>Um einen Bus <code>data_reg</code> mit 8 Signalen zu definieren und diesen mit den Bits <code>"00000001"</code> zu initialisieren wird folgende Definition genutzt:</p> <div class=codehilite><pre><span></span><span class=k>signal</span> <span class=n>data_reg</span> <span class=o>:</span> <span class=kt>std_ulogic_vector</span><span class=p>(</span><span class=mi>7</span> <span class=k>downto</span> <span class=mi>0</span><span class=p>)</span> <span class=o>:=</span> <span class=s>"00000001"</span><span class=p>;</span>
</pre></div> <h3 id=downto-und-to><code>downto</code> und <code>to</code></h3> <p>Im obigen Beispiel wurde <code>downto</code> genutzt um innerhalb des Vektors die einzelnen Indizies zu definieren. Wir k&ouml;nnen auf ein einzelnes Signal im Bus mittels <code>data_reg(0)</code> zugreifen. Dies wurde laut obiger Definition <code>'1'</code> zur&uuml;ckliefern und entspricht somit (wie erwartet) dem niederwertigsten Bit.</p> <p>W&uuml;rde <code>data_reg</code> wie folgt definiert sein:</p> <div class=codehilite><pre><span></span><span class=k>signal</span> <span class=n>data_reg</span> <span class=o>:</span> <span class=kt>std_ulogic_vector</span><span class=p>(</span><span class=mi>0</span> <span class=k>to</span> <span class=mi>7</span><span class=p>)</span> <span class=o>:=</span> <span class=s>"00000001"</span><span class=p>;</span>
</pre></div> <p>w&uuml;rden wir bei <code>data_reg(0)</code> den Wert <code>'0'</code> zur&uuml;ckbekommen, da der Index 0 nun dem &auml;u&szlig;erst linken Bit entspricht.</p> <div class="panel panel-info"> <div class=panel-heading>Verwende <code>downto</code></div> <div class=panel-body> <p>Da bei den meisten Darstellungen das h&ouml;chstwertigste Bit links und das niederwertigste Bit rechts steht bietet sich <code>downto</code> an. Prinzipiell spricht nichts gegen eine Verwendung von <code>to</code> solange man wei&szlig;, was man tut!</p> </div> </div> <h3 id=literale>Literale</h3> <p>Wir haben im obigen Beispiel die Initialisierung mit dem Bitstring <code>"00000001"</code> gesehen. Solche Werte werden <em>Literale</em> ( engl. <em>literals</em>) genannt. In diesem Beispiel wird jedes einzelne Bit aufgeschl&uuml;sselt. Das gleiche Ergebnis erzielt man mittels <code>x"01"</code> f&uuml;r die Darstellung mittels hexadezimaler Zahl.</p> <p>Eine andere M&ouml;glichkeit bietet die Darstellung mittels Mapping:</p> <div class=codehilite><pre><span></span><span class=k>signal</span> <span class=n>data_reg</span> <span class=o>:</span> <span class=kt>std_ulogic_vector</span><span class=p>(</span><span class=mi>7</span> <span class=k>downto</span> <span class=mi>0</span><span class=p>)</span> <span class=o>:=</span> <span class=p>(</span><span class=mi>0</span> <span class=o>=&gt;</span> <span class=sc>'1'</span><span class=p>,</span> <span class=k>others</span><span class=o>=&gt;</span><span class=sc>'0'</span><span class=p>);</span>
</pre></div> <p>Diese Definition setzt den Index 0 auf <code>'1'</code> und alle anderen Bits auf <code>'0'</code>.</p> <h3 id=verknupfen-von-bussen>Verkn&uuml;pfen von Bussen</h3> <p>Busse lassen sich beliebig zusammenf&uuml;hren und aufteilen. Im folgenden Beispiel wird der 8 Bit Bus <code>data_in_reg</code> in zwei Teilbusse <code>low_nibble</code> und <code>high_nibble</code> mit jeweils 4 Bit aufgeteilt. Der 8 Bit Bus <code>data_out_reg</code> besteht aus den einzelnen 4 Bit Bussen, die in umgekehrter Reihenfolge wieder zusammengesetzt werden.</p> <div class=codehilite><pre><span></span><span class=k>signal</span> <span class=n>data_in_reg</span> <span class=o>:</span> <span class=kt>std_ulogic_vector</span><span class=p>(</span><span class=mi>7</span> <span class=k>downto</span> <span class=mi>0</span><span class=p>);</span>
<span class=k>signal</span> <span class=n>low_nibble</span> <span class=o>:</span> <span class=kt>std_ulogic_vector</span><span class=p>(</span><span class=mi>3</span> <span class=k>downto</span> <span class=mi>0</span><span class=p>);</span>
<span class=k>signal</span> <span class=n>high_nibble</span> <span class=o>:</span> <span class=kt>std_ulogic_vector</span><span class=p>(</span><span class=mi>3</span> <span class=k>downto</span> <span class=mi>0</span><span class=p>);</span>
<span class=k>signal</span> <span class=n>data_out_reg</span> <span class=o>:</span> <span class=kt>std_ulogic_vector</span><span class=p>(</span><span class=mi>7</span> <span class=n>dowto</span> <span class=mi>0</span><span class=p>);</span>

<span class=n>low_nibble</span> <span class=o>&lt;=</span> <span class=n>data_in_reg</span><span class=p>(</span><span class=mi>3</span> <span class=k>downto</span> <span class=mi>0</span><span class=p>);</span>
<span class=n>high_nibble</span> <span class=o>&lt;=</span> <span class=n>data_in_reg</span><span class=p>(</span><span class=mi>7</span> <span class=k>downto</span> <span class=mi>4</span><span class=p>);</span>
<span class=n>data_out_reg</span> <span class=o>&lt;=</span> <span class=n>low_nibble</span> <span class=o>&amp;</span> <span class=n>high_nibble</span><span class=p>;</span>
</pre></div> <p>Das gleiche w&uuml;rde sich auch wie folgt realisieren lassen:</p> <div class=codehilite><pre><span></span><span class=n>data_out_reg</span> <span class=o>&lt;=</span> <span class=n>data_in_reg</span><span class=p>(</span><span class=mi>3</span> <span class=k>downto</span> <span class=mi>0</span><span class=p>)</span> <span class=o>&amp;</span> <span class=n>data_in_reg</span><span class=p>(</span><span class=mi>7</span> <span class=k>downto</span> <span class=mi>4</span><span class=p>);</span>
</pre></div> <h2 id=numerische-signaltypen-unsigned-und-signed_1>Numerische Signaltypen <code>unsigned</code> und <code>signed</code></h2> <p>Der Signaltyp <code>std_ulogic_vector</code> ist eine einfache Ansammlung einzelner <code>std_ulogic</code> Signale. Damit zu rechnen ist nicht unmittelbar m&ouml;glich. F&uuml;r diese Anwendungsf&auml;lle gibt es die Bibliothek <code>numeric_std</code> mit den Signaltypen <code>unsigned</code> und <code>signed</code>.</p> <div class=codehilite><pre><span></span><span class=k>library</span> <span class=nn>ieee</span> <span class=p>;</span>
<span class=k>use</span> <span class=nn>ieee.numeric_std.</span><span class=k>all</span><span class=p>;</span>
</pre></div> <p>Die Definition selbst entspricht der Definition von Bussen mittels <code>std_ulogic_vector</code>:</p> <div class=codehilite><pre><span></span><span class=k>signal</span> <span class=n>counter_reg</span> <span class=o>:</span> <span class=kt>unsigned</span><span class=p>(</span><span class=mi>7</span> <span class=k>downto</span> <span class=mi>0</span><span class=p>);</span>
</pre></div> <p>Damit werden nun Addition und Subtraktion mit anderen <code>unsigned</code> bzw. <code>signed</code> Typen sowie <em>Integern</em> m&ouml;glich:</p> <div class=codehilite><pre><span></span><span class=n>counter_reg</span> <span class=o>&lt;=</span> <span class=n>counter_reg</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</pre></div> <h2 id=ganzzahlen-mittels-integer>Ganzzahlen mittels <code>integer</code></h2> <p>In vielen Anwendungen werden arithmetische Operationen mit Signalen durchgef&uuml;hrt. Oft ist es aber nicht notwendig, auf die einzelnen Bits zuzugreifen. F&uuml;r solche Zwecke gibt folgende Ganzzahl Signaltypen:</p> <ul> <li><code>integer</code>: Ganzzahl, je nach Synthesetool meist als 32 Bit vorzeichbehaftete Zahl representiert</li> <li><code>natural</code>: Subtype von <code>integer</code> die positive Zahlen inklusive <code>0</code> enth&auml;lt.</li> <li><code>positive</code>: Subtype von <code>integer</code> die ausschlie&szlig;lich positive Zahlen enth&auml;lt (ohne <code>0</code>).</li> </ul> <h3 id=eingrenzung-mittels-range>Eingrenzung mittels <code>range</code></h3> <p>F&uuml;r Signale kann der Wertebereich der Ganzzahltypen weiter eingeschr&auml;nkt werden. F&uuml;r einen Z&auml;hler im Dezimalsystem bietet sich eventuell folgende Definition an:</p> <div class=codehilite><pre><span></span><span class=k>signal</span> <span class=n>dec_counter_reg</span> <span class=o>:</span> <span class=kt>integer</span> <span class=k>range</span> <span class=mi>0</span> <span class=k>to</span> <span class=mi>9</span><span class=p>;</span>
</pre></div> <div class="panel panel-warning"> <div class=panel-heading>&Uuml;berlauf bei <code>integer</code></div> <div class=panel-body> <p>Wenn wie im obigen Beispiel der Bereich auf 0 bis 9 eingeschr&auml;nkt ist, bedeutet dies nicht, dass bei einem &Uuml;berlauf (9+1) das Ergebnis auf 0 &uuml;berl&auml;uft. Es ist ein Hinweis f&uuml;r Simulation und Synthese, die im Falle eine Warnung ausgeben k&ouml;nnen, der &Uuml;berlauf selbst muss aber durch eine eigene Beschreibung abgefangen werden.</p> </div> </div> <h2 id=konvertierung-und-casting_1>Konvertierung und Casting</h2> <p>Wird ein Signaltyp mit dem Wert eines anderen Signaltyps angesteuert ben&ouml;tigt man eine Konvertierung bzw. einen <em>Cast</em>.</p> <p>Die Typen <code>std_ulogic_vector</code>, <code>unsigned</code> und <code>signed</code> sind Vektoren. Hier reicht es aus den Typ zu <em>casten</em>. Bei einer Umwandlung von einem <code>integer</code> zu einem Vektor ben&ouml;tigt man die Information, wieviele Bits notwendig sind.</p> <p>F&uuml;r die folgenden Beispiele gehen wir von folgender Definition aus:</p> <div class=codehilite><pre><span></span><span class=k>signal</span> <span class=n>sul_vector</span> <span class=o>:</span> <span class=kt>std_ulogic_vector</span><span class=p>(</span><span class=mi>7</span> <span class=k>downto</span> <span class=mi>0</span><span class=p>);</span>
<span class=k>signal</span> <span class=n>u_vector</span> <span class=o>:</span> <span class=kt>unsigned</span><span class=p>(</span><span class=mi>7</span> <span class=k>downto</span> <span class=mi>0</span><span class=p>);</span>
<span class=k>signal</span> <span class=n>s_vector</span> <span class=o>:</span> <span class=kt>signed</span><span class=p>(</span><span class=mi>7</span> <span class=k>downto</span> <span class=mi>0</span><span class=p>);</span>
<span class=k>signal</span> <span class=n>int</span> <span class=o>:</span> <span class=kt>integer</span> <span class=k>range</span> <span class=mi>0</span> <span class=k>to</span> <span class=mi>255</span><span class=p>;</span>
</pre></div> <h3 id=std_ulogic_vector><code>std_ulogic_vector</code></h3> <div class=codehilite><pre><span></span><span class=n>u_vector</span> <span class=o>&lt;=</span> <span class=kt>unsigned</span><span class=p>(</span><span class=n>sul_vector</span><span class=p>);</span>
<span class=n>s_vector</span> <span class=o>&lt;=</span> <span class=kt>signed</span><span class=p>(</span><span class=n>sul_vector</span><span class=p>);</span>
<span class=n>int</span> <span class=o>&lt;=</span> <span class=n>to_integer</span><span class=p>(</span><span class=kt>unsigned</span><span class=p>(</span><span class=n>sul_vector</span><span class=p>));</span>
</pre></div> <p>Die Umwandlung eines <code>std_ulogic_vector</code> in <code>unsigned</code> und <code>signed</code> geht einfach, da es sich nur die Interpretation der Bits &auml;ndert.</p> <p>Bei der Umwandlung in einen <code>integer</code> gibt es das Problem, dass <code>std_ulogic_vector</code> nur eine Ansammlung von Bits ist, ohne eine Wertigkeit vorzugeben. Die Umwandlung zu <code>integer</code> geschieht &uuml;ber einen Cast zu <code>unsigned</code> bzw. <code>signed</code> und dann die Konvertierung in einen <code>integer</code>.</p> <h3 id=unsigned-und-signed><code>unsigned</code> und <code>signed</code></h3> <div class=codehilite><pre><span></span><span class=c1>-- Umwandlung von unsigned</span>
<span class=n>sul_vector</span> <span class=o>&lt;=</span> <span class=kt>std_ulogic_vector</span><span class=p>(</span><span class=n>u_vector</span><span class=p>);</span>
<span class=n>int</span> <span class=o>&lt;=</span> <span class=n>to_integer</span><span class=p>(</span><span class=n>u_vector</span><span class=p>);</span>

<span class=c1>-- Umwandlung von signed</span>
<span class=n>sul_vector</span> <span class=o>&lt;=</span> <span class=kt>std_ulogic_vector</span><span class=p>(</span><span class=n>s_vector</span><span class=p>);</span>
<span class=n>int</span> <span class=o>&lt;=</span> <span class=n>to_integer</span><span class=p>(</span><span class=n>s_vector</span><span class=p>);</span>
</pre></div> <p>Die Umwandlung funktioniert hier &auml;nhlich zu <code>std_ulogic_vector</code>.</p> <h3 id=integer><code>integer</code></h3> <div class=codehilite><pre><span></span><span class=n>u_vector</span> <span class=o>&lt;=</span> <span class=n>to_unsigned</span><span class=p>(</span><span class=n>int</span><span class=p>,</span> <span class=mi>8</span><span class=p>);</span>
<span class=n>s_vector</span> <span class=o>&lt;=</span> <span class=n>to_signed</span><span class=p>(</span><span class=n>int</span><span class=p>,</span> <span class=mi>8</span><span class=p>);</span>
<span class=n>sul_vector</span> <span class=o>&lt;=</span> <span class=kt>std_ulogic_vector</span><span class=p>(</span><span class=n>to_unsigned</span><span class=p>(</span><span class=n>int</span><span class=p>,</span> <span class=mi>8</span><span class=p>));</span>
</pre></div> <p>Bei der Konvertierung eines <code>integer</code>s in einen Vektor sind entsprechende Konvertierungsfunktionen zu nutzen. Der Weg von <code>integer</code> zu <code>std_ulogic_vector</code> kann dabei je nach Anwendung &uuml;ber <code>to_unsigned</code> und <code>to_signed</code> f&uuml;hren.</p> </div> <div class=col-md-4 role=complementary> <nav class="well well-sm" data-spy=affix data-offset-top=0 id=sidebar> <ul class=nav><li><a href=#allgemeines>Allgemeines</a></li><li><a href=#standard-logic-1164>Standard Logic 1164</a><ul class=nav><li><a href=#std_logic-und-std_ulogic>std_logic und std_ulogic</a></li><li><a href=#definition-eines-signals-mit-std_ulogic>Definition eines Signals mit std_ulogic</a></li></ul></li><li><a href=#busse-mittels-std_ulogic_vector_1>Busse mittels std_ulogic_vector</a><ul class=nav><li><a href=#downto-und-to>downto und to</a></li><li><a href=#literale>Literale</a></li><li><a href=#verknupfen-von-bussen>Verkn&uuml;pfen von Bussen</a></li></ul></li><li><a href=#numerische-signaltypen-unsigned-und-signed_1>Numerische Signaltypen unsigned und signed</a></li><li><a href=#ganzzahlen-mittels-integer>Ganzzahlen mittels integer</a><ul class=nav><li><a href=#eingrenzung-mittels-range>Eingrenzung mittels range</a></li></ul></li><li><a href=#konvertierung-und-casting_1>Konvertierung und Casting</a><ul class=nav><li><a href=#std_ulogic_vector>std_ulogic_vector</a></li><li><a href=#unsigned-und-signed>unsigned und signed</a></li><li><a href=#integer>integer</a></li></ul></li></ul> </nav> </div> </div> </div> </div> <footer class="footer hidden-print"><div class=container><p class="text-muted credit">Günther Jena 2011 - 2020 | Letztes Update am 20.9.2020 (Rev. <a href=https://github.com/semiversus/semiversus.github.io-source/commit/ffdbb85>ffdbb85</a>) <a href=https://plus.google.com/111972313670421914746/about rel=author class=hidden>Google+</a><a href=https://creativecommons.org/licenses/by-sa/3.0/de/ class=pull-right><img src=https://www.semiversus.com/theme/img/cc_by_sa.svg alt="Licence CC-BY-SA"></a></p></div></footer> <script type=text/javascript>
        var s = document.createElement('script');
        s.type = 'text/javascript';
        s.src = 'https:' == document.location.protocol ? 'https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML' : 'http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; 
        s[(window.opera ? "innerHTML" : "text")] =
            "MathJax.Hub.Config({" + 
            "    config: ['MMLorHTML.js']," + 
            "    jax: ['input/TeX','input/MathML','output/HTML-CSS','output/NativeMML']," +
            "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," + 
            "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
            "    tex2jax: { " +
            "        inlineMath: [ ['%%','%%'] ], " +
            "        processEscapes: false }, " +
            "    'HTML-CSS': { " +
            "        styles: { '.MathJax .mo, .MathJax .mi': {color: 'black ! important'}} " +
            "    } " +
            "}); ";
        (document.body || document.getElementsByTagName('head')[0]).appendChild(s);
    </script> </body> </html>