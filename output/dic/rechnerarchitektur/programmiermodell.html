<!DOCTYPE html><html lang=de> <head><title>Programmiermodell</title><link rel=icon href=https://www.semiversus.com/favicon.ico><meta charset=utf-8><meta name=description content="Allgemeines Das Programmiermodell (engl. Instruction Set Architecture oder kurz ISA) beschreibt den Aufbau eines Prozessors als abstraktes Modell. Dazu gehört: Beschreibung der Befehle, die der Prozessor ausführen kann Codierung der Befehle Adressierungsarten Aufbau der Register Zeitverhalten (Anzahl der benötigten Taktzyklen) Befehlssatz Die Gesamtheit aller Befehle eines Prozessors ..."><meta name=author content="Günther Jena"><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=google-site-verification content=O-3LVEziPiVrCYqFCwbLmB3s7lNG__cPMLLAr_RUxbA><meta name=msvalidate.01 content=70DFF0E672B42811AA384CC455C9406C><link rel=stylesheet href=https://www.semiversus.com/theme/css/semiversus.min.css?f7108c59><script async src=https://www.semiversus.com/theme/js/semiversus.min.js?c02fe949></script></head> <body data-spy=scroll data-target=#sidebar data-offset=30> <div id=wrap> <nav class="navbar navbar-inverse"> <div class=container> <div class=navbar-header> <button type=button class="navbar-toggle collapsed" data-toggle=collapse data-target=.navbar-collapse> <span class=icon-bar></span><span class=icon-bar></span><span class=icon-bar></span> </button> <a href=https://www.semiversus.com/index.html class=navbar-brand>SEMIVERSUS</a> </div> <div class="navbar-collapse collapse"> <ul class="nav navbar-nav"> <li><a href=https://www.semiversus.com/index.html>Blog</a></li> <li><a href=https://www.semiversus.com/dic/uebersicht.html>Unterricht</a></li> <li><a href=https://www.semiversus.com/projekte/projekte.html>Projekte</a></li> <li><a href=https://www.semiversus.com/about.html>Über mich</a></li> </ul> <form class="navbar-form navbar-right" role=search action=https://www.semiversus.com/search.html onsubmit="return validateForm(this.elements['q'].value);"> <input type=text class=form-control placeholder=Suche name=q id=tipue_search_input></form> <ul class="nav navbar-nav navbar-right socialicons"> <li><a href=https://www.linkedin.com/in/guenther-jena data-toggle=tooltip data-placement=bottom title=LinkedIn.com/Günther-Jena><span class="linkedin icon hidden-xs"></span><span class="hidden-sm hidden-md hidden-lg">Linkedin</span></a></li> <li><a href=https://www.xing.com/profile/Guenther_Jena2 data-toggle=tooltip data-placement=bottom title=Xing.com/Günther-Jena><span class="xing icon hidden-xs"></span><span class="hidden-sm hidden-md hidden-lg">Xing</span></a></li> <li><a href=https://stackoverflow.com/users/166605/g%C3%BCnther-jena data-toggle=tooltip data-placement=bottom title=Stackoverflow.com/Semiversus><span class="stackoverflow icon hidden-xs"></span><span class="hidden-sm hidden-md hidden-lg">Stack Overflow</span></a></li> <li><a href=https://github.com/semiversus data-toggle=tooltip data-placement=bottom title=Github.com/Semiversus><span class="github icon hidden-xs"></span><span class="hidden-sm hidden-md hidden-lg">Github</span></a></li> <li><a href=https://www.semiversus.com/semiversus.atom.xml class=rss data-toggle=tooltip data-placement=bottom title="RSS Feed"><span class="rss icon hidden-xs"></span><span class="hidden-sm hidden-md hidden-lg">RSS Feed</span></a></li> </ul> </div> </div> </nav> <div class=container> <div class=visible-print-block>Semiversus | Programmiermodell</div> <ol class="breadcrumb hidden-print"><li><a href=https://www.semiversus.com/dic/uebersicht.html>Unterrichtsmaterial</a></li><li><a href=https://www.semiversus.com/dic/rechnerarchitektur/uebersicht.html>Rechnerarchitektur</a></li><li><strong>Programmiermodell</strong></li></ol> <div class=row> <div class=col-md-8 role=main> <header><h1>Programmiermodell<div class="pull-right hidden-print"><a href=https://www.semiversus.com/dic/rechnerarchitektur/programmiermodell.md class="btn btn-default btn-xs" data-toggle=tooltip data-placement=bottom title="Quelltext zu dieser Seite">Quelltext</a></div></h1></header> <h2 id=allgemeines>Allgemeines</h2> <p>Das <em>Programmiermodell</em> (engl. <em>Instruction Set Architecture</em> oder kurz <em>ISA</em>) beschreibt den Aufbau eines Prozessors als abstraktes Modell. Dazu geh&ouml;rt:</p> <ul> <li>Beschreibung der Befehle, die der Prozessor ausf&uuml;hren kann</li> <li>Codierung der Befehle</li> <li>Adressierungsarten</li> <li>Aufbau der Register</li> <li>Zeitverhalten (Anzahl der ben&ouml;tigten Taktzyklen)</li> </ul> <h2 id=befehlssatz>Befehlssatz</h2> <p>Die Gesamtheit aller Befehle eines Prozessors wird auch Befehlssatz genannt. Je nach Umfang des Befehlssatzes wird zwischen der <em>CISC</em> und <em>RISC</em> Designphilosophie unterschieden. Bei der <em>Complex Instruction Set Computer</em> Philosophie gibt es Befehle, die sehr komplexe Operationen ausf&uuml;hren k&ouml;nnen. Diese ben&ouml;tigen aber meist mehrere Taktzyklen. Viele klassische Prozessorarchitekturen (zum Beispiel Intel x86, Zilog Z80 und Motorola 68k) gelten als typische Vertreter von Prozessorarchitekturen mit <em>CISC</em>-Befehlss&auml;tzen.</p> <p>Der Begriff <em>CISC</em> wurde nachtr&auml;glich eingef&uuml;hrt, um die bis damals vorherrschende Befehlss&auml;tze von neuartigen Design zu unterscheiden, die als <em>RISC</em> (<em>Reduced Instruction Set Computer</em>) Befehlss&auml;tze bezeichnet wurden. Bei <em>RISC</em> Befehlss&auml;tzen wird auf komplexe Befehle verzichtet, dadurch wird ein einfacheres Chipdesign erm&ouml;glicht.</p> <h3 id=cisc>CISC</h3> <ul> <li>ben&ouml;tigt im Vergleich weniger Programmspeicher, da die einzelnen Befehle komplexer sind und dadurch "mehr" ausf&uuml;hren k&ouml;nnen</li> <li>Meist ben&ouml;tigt ein Befehl mehrere Takte</li> </ul> <p>Die Realisierung eines CISC Prozessors wird oft mittels <em>Mikrocode</em> realisiert. Zur Ausf&uuml;hrung eines Befehl f&uuml;hrt das Steuerwerk den entsprechenden Mikrocode aus. Dieser Mikrocode steuert den Datenpfad des Prozessors an. Dadurch k&ouml;nnen komplexe Befehle realisiert werden.</p> <h3 id=risc>RISC</h3> <p>F&uuml;r die meisten Prozessoren mit <em>RISC</em>-Befehlssatz gilt:</p> <ul> <li>Load-Store Befehle: Speicherzugriffe erfolgen (nur) durch Load bzw. Store Befehle. Dies vereinfacht den Datenpfad</li> <li>Befehlsausf&uuml;hrung meist in einem Taktzyklus</li> <li>Sehr viele frei verwendbare Register</li> <li>Befehle haben meist eine feste L&auml;nge</li> <li>Steuerwerk ist festverdrahtet (vgl. CISC mit Mikrocode)</li> <li>unabh&auml;ngige Verarbeitungseinheiten erm&ouml;glichen Pipelining</li> </ul> <h2 id=befehle_1>Befehle</h2> <h3 id=transferbefehle>Transferbefehle</h3> <p>Transferbefehle werden verwendet, um Information innerhalb eines Prozessors oder &uuml;ber den Speicher zu transferieren. Da die Daten an ihrem Quellort nicht ver&auml;ndert werden ist der Vorgang eigentlich eine Kopie. Je nach Prozessorarchitektur k&ouml;nnen dies ein- oder mehrere Bytes auf einmal sein.</p> <p>Eine Sondergruppe bilden Befehle, die mit dem Stack arbeiten. Es k&ouml;nnen Daten auf den Stack kopiert (<code>push</code>) oder vom Stack geholt (<code>pop</code>) werden.</p> <h3 id=arithmetische-und-logische-befehle>Arithmetische und logische Befehle</h3> <p>Bei diesem Befehlen wird eine arithmetische Operation (Addition, Subtraktion, Multiplikation, usw.) oder eine logische Operation (UND-, ODER-Verkn&uuml;pfung, usw.). Auch Schiebe- und Rotationsoperationen geh&ouml;ren hier dazu. Die Operationen selbst werden im Prozessor mittels einer <em>Arithmetisch-Logischen Einheit</em> (engl. <em>arithmetic logic unit</em> oder kurz <em>ALU</em>) durchgef&uuml;hrt.</p> <h3 id=sprungbefehle>Sprungbefehle</h3> <p>Sprungbefehle dienen zum &Auml;ndern des Programmablaufes. Dabei wird zwischen unbedingten und bedingten Spr&uuml;ngen unterschieden. Unbedingte Spr&uuml;nge werden immer ausgef&uuml;hrt, bedingte Spr&uuml;nge sind abh&auml;ngig von einem Prozessorstatus. Bei Spr&uuml;ngen wird dar&uuml;ber hinaus zwischen absoluten Spr&uuml;ngen (referenziert auf die Befehlsspeicheradresse 0) oder relativen Spr&uuml;ngen (relativ zum aktuellen Befehlsz&auml;hler) unterschieden. Bei allen Nicht-Sprung Befehlen wird der Programmablauf mit dem nachfolgenden Befehl fortgesetzt.</p> <h3 id=sonstige-befehle>Sonstige Befehle</h3> <p>Es gibt noch weitere Befehle, die in keine der aufgef&uuml;hrten Kategorien passen. Dazu z&auml;hlen Befehle zum Umgang mit Interrupts, aktivierung bestimmter Betriebsarten (z.B. Sleep Modes) oder der h&auml;ufig vorhandene <code>No Operation</code> Befehl, der w&auml;hrend seiner Ausf&uuml;hrung keine &Auml;nderung vornimmt und somit nur Zeit "verbraucht".</p> <h2 id=adressierungsarten_1>Adressierungsarten</h2> <p>Die Adressierungsarten beschreiben die M&ouml;glichkeiten, wie ein Prozessor auf die Daten f&uuml;r eine Operation zugreift. Dies gilt f&uuml;r die Operanden sowie f&uuml;r das Ergebnis einer Operation.</p> <h3 id=unmittelbare-adressierung>Unmittelbare Adressierung</h3> <p>Der ben&ouml;tigte Wert ist unmittelbar im Befehl selbst kodiert. Bei den meisten Prozessorarchitekturen gibt es Befehle, die ein Register mit einem unmittelbaren Wert laden. Auch absolute Spr&uuml;nge sind meist durch einen Befehl mit unmittelbarer Adressierung realisiert.</p> <h3 id=registeradressierung>Registeradressierung</h3> <p>Bei der Registeradressierung wird das gew&uuml;nschte Register angegeben.</p> <h3 id=absolute-adressierung>Absolute Adressierung</h3> <p>Bei der absoluten Adressierung wird eine Adresse im Speicher &uuml;bergeben. Geladen wird der Wert an dieser Adresse.</p> <h3 id=relative-adressierung>Relative Adressierung</h3> <p>Die Relative Adressierung bezieht sich auf den Befehlsz&auml;hler und wird f&uuml;r einen relativen Sprung verwendet. Dabei wird ein Wert zum Befehlsz&auml;hler addiert bzw. subtrahiert.</p> <h3 id=indirekte-adressierung>Indirekte Adressierung</h3> <p>Bei der indirekten Adressierung wird ein Register adressiert, welches eine Adresse auf den Speicher darstellt. Geladen wird der Wert an dieser Adresse.</p> <p>Bei der indirekten Adressierung gibt es die Erweiterung, dass die Adresse, die im Register gespeichert ist entweder vor (Pr&auml;- ) oder nach (Post- ) der Ausf&uuml;hrung des Befehls modifiziert wird. Meistens handelt es sich bei der Modifikation um eine Addition oder Subtraktion um 1 (Inkrement bzw. Dekrement).</p> <h3 id=indizierte-adressierung>Indizierte Adressierung</h3> <p>Bei der indizierten Adressierung kommen zwei Adressen zum Einsatz. Es wird &auml;hnlich zur indirekten Adressierung ein Register adressiert, welches eine Adresse auf den Speicher darstellt. Zu dieser Adresse wird dann ein unmittelbar kodierter Offset addiert.</p> <h3 id=andere-adressierungsarten>Andere Adressierungsarten</h3> <p>Es gibt ja nach Prozessormodell noch weitere Adressierungsarten. Es ist genauso m&ouml;glich, dass ein Prozessor eine der oben angef&uuml;hrten Adressierungsarten nicht unterst&uuml;tzt.</p> <p>F&uuml;r Signalprozessoren steht meist eine Modulo-Adressierung zur Verf&uuml;gung. Dies entspricht einer Indirekten Adressierung mit einer Modifizierung der Adresse im Register, wobei f&uuml;r die Berechnung der neuen Adresse eine Modulo-Operation durchgef&uuml;hrt wird. Dadurch lassen sich effiziente Ringspeicher erzeugen.</p> <h2 id=anzahl-der-operanden_1>Anzahl der Operanden</h2> <p>Befehlss&auml;tze k&ouml;nnen je nach Anzahl der Operanden, die ein Befehl nutzt, in Kategorien eingeteilt werden.</p> <h3 id=drei-adress-architektur>Drei-Adress Architektur</h3> <p>Bei dieser Architektur kann ein Befehl bis zu drei Adressen nutzen. Dabei werden zwei Adressen f&uuml;r die Operanden und die dritte Adresse f&uuml;r das Ergebnis genutzt.</p> <p>Beispiel (MIPS Architektur):</p> <div class=codehilite><pre><span></span><span class=err>addi $t1, $t0, 1 # $t1=$t0+1</span>
</pre></div> <h3 id=zwei-adress-architektur>Zwei-Adress Architektur</h3> <p>Bei dieser Architektur stehen zwei Adressen pro Befehl zur Verf&uuml;gung, wobei f&uuml;r viele Operationen eine Adresse f&uuml;r den Operand und gleichzeitig f&uuml;r das Ergebnis genutzt wird.</p> <p>Beispiel (AVR Architektur):</p> <div class=codehilite><pre><span></span><span class=err>add r24, r25 ; r24=r24+r25</span>
</pre></div> <h3 id=ein-adress-architektur>Ein-Adress Architektur</h3> <p>Bei dieser Architektur spricht man auch vom <em>Akkumulator</em>-Rechner, da s&auml;mtliche Rechenoperationen nur &uuml;ber das <em>Akkumulator</em>-Register laufen.</p> <p>Beispiel (68HC11 Architektur)</p> <div class=codehilite><pre><span></span><span class=err>adda $48 ; Addiere den Wert an der Speicherstelle 0x48 zum Akkumulator</span>
</pre></div> <h3 id=0-adress-architektur>0-Adress Architektur</h3> <p>Die 0-Adress Architektur ist ein Spezialfall, bei der ein Befehl keine Operanden adressieren kann. Eine Realisierungsvariante ist ein Stack-Prozessor, der selbst keine Register besitzt, sondern alle Operationen am Stack ausf&uuml;hrt. Um Werte auf den Stack zu bekommen ist allerdings die unmittelbare Adressierung notwendig.</p> <p>Beispiel (picoJava-II Architektur)</p> <div class=codehilite><pre><span></span><span class=err>iadd ; Hole zwei Integer vom Stack, addiere diese und lege diese wieder ab</span>
</pre></div> <p>Typische Stack Maschinen haben Befehle wie <code>push</code> und <code>pop</code> um Daten auf den Stack zu legen oder vom Stack zu entfernen. Rechenoperationen wie <code>add</code>, <code>mult</code>, <code>sub</code>, usw. holen zwei Werte vom Stack, f&uuml;hren mit diesen die Rechenoperation aus und legen das Ergebnis wieder am Stack ab.</p> <p>Die Rechenoperation 4+5*(3+6) kann dabei folgenderweise realisiert werden:</p> <div class=codehilite><pre><span></span><span class=err>push 4</span>
<span class=err>push 5</span>
<span class=err>push 3</span>
<span class=err>push 6</span>
<span class=err>add ; addiert 3 und 6 und legt das Ergebnis 9 wieder am Stack ab</span>
<span class=err>mult ; multipliziert 5 und 9 und legt das Ergebnis 45 wieder am Stack ab</span>
<span class=err>add ; addiert 45 und 4 und legt das Ergebnis 49 wieder am Stack ab</span>
</pre></div> <p>Nach der Ausf&uuml;hrung liegt nur mehr ein Wert am Stack und dies ist das Ergebnis.</p> </div> <div class=col-md-4 role=complementary> <nav class="well well-sm" data-spy=affix data-offset-top=0 id=sidebar> <ul class=nav><li><a href=#allgemeines>Allgemeines</a></li><li><a href=#befehlssatz>Befehlssatz</a><ul class=nav><li><a href=#cisc>CISC</a></li><li><a href=#risc>RISC</a></li></ul></li><li><a href=#befehle_1>Befehle</a><ul class=nav><li><a href=#transferbefehle>Transferbefehle</a></li><li><a href=#arithmetische-und-logische-befehle>Arithmetische und logische Befehle</a></li><li><a href=#sprungbefehle>Sprungbefehle</a></li><li><a href=#sonstige-befehle>Sonstige Befehle</a></li></ul></li><li><a href=#adressierungsarten_1>Adressierungsarten</a><ul class=nav><li><a href=#unmittelbare-adressierung>Unmittelbare Adressierung</a></li><li><a href=#registeradressierung>Registeradressierung</a></li><li><a href=#absolute-adressierung>Absolute Adressierung</a></li><li><a href=#relative-adressierung>Relative Adressierung</a></li><li><a href=#indirekte-adressierung>Indirekte Adressierung</a></li><li><a href=#indizierte-adressierung>Indizierte Adressierung</a></li><li><a href=#andere-adressierungsarten>Andere Adressierungsarten</a></li></ul></li><li><a href=#anzahl-der-operanden_1>Anzahl der Operanden</a><ul class=nav><li><a href=#drei-adress-architektur>Drei-Adress Architektur</a></li><li><a href=#zwei-adress-architektur>Zwei-Adress Architektur</a></li><li><a href=#ein-adress-architektur>Ein-Adress Architektur</a></li><li><a href=#0-adress-architektur>0-Adress Architektur</a></li></ul></li></ul> </nav> </div> </div> </div> </div> <footer class="footer hidden-print"><div class=container><p class="text-muted credit">Günther Jena 2011 - 2020 | Letztes Update am 20.9.2020 (Rev. <a href=https://github.com/semiversus/semiversus.github.io-source/commit/ffdbb85>ffdbb85</a>) <a href=https://plus.google.com/111972313670421914746/about rel=author class=hidden>Google+</a><a href=https://creativecommons.org/licenses/by-sa/3.0/de/ class=pull-right><img src=https://www.semiversus.com/theme/img/cc_by_sa.svg alt="Licence CC-BY-SA"></a></p></div></footer> <script type=text/javascript>
        var s = document.createElement('script');
        s.type = 'text/javascript';
        s.src = 'https:' == document.location.protocol ? 'https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML' : 'http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; 
        s[(window.opera ? "innerHTML" : "text")] =
            "MathJax.Hub.Config({" + 
            "    config: ['MMLorHTML.js']," + 
            "    jax: ['input/TeX','input/MathML','output/HTML-CSS','output/NativeMML']," +
            "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," + 
            "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
            "    tex2jax: { " +
            "        inlineMath: [ ['%%','%%'] ], " +
            "        processEscapes: false }, " +
            "    'HTML-CSS': { " +
            "        styles: { '.MathJax .mo, .MathJax .mi': {color: 'black ! important'}} " +
            "    } " +
            "}); ";
        (document.body || document.getElementsByTagName('head')[0]).appendChild(s);
    </script> </body> </html>