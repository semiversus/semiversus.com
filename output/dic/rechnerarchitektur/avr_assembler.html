<!DOCTYPE html><html lang=de> <head><title>AVR Assembler</title><link rel=icon href=https://www.semiversus.com/favicon.ico><meta charset=utf-8><meta name=description content="Übungsblatt Zu diesem Teil gibt es Übungsaufgaben Allgemeines Der Befehlssatz des Atmel AVR ist ein typischer RISC-Befehlssatz. Bei der Entwicklung der AVR Reihe stand vor allem eine möglichst effiziente Nutzung durch C-Compiler im Vordergrund. Komplette Übersicht über den Befehlssatz von Atmel Auszug der wichtigsten Befehle Blockschaltbild Blockschaltbild des ..."><meta name=author content="Günther Jena"><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=google-site-verification content=O-3LVEziPiVrCYqFCwbLmB3s7lNG__cPMLLAr_RUxbA><meta name=msvalidate.01 content=70DFF0E672B42811AA384CC455C9406C><link rel=stylesheet href=https://www.semiversus.com/theme/css/semiversus.min.css?f7108c59><script async src=https://www.semiversus.com/theme/js/semiversus.min.js?c02fe949></script></head> <body data-spy=scroll data-target=#sidebar data-offset=30> <div id=wrap> <nav class="navbar navbar-inverse"> <div class=container> <div class=navbar-header> <button type=button class="navbar-toggle collapsed" data-toggle=collapse data-target=.navbar-collapse> <span class=icon-bar></span><span class=icon-bar></span><span class=icon-bar></span> </button> <a href=https://www.semiversus.com/index.html class=navbar-brand>SEMIVERSUS</a> </div> <div class="navbar-collapse collapse"> <ul class="nav navbar-nav"> <li><a href=https://www.semiversus.com/index.html>Blog</a></li> <li><a href=https://www.semiversus.com/dic/uebersicht.html>Unterricht</a></li> <li><a href=https://www.semiversus.com/projekte/projekte.html>Projekte</a></li> <li><a href=https://www.semiversus.com/about.html>Über mich</a></li> </ul> <form class="navbar-form navbar-right" role=search action=https://www.semiversus.com/search.html onsubmit="return validateForm(this.elements['q'].value);"> <input type=text class=form-control placeholder=Suche name=q id=tipue_search_input></form> <ul class="nav navbar-nav navbar-right socialicons"> <li><a href=https://www.linkedin.com/in/guenther-jena data-toggle=tooltip data-placement=bottom title=LinkedIn.com/Günther-Jena><span class="linkedin icon hidden-xs"></span><span class="hidden-sm hidden-md hidden-lg">Linkedin</span></a></li> <li><a href=https://www.xing.com/profile/Guenther_Jena2 data-toggle=tooltip data-placement=bottom title=Xing.com/Günther-Jena><span class="xing icon hidden-xs"></span><span class="hidden-sm hidden-md hidden-lg">Xing</span></a></li> <li><a href=https://stackoverflow.com/users/166605/g%C3%BCnther-jena data-toggle=tooltip data-placement=bottom title=Stackoverflow.com/Semiversus><span class="stackoverflow icon hidden-xs"></span><span class="hidden-sm hidden-md hidden-lg">Stack Overflow</span></a></li> <li><a href=https://github.com/semiversus data-toggle=tooltip data-placement=bottom title=Github.com/Semiversus><span class="github icon hidden-xs"></span><span class="hidden-sm hidden-md hidden-lg">Github</span></a></li> <li><a href=https://www.semiversus.com/semiversus.atom.xml class=rss data-toggle=tooltip data-placement=bottom title="RSS Feed"><span class="rss icon hidden-xs"></span><span class="hidden-sm hidden-md hidden-lg">RSS Feed</span></a></li> </ul> </div> </div> </nav> <div class=container> <div class=visible-print-block>Semiversus | AVR Assembler</div> <ol class="breadcrumb hidden-print"><li><a href=https://www.semiversus.com/dic/uebersicht.html>Unterrichtsmaterial</a></li><li><a href=https://www.semiversus.com/dic/rechnerarchitektur/uebersicht.html>Rechnerarchitektur</a></li><li><strong>AVR Assembler</strong></li></ol> <div class=row> <div class=col-md-8 role=main> <header><h1>AVR Assembler<div class="pull-right hidden-print"><a href=https://www.semiversus.com/dic/rechnerarchitektur/avr_assembler.md class="btn btn-default btn-xs" data-toggle=tooltip data-placement=bottom title="Quelltext zu dieser Seite">Quelltext</a></div></h1></header> <div class="panel panel-info"> <div class=panel-heading>&Uuml;bungsblatt</div> <div class=panel-body> <p>Zu diesem Teil gibt es <a href=https://www.semiversus.com/dic/rechnerarchitektur/uebung_avr_assembler.html>&Uuml;bungsaufgaben</a></p> </div> </div> <h2 id=allgemeines>Allgemeines</h2> <p>Der Befehlssatz des Atmel AVR ist ein typischer <em>RISC</em>-Befehlssatz. Bei der Entwicklung der AVR Reihe stand vor allem eine m&ouml;glichst effiziente Nutzung durch C-Compiler im Vordergrund.</p> <ul> <li><a class=external href=http://www.atmel.com/images/Atmel-0856-AVR-Instruction-Set-Manual.pdf>Komplette &Uuml;bersicht</a> &uuml;ber den Befehlssatz von Atmel</li> <li><a class=download href=https://www.semiversus.com/dic/rechnerarchitektur/avr_assembler_befehle.pdf>Auszug</a> der wichtigsten Befehle</li> </ul> <h3 id=blockschaltbild>Blockschaltbild</h3> <p><figure><img src=https://www.semiversus.com/dic/rechnerarchitektur/avr_blockschaltbild.svg><figcaption>Blockschaltbild des AVR (Quelle: <a href=http://www.atmel.com/images/doc2466.pdf>Datenblatt ATMega16</a> &copy; Atmel Corporation)</figcaption></figure></p> <p>Im Blockschaltbild des Atmel AVR ATMega16 erkennt man am oberen und unteren Ende die vier IO-Ports.</p> <p>Rund um den Prozessorkern (<em>AVR CPU</em>) befindet sich folgende Peripheriebausteine:</p> <ul> <li>ADC, mit Multiplexer auf die Pins von Port A</li> <li>I&sup2;C Schnittstelle (TWI - Two Wire Interface) auf Port C</li> <li>Timer/Counter</li> <li>Watchdogtimer mit dem internen Oszillator</li> <li><em>MCU Ctrl. &amp; Timing</em> - zust&auml;ndig f&uuml;r den Prozessortakt und Reset</li> <li>Interrupt Einheit</li> <li>EEPROM</li> <li>USART auf Port D</li> <li>SPI auf Port B</li> <li>Komperator</li> </ul> <p>Diese Peripheriebausteine sind &uuml;ber einen Adress/Datenbus mit dem Prozessorkern verbunden.</p> <p>Der Prozessorkern besteht aus dem Flash Speicher f&uuml;r das eigentliche Programm und dem SRAM f&uuml;r die Laufzeitvariablen. Der Programmzeiger (<em>Program Counter</em>) zeigt auf den aktuellen Befehl der vom <em>Instruction Register</em> zwischengespeichert wird und durch den <em>Instruction Decoder</em> dekodiert wird.</p> <p>Der <em>Stack Pointer</em> dient zum Ablegen von Werten und R&uuml;cksprungadressen im SRAM. F&uuml;r Berechnungen mit der <em>ALU</em> werden die Register R0 bis R31 genutzt. 3 16Bit Indexregister (X, Y und Z) dienen der indirekten Adressierung des SRAMs. Das Statusregister ist unter anderem f&uuml;r die Flags der ALU zust&auml;ndig (<em>Carry</em>, <em>Overflow</em>, usw.).</p> <p>Im Prozessorkern sieht man auch die Harvardarchitektur, da der SRAM Speicher und der Flash Speicher durch getrennte Adress/Datenbusse angesteuert werden.</p> <h2 id=registersatz_1>Registersatz</h2> <p>Die AVR Serie besitzt 32 allgemein verwendbare Register(<code>R0</code> bis <code>R31</code>). Die Register <code>R0</code> bis <code>R15</code> sind nicht verf&uuml;gbar f&uuml;r Befehle mit unmittelbaren Konstanten (z.B. <code>ldi</code>-load immediate).</p> <p>Die Register <code>R27:R26</code> bilden gemeinsam das 16 Bit X-Register, wobei <code>R27</code> das h&ouml;herwertige Byte darstellt und <code>R26</code> das niederwertige. Neben dem X-Register gibt es analog das Y und Z Register:</p> <ul> <li><code>R27:R26</code>: X-Register</li> <li><code>R29:R28</code>: Y-Register</li> <li><code>R31:R30</code>: Z-Register</li> </ul> <p>Diese Register k&ouml;nnen f&uuml;r die indirekte Adressierung genutzt werden.</p> <h2 id=stack-pointer>Stack Pointer</h2> <p>Der Stack Pointer ist eine 16 Bit Adresse und zeigt auf die aktuelle Position im Stack. Auf dem Stack werden die R&uuml;cksprungadressen bei einem <code>call</code>-Befehl und bei einem Interruptaufruf gespeichert. Zus&auml;tzlich kann der Stack genutzt werden, um Register zu sichern oder Zwischenergebnisse zu speichern.</p> <p>Der Stackpointer muss vor dem ersten Zugriff initialisiert werden. Dazu wird er an das Ende des Datenspeichers gesetzt. Der AVR Assembler unterst&uuml;tzt das Symbol <code>RAMEND</code>, das die letzte Adresse des Datenspeichers darstellt. Die Makros <code>HIGH</code> und <code>LOW</code> liefern die oberen bzw. unteren 8 Bit eines 16 Bit Wertes.</p> <div class=codehilite><pre><span></span><span class=err>ldi R16, HIGH(RAMEND)</span>
<span class=err>out SPH, R16</span>
<span class=err>ldi R16, LOW(RAMEND)</span>
<span class=err>out SPL, R16</span>
</pre></div> <h2 id=adressraume>Adressr&auml;ume</h2> <p>Bedingt durch die Harvard-Architektur der AVR Serie gibt es eine Trennung der Adressr&auml;ume f&uuml;r den Befehlsspeicher (Flash), den Datenspeicher (SRAM) und dem EEPROM.</p> <h3 id=befehlsspeicher>Befehlsspeicher</h3> <p>Der Adressraum im Befehlsspeicher wird in folgende Bereiche unterteilt:</p> <ul> <li><strong>Interruptvektoren</strong>: Sprungmarken f&uuml;r Reset und die Interruptquellen</li> <li><strong>Programmspeicher</strong>: Nach den Interruptvektoren befindet sich das eigentliche Programm</li> <li><strong>Optionaler Bootloader</strong>: Ein Teil des Befehlsspeichers kann gesch&uuml;tzt und als Bootloader verwendet werden</li> </ul> <h3 id=datenspeicher>Datenspeicher</h3> <table> <thead> <tr> <th>Adresse</th> <th>Beschreibung</th> </tr> </thead> <tbody> <tr> <td><code>0x00-0x1F</code></td> <td>Register <code>R0</code> bis <code>R31</code></td> </tr> <tr> <td><code>0x20-0x5F</code></td> <td>I/O Register 0x00 bis 0x3F</td> </tr> <tr> <td><code>0x60</code>-Ende des internen SRAM</td> <td>als Datenspeicher verwendbar</td> </tr> </tbody> </table> <h3 id=eeprom>EEPROM</h3> <p>Das EEPROM wird mittels I/O Register angesprochen.</p> <h2 id=befehlsubersicht_1>Befehls&uuml;bersicht</h2> <h3 id=transferbefehle>Transferbefehle</h3> <h4 id=kopieren-von-registern-mittels-mov>Kopieren von Registern mittels <code>mov</code></h4> <p>Kopiert den Inhalt des Registers Rr in das Register Rd.</p> <div class=codehilite><pre><span></span><span class=err>mov r0, r16 ; Kopiert den Inhalt von R16 nach R0</span>
</pre></div> <p>Eine spezielle Variante ist <code>movw</code> . Hier werden zwei Register gleichzeitig kopiert, wobei als Basisregister nur geradzahlige Register m&ouml;glich sind.</p> <div class=codehilite><pre><span></span><span class=err>movw r17:r16, r1:r0 ; Kopiert Register R1 nach R17 und Register R0 nach R16</span>
</pre></div> <h4 id=laden-von-registern-mittels-ld>Laden von Registern mittels <code>ld</code></h4> <p>Beim Laden gibt es mehrere M&ouml;glichkeiten der Adressierung der Quelle. Soll ein Konstante geladen werden, wird <code>ldi</code> verwendet.</p> <div class=codehilite><pre><span></span><span class=err>ldi R16, 0x20 ; L&auml;dt den Wert 0x20 in das Register R16</span>
</pre></div> <p>Soll von einer bestimmten Speicheradresse geladen werden, wird <code>lds</code> verwendet.</p> <div class=codehilite><pre><span></span><span class=err>lds R0, 0x60 ; L&auml;dt den Wert an der Adresse 0x60 ins Register R0</span>
</pre></div> <p>Die Register X,Y und Z k&ouml;nnen zum indirekten Laden von Werten verwendet werden. Dabei wird der Inhalt der Register als Adresse verwendet und an der Wert von der entsprechenden Adresse im Speicher geladen. Weiters ist es m&ouml;glich, die Adresse nach dem Zugriff um 1 zu erh&ouml;hen (Post-Inkrement) oder vor dem Zugriff um 1 zu erniedrigen (Pre-Dekrement).</p> <div class=codehilite><pre><span></span><span class=err>ld r0, X ; L&auml;dt den Wert an der durch das Register X dargestellten Adresse</span>
<span class=err>ld r1, Y+ ; Erh&ouml;ht nach dem Laden das Y Register um 1</span>
<span class=err>ld r3, -Y; Erniedrigt vor dem Laden das Y Register um 1</span>
</pre></div> <p>F&uuml;r den Zugriff auf Tabellen oder auf den Stack Frame eignet sich das Laden mittels Displacment. Dabei wird das Y oder Z Register verwendet und ein Offset hinzugerechnet.</p> <div class=codehilite><pre><span></span><span class=err>ldd r4, Y+20 ; L&auml;dt den Wert an der durch Y+20 dargestellten Adresse</span>
</pre></div> <h4 id=speichern-von-werten-im-sram>Speichern von Werten im SRAM</h4> <p>Beim Speichern auf eine bestimmte Speicheradresse wird der Befehl <code>sts</code> benutzt.</p> <div class=codehilite><pre><span></span><span class=err>sts 0x60, R0 ; Speichert den Wert des Registers R0 an der Adresse 0x60</span>
</pre></div> <p>&Auml;hnlich zu den <em>Load</em> Befehlen kann auch die indirekte Adressierung &uuml;ber X,Y und Z Register verwendet werden.</p> <div class=codehilite><pre><span></span><span class=err>st X, r0 ; Speichert das Register an der durch das Register X dargestellten Adresse</span>
<span class=err>st Y+, r1 ; Erh&ouml;ht nach dem Speichern das Y Register um 1</span>
<span class=err>st -Y, r1; Erniedrigt vor dem Speichern das Y Register um 1</span>
</pre></div> <h4 id=zugriff-auf-io-register>Zugriff auf I/O Register</h4> <p>Der Zugriff auf I/O Register erfolgt mittels <code>in</code> und <code>out</code>.</p> <div class=codehilite><pre><span></span><span class=err>out PORTD, R0 ; Kopiere den Wert von R0 ins IO Register PORTD</span>
<span class=err>in R29, PINA   ; Kopiere den Wert des IO Registers PINA ins Register R29</span>
</pre></div> <h4 id=arbeiten-mit-dem-stack>Arbeiten mit dem Stack</h4> <p>Der Stackpointer wird in den beiden Register <code>SPH</code> und <code>SPL</code> gespeichert. Mittels <code>push</code> und <code>pop</code> k&ouml;nnen Werte auf den Stack gelegt bzw. wieder vom Stack geholt werden. Der Stack wird au&szlig;erdem genutzt, um die R&uuml;cksprungadresse bei Subroutinen-Aufr&uuml;fen mittels <code>call</code> bzw. <code>rcall</code> zu speichern.</p> <h3 id=arithmetische-befehle_1>Arithmetische Befehle</h3> <p>Arthmetische Befehle verkn&uuml;pfen &uuml;blicherweise entweder zwei Register miteinander oder ein Register mit einer Konstante.</p> <p>Als Operationen stehen die Addtion (<code>add</code>) und Subtraktion (<code>sub</code>) zur Verf&uuml;gung. Es gibt auch jeweils eine Veriante, in der das &Uuml;bertragsbit aus einer vorhergehenden Operation verwendet wird (<code>adc</code> bzw. <code>sbc</code>). F&uuml;r die Addition der Konstante 1 stehen die Befehle <code>inc</code> (Inkrement) bzw. <code>dec</code> (Dekrement) zur Verf&uuml;gung.</p> <h3 id=logische-befehle>Logische Befehle</h3> <p>Zu den logischen Befehlen geh&ouml;rt die AND Verkn&uuml;pfung (<code>and</code> bzw. <code>andi</code>), die ODER Verkn&uuml;pfung (<code>or</code> bzw. <code>ori</code>), die Exclusive-ODER Verkn&uuml;pfung (<code>eor</code>) und die Invertierung aller Bits (<code>com</code>).</p> <h3 id=sprunge>Spr&uuml;nge</h3> <h4 id=unbedingte-sprunge>Unbedingte Spr&uuml;nge</h4> <p>Bei unbedingten Spr&uuml;ngen ist der Sprung nicht von einer Bedingung abh&auml;ngig. Es gibt relative Spr&uuml;nge (<code>rjmp</code>) und absolute Spr&uuml;nge (<code>jmp</code>). Die relativen Spr&uuml;nge k&ouml;nnen den Befehlsz&auml;hler um +/-2048 ver&auml;ndern. Dies ben&ouml;tigt zwar eine entsprechende Ber&uuml;cksichtigung vom Assembler bzw. Compiler aus, stellt aber durch die kompaktere Ausf&uuml;hrung (ein Befehlswort statt zwei) eine Optimierung dar.</p> <h4 id=bedingte-sprunge>Bedingte Spr&uuml;nge</h4> <p>Die bedingten Spr&uuml;nge bedienen sich der &Uuml;berpr&uuml;fung von Flags aus dem Statusregister und entscheiden anhand deren Zustandes, ob der Sprung genommen wird oder nicht. H&auml;ufig genutzt werden hier <code>breq</code> (branch if equal), <code>brne</code> (branch if not equal), <code>brlo</code> (branch if lower) und <code>brsh</code> (branch if same or higher).</p> <p>Die Statusflags m&uuml;ssen durch einen vorhergehenden Befehl entsprechend gesetzt werden. Will man kein Register f&uuml;r einen Vergleich &auml;ndern, sondern nur die Statusflags, so eignet sich der <code>cp</code> (compare) Befehl. Dieser Vergleicht zwei Register mittels Subtraktion und setzt die Flags entsprechend.</p> </div> <div class=col-md-4 role=complementary> <nav class="well well-sm" data-spy=affix data-offset-top=0 id=sidebar> <ul class=nav><li><a href=#allgemeines>Allgemeines</a><ul class=nav><li><a href=#blockschaltbild>Blockschaltbild</a></li></ul></li><li><a href=#registersatz_1>Registersatz</a></li><li><a href=#stack-pointer>Stack Pointer</a></li><li><a href=#adressraume>Adressr&auml;ume</a><ul class=nav><li><a href=#befehlsspeicher>Befehlsspeicher</a></li><li><a href=#datenspeicher>Datenspeicher</a></li><li><a href=#eeprom>EEPROM</a></li></ul></li><li><a href=#befehlsubersicht_1>Befehls&uuml;bersicht</a><ul class=nav><li><a href=#transferbefehle>Transferbefehle</a><ul class=nav><li><a href=#kopieren-von-registern-mittels-mov>Kopieren von Registern mittels mov</a></li><li><a href=#laden-von-registern-mittels-ld>Laden von Registern mittels ld</a></li><li><a href=#speichern-von-werten-im-sram>Speichern von Werten im SRAM</a></li><li><a href=#zugriff-auf-io-register>Zugriff auf I/O Register</a></li><li><a href=#arbeiten-mit-dem-stack>Arbeiten mit dem Stack</a></li></ul></li><li><a href=#arithmetische-befehle_1>Arithmetische Befehle</a></li><li><a href=#logische-befehle>Logische Befehle</a></li><li><a href=#sprunge>Spr&uuml;nge</a><ul class=nav><li><a href=#unbedingte-sprunge>Unbedingte Spr&uuml;nge</a></li><li><a href=#bedingte-sprunge>Bedingte Spr&uuml;nge</a></li></ul></li></ul></li></ul> </nav> </div> </div> </div> </div> <footer class="footer hidden-print"><div class=container><p class="text-muted credit">Günther Jena 2011 - 2020 | Letztes Update am 20.9.2020 (Rev. <a href=https://github.com/semiversus/semiversus.github.io-source/commit/ffdbb85>ffdbb85</a>) <a href=https://plus.google.com/111972313670421914746/about rel=author class=hidden>Google+</a><a href=https://creativecommons.org/licenses/by-sa/3.0/de/ class=pull-right><img src=https://www.semiversus.com/theme/img/cc_by_sa.svg alt="Licence CC-BY-SA"></a></p></div></footer> <script type=text/javascript>
        var s = document.createElement('script');
        s.type = 'text/javascript';
        s.src = 'https:' == document.location.protocol ? 'https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML' : 'http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; 
        s[(window.opera ? "innerHTML" : "text")] =
            "MathJax.Hub.Config({" + 
            "    config: ['MMLorHTML.js']," + 
            "    jax: ['input/TeX','input/MathML','output/HTML-CSS','output/NativeMML']," +
            "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," + 
            "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
            "    tex2jax: { " +
            "        inlineMath: [ ['%%','%%'] ], " +
            "        processEscapes: false }, " +
            "    'HTML-CSS': { " +
            "        styles: { '.MathJax .mo, .MathJax .mi': {color: 'black ! important'}} " +
            "    } " +
            "}); ";
        (document.body || document.getElementsByTagName('head')[0]).appendChild(s);
    </script> </body> </html>