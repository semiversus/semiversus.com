<!DOCTYPE html><html lang=de> <head><title>Scheduling</title><link rel=icon href=https://www.semiversus.com/favicon.ico><meta charset=utf-8><meta name=description content="Allgemeines Unter Scheduling (englisch für „Zeitplanerstellung“), versteht man das Erstellen eines Ablaufplanes (schedule), der Prozessen zeitlich begrenzt Ressourcen zuteilt. Dem Scheduler stehen als Entscheidungsbasis die anstehenden Aufgaben zur Verfügung. Kriterien Ein gutes Scheduling-Verfahren zeichnet sich dadurch aus, dass es die folgenden Kriterien optimiert: Durchsatz: Möglichst viele Prozesse ..."><meta name=author content="Günther Jena"><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=google-site-verification content=O-3LVEziPiVrCYqFCwbLmB3s7lNG__cPMLLAr_RUxbA><meta name=msvalidate.01 content=70DFF0E672B42811AA384CC455C9406C><link rel=stylesheet href=https://www.semiversus.com/theme/css/semiversus.min.css?f7108c59><script async src=https://www.semiversus.com/theme/js/semiversus.min.js?c02fe949></script></head> <body data-spy=scroll data-target=#sidebar data-offset=30> <div id=wrap> <nav class="navbar navbar-inverse"> <div class=container> <div class=navbar-header> <button type=button class="navbar-toggle collapsed" data-toggle=collapse data-target=.navbar-collapse> <span class=icon-bar></span><span class=icon-bar></span><span class=icon-bar></span> </button> <a href=https://www.semiversus.com/index.html class=navbar-brand>SEMIVERSUS</a> </div> <div class="navbar-collapse collapse"> <ul class="nav navbar-nav"> <li><a href=https://www.semiversus.com/index.html>Blog</a></li> <li><a href=https://www.semiversus.com/dic/uebersicht.html>Unterricht</a></li> <li><a href=https://www.semiversus.com/projekte/projekte.html>Projekte</a></li> <li><a href=https://www.semiversus.com/about.html>Über mich</a></li> </ul> <form class="navbar-form navbar-right" role=search action=https://www.semiversus.com/search.html onsubmit="return validateForm(this.elements['q'].value);"> <input type=text class=form-control placeholder=Suche name=q id=tipue_search_input></form> <ul class="nav navbar-nav navbar-right socialicons"> <li><a href=https://www.linkedin.com/in/guenther-jena data-toggle=tooltip data-placement=bottom title=LinkedIn.com/Günther-Jena><span class="linkedin icon hidden-xs"></span><span class="hidden-sm hidden-md hidden-lg">Linkedin</span></a></li> <li><a href=https://www.xing.com/profile/Guenther_Jena2 data-toggle=tooltip data-placement=bottom title=Xing.com/Günther-Jena><span class="xing icon hidden-xs"></span><span class="hidden-sm hidden-md hidden-lg">Xing</span></a></li> <li><a href=https://stackoverflow.com/users/166605/g%C3%BCnther-jena data-toggle=tooltip data-placement=bottom title=Stackoverflow.com/Semiversus><span class="stackoverflow icon hidden-xs"></span><span class="hidden-sm hidden-md hidden-lg">Stack Overflow</span></a></li> <li><a href=https://github.com/semiversus data-toggle=tooltip data-placement=bottom title=Github.com/Semiversus><span class="github icon hidden-xs"></span><span class="hidden-sm hidden-md hidden-lg">Github</span></a></li> <li><a href=https://www.semiversus.com/semiversus.atom.xml class=rss data-toggle=tooltip data-placement=bottom title="RSS Feed"><span class="rss icon hidden-xs"></span><span class="hidden-sm hidden-md hidden-lg">RSS Feed</span></a></li> </ul> </div> </div> </nav> <div class=container> <div class=visible-print-block>Semiversus | Scheduling</div> <ol class="breadcrumb hidden-print"><li><a href=https://www.semiversus.com/dic/uebersicht.html>Unterrichtsmaterial</a></li><li><a href=https://www.semiversus.com/dic/komplexe_digitale_systeme/uebersicht.html>Komplexe digitale Systeme</a></li><li><strong>Scheduling</strong></li></ol> <div class=row> <div class=col-md-8 role=main> <header><h1>Scheduling<div class="pull-right hidden-print"><a href=https://www.semiversus.com/dic/komplexe_digitale_systeme/scheduling.md class="btn btn-default btn-xs" data-toggle=tooltip data-placement=bottom title="Quelltext zu dieser Seite">Quelltext</a></div></h1></header> <h2 id=allgemeines>Allgemeines</h2> <p>Unter Scheduling (englisch f&uuml;r &bdquo;Zeitplanerstellung&ldquo;), versteht man das Erstellen eines Ablaufplanes (schedule), der Prozessen zeitlich begrenzt Ressourcen zuteilt. Dem Scheduler stehen als Entscheidungsbasis die anstehenden Aufgaben zur Verf&uuml;gung.</p> <h2 id=kriterien>Kriterien</h2> <p>Ein gutes Scheduling-Verfahren zeichnet sich dadurch aus, dass es die folgenden Kriterien optimiert:</p> <ul> <li><strong>Durchsatz</strong>: M&ouml;glichst viele Prozesse werden in m&ouml;glichst kurzer Zeit abgearbeitet.</li> <li><strong>Effizienz</strong>: Die zur Verf&uuml;gung stehenden Ressourcen werden m&ouml;glichst vollst&auml;ndig ausgelastet.</li> <li><strong>Fairness</strong>: Die Ressourcen werden den Prozessen gerecht zugeteilt, das hei&szlig;t kein Prozess wird dauerhaft vernachl&auml;ssigt. Man sagt auch, das Verfahren vermeide das &bdquo;Verhungern&ldquo; (starvation) von Prozessen.</li> <li><strong>Echtzeit</strong>: Prozesse, die zu einem bestimmten Zeitpunkt beendet sein m&uuml;ssen, werden so geplant, dass der Zeitpunkt eingehalten wird.</li> <li><strong>Verweilzeit</strong>: Prozesse sollten m&ouml;glichst schnell beendet sein.</li> <li><strong>Einfach und schnell</strong>: F&uuml;r Implementierungen kann es sinnvoll sein, m&ouml;glichst wenig Ressourcen im Scheduler selbst zu verbrauchen.</li> </ul> <h2 id=praemptiv-und-nicht-praemptiv>Pr&auml;emptiv und Nicht-Pr&auml;emptiv</h2> <p>Beim nicht-pr&auml;emptiven Verfahren &uuml;bergibt ein Prozess die ben&ouml;tigten Ressourcen selbstst&auml;ndig, wenn diese nicht mehr ben&ouml;tigt werden. Dies gilt insbesondere f&uuml;r die Prozessorzeit. Wenn einem Prozess also Prozessorzeit zugeteilt wird kann dieser Prozess frei entscheiden, wann er die Kontrolle an das Betriebssystem zur&uuml;ck gibt. Dieses Verfahren wird auch kooperatives Verfahren genannt. Wenn ein Prozess durch einen Fehler die Kontrolle nicht zur&uuml;ck gibt bleibt das ganze System <em>h&auml;ngen</em>. Dieses Verfahren kann aber gro&szlig;e Vorteile bei Echtzeitbetriebssystemen haben, da es m&ouml;glich ist, die Ressourcen sehr gut zu nutzen.</p> <p>Das pr&auml;emtive (engl. preemptive) Verfahren hat die M&ouml;glichkeit, dem Prozess die Zuteilung des Prozessors zu entziehen. Dieses Verfahren wird meist mit festen Zeitschlitzen implementiert, nach deren Ende jeweils ein Prozesswechsel vollzogen wird.</p> <h2 id=scheduling-strategien>Scheduling Strategien</h2> <p>Das gr&ouml;&szlig;te Problem des Schedulers ist die Tatsache, dass die ben&ouml;tigten Betriebsmittel f&uuml;r die einzelnen Prozesse meist nicht im Vorfeld bekannt sind. Es l&auml;sst sich also im Allgemeinen keine optimale Planung erstellen, sondern der Scheduler muss dynamisch auf ge&auml;nderte Anforderungen reagieren. Dabei k&ouml;nnen (abh&auml;ngig vom Scheduler) verschiedene Zuteilungsstrategien zum Einsatz kommen.</p> <h3 id=first-in-first-out-fifo-first-come-first-served-fcfs>First In &ndash; First Out (FIFO), First-Come First-Served (FCFS)</h3> <p>Hierbei werden alle Prozesse in der Reihenfolge ihres Eingangs bearbeitet. Eine Neuzuteilung der Prozesse findet erst statt, wenn der laufende Prozess zu warten beginnt oder seine Ausf&uuml;hrung beendet ist. Diese Strategie erzielt eine gute Auslastung bez&uuml;glich der CPU, allerdings nicht bez&uuml;glich Ressourcen, die l&auml;ngere Zeit f&uuml;r eine Anforderung ben&ouml;tigen k&ouml;nnen, wie z. B. Ein-/Ausgabe oder Massenspeicher. F&uuml;r Mehrbenutzersysteme ist die Strategie dar&uuml;ber hinaus wenig geeignet, da einzelne Benutzer so ggf. f&uuml;r l&auml;ngere Zeit (n&auml;mlich bei aufwendigen Prozessen anderer Benutzer) ausgeschlossen werden.</p> <p>Beispiel mit kooperativem Scheduling</p> <table> <thead> <tr> <th align=center>&nbsp;</th> <th align=center>Startzeit</th> <th align=center>Dauer</th> </tr> </thead> <tbody> <tr> <td align=center>Job A</td> <td align=center>0</td> <td align=center>4</td> </tr> <tr> <td align=center>Job B</td> <td align=center>1</td> <td align=center>3</td> </tr> <tr> <td align=center>Job C</td> <td align=center>2</td> <td align=center>2</td> </tr> <tr> <td align=center>Job D</td> <td align=center>5</td> <td align=center>1</td> </tr> </tbody> </table> <p>Ausf&uuml;hrung:</p> <table> <thead> <tr> <th align=center>0</th> <th align=center>1</th> <th align=center>2</th> <th align=center>3</th> <th align=center>4</th> <th align=center>5</th> <th align=center>6</th> <th align=center>7</th> <th align=center>8</th> <th align=center>9</th> </tr> </thead> <tbody> <tr> <td align=center>A</td> <td align=center>A</td> <td align=center>A</td> <td align=center>A</td> <td align=center>B</td> <td align=center>B</td> <td align=center>B</td> <td align=center>C</td> <td align=center>C</td> <td align=center>D</td> </tr> </tbody> </table> <h3 id=shortest-job-next-sjn-shortest-job-first-sjf-shortest-processing-time-spt>Shortest-Job-Next (SJN), Shortest Job First (SJF), Shortest Processing Time (SPT)</h3> <p>Ein weiteres Verfahren, das nicht f&uuml;r Mehrbenutzersysteme geeignet ist. Es l&auml;sst sich in F&auml;llen einsetzen, in denen die ben&ouml;tigte Rechenzeit f&uuml;r einzelne Aufgaben aus Erfahrungswerten gut vorhergesagt werden kann. Ein Nachteil ist, dass gro&szlig;e Prozesse u. U. niemals die CPU zugeteilt bekommen, wenn sich immer k&uuml;rzere Jobs vordr&auml;ngeln. K&ouml;nnen Prozesse unterbrochen werden, das hei&szlig;t ein Prozesswechsel wird durchgef&uuml;hrt, wenn ein neu ankommender Prozess eine k&uuml;rzere Ausf&uuml;hrungszeit aufweist, als die verbleibende Ausf&uuml;hrungszeit des aktuellen Prozesses, so spricht man von Shortest-Remaining-Time (SRT) oder Shortest-Remaining-Processing-Time (SRPT).</p> <p>Ausf&uuml;hrung (gleiche Angaben wie Beispiel davor):</p> <table> <thead> <tr> <th align=center>0</th> <th align=center>1</th> <th align=center>2</th> <th align=center>3</th> <th align=center>4</th> <th align=center>5</th> <th align=center>6</th> <th align=center>7</th> <th align=center>8</th> <th align=center>9</th> </tr> </thead> <tbody> <tr> <td align=center>A</td> <td align=center>A</td> <td align=center>A</td> <td align=center>A</td> <td align=center>C</td> <td align=center>C</td> <td align=center>D</td> <td align=center>B</td> <td align=center>B</td> <td align=center>B</td> </tr> </tbody> </table> <h3 id=earliest-due-date-edd>Earliest Due Date (EDD)</h3> <p>Bei dieser Strategie werden diejenigen Prozesse zuerst ausgef&uuml;hrt, welche die geringste Deadline haben. Voraussetzung daf&uuml;r sind statische Deadlines und gleichzeitiges Eintreffen voneinander unabh&auml;ngiger Tasks. Dieses nichtunterbrechende Verfahren ist ideal, um die maximale Versp&auml;tung zu minimieren. Wenn Prozesse unterbrochen werden k&ouml;nnen spricht man von einer Terminabh&auml;ngigen Ablaufplanung, Planen nach Fristen oder Earliest Deadline First (EDF). Diese Strategie kommt haupts&auml;chlich in Echtzeitsystemen vor, da es damit m&ouml;glich ist, eine definierte Antwortzeit f&uuml;r bestimmte Prozesse zu garantieren.</p> <h3 id=round-robin-zeitscheibenverfahren>Round Robin, Zeitscheibenverfahren</h3> <p>Einem Prozess wird die CPU f&uuml;r eine bestimmte (kurze) Zeitspanne zugeteilt. Danach wird der Prozess wieder hinten in die Warteschlange eingereiht. Sind die einzelnen Zeitspannen unterschiedlich gro&szlig;, so spricht man von Weighted Round Robin (WRR).</p> <p>Round-Robin behandelt alle Prozesse gleich, so dass einerseits kein Prozess unfair behandelt wird oder gar verhungert, es aber andererseits auch nicht m&ouml;glich ist, Prozesse mit h&ouml;herer Dringlichkeit bevorzugt abzuarbeiten. Der Durchsatz dieses Scheduling-Verfahrens ist im Allgemeinen weder besonders niedrig noch besonders hoch. Die Verwendung von Zeitschlitzen fester L&auml;nge macht Round-Robin unflexibel und f&uuml;hrt dazu, dass Ressourcen h&auml;ufig ungenutzt bleiben.</p> <p>Beispiel mit pr&auml;emptivem Scheduling:</p> <table> <thead> <tr> <th align=center>&nbsp;</th> <th align=center>Startzeit</th> <th align=center>Dauer</th> </tr> </thead> <tbody> <tr> <td align=center>Job A</td> <td align=center>0</td> <td align=center>4</td> </tr> <tr> <td align=center>Job B</td> <td align=center>0</td> <td align=center>3</td> </tr> <tr> <td align=center>Job C</td> <td align=center>0</td> <td align=center>2</td> </tr> <tr> <td align=center>Job D</td> <td align=center>3</td> <td align=center>1</td> </tr> </tbody> </table> <p>Ausf&uuml;hrung:</p> <table> <thead> <tr> <th align=center>0</th> <th align=center>1</th> <th align=center>2</th> <th align=center>3</th> <th align=center>4</th> <th align=center>5</th> <th align=center>6</th> <th align=center>7</th> <th align=center>8</th> <th align=center>9</th> </tr> </thead> <tbody> <tr> <td align=center>A</td> <td align=center>B</td> <td align=center>C</td> <td align=center>A</td> <td align=center>B</td> <td align=center>C</td> <td align=center>D</td> <td align=center>A</td> <td align=center>B</td> <td align=center>A</td> </tr> </tbody> </table> <h3 id=lotterie-scheduling>Lotterie-Scheduling</h3> <p>Hierbei handelt es sich um ein Wahrscheinlichkeits-Scheduling-Verfahren. Prozesse bekommen alle eine bestimmte Anzahl von Losen zugewiesen und der Prozess-Scheduler zieht ein Zufallslos, um den n&auml;chsten Prozess auszuw&auml;hlen. Die Aufteilung der Lose muss nicht gleich sein. Wenn man einem Prozess mehr Lose zuweist, erh&ouml;ht das seine relativen Chancen, ausgew&auml;hlt zu werden. Diese Technik kann man benutzen, um sich anderen Scheduling-Verfahren, wie zum Beispiel dem Shortest-Job-Next-Verfahren und dem Fair-Share-Scheduling, anzun&auml;hern. Lotterie-Scheduling l&ouml;st das Problem des Verhungerns. Wenn man jedem Prozess mindestens ein Los gibt, garantiert dies, dass es eine Wahrscheinlichkeit von &uuml;ber 0 % gibt, dass dieser Prozess bei der jeweils n&auml;chsten Scheduling-Operation ausgew&auml;hlt wird.</p> <h2 id=prioritatsscheduling_1>Priorit&auml;tsscheduling</h2> <p>Bei diesen Strategien wird jedem Prozess eine Priorit&auml;t zugeordnet. Die Abarbeitung erfolgt dann in der Reihenfolge der Priorit&auml;ten.</p> <ul> <li><strong>Rate Monotonic Scheduling</strong> (RMS): Die Priorit&auml;t wird aus der Periodenl&auml;nge berechnet (Prozesse mit k&uuml;rzeren Perioden haben h&ouml;here Priorit&auml;t).</li> <li><strong>Deadline Monotonic Scheduling</strong> (DMS): Die Priorit&auml;t wird aus der relativen Deadline berechnet (Prozesse mit gr&ouml;&szlig;eren Deadlines haben h&ouml;here Priorit&auml;t.</li> <li>Man kann auch mehreren Prozessen die gleiche Priorit&auml;t geben, sie werden dann in Eingangsreihenfolge ausgef&uuml;hrt, oder mit einem untergeordneten Zeitscheibenverfahren innerhalb der gleichen Priorit&auml;t abgewechselt (zum Beispiel Multilevel Feedback Queue Scheduling oder Shortest-Elapsed-Time (SET) )</li> <li>Die Priorit&auml;ten k&ouml;nnen auch dynamisch sein, wobei sich die Priorit&auml;t eines Prozesses mit der Zeit erh&ouml;ht, damit auch niedrig priorisierte Prozesse irgendwann bearbeitet werden und nicht st&auml;ndig von h&ouml;her priorisierten Prozessen verdr&auml;ngt werden.</li> </ul> <h3 id=prioritatsinversion>Priorit&auml;tsinversion</h3> <p>An einer Priorit&auml;tsinversion sind mehrere Prozesse mit unterschiedlicher Priorit&auml;t und eine Ressource beteiligt. Die Ressource wird hierbei mit wechselseitigem Ausschluss exklusiv belegt (etwa einem Semaphor).</p> <p>Ein Prozess mit hoher Priorit&auml;t will auf eine Ressource zugreifen, kann dies aber nicht, da die Ressource bereits von einem niedriger priorisierten Prozess belegt ist. Der hoch priorisierte Prozess muss warten, bis der andere Prozess die Ressource wieder freigibt. Dadurch sind die Prozess-Priorit&auml;ten in einer ersten Form der Priorit&auml;tsinversion vertauscht.</p> <p>Existiert nun ein Prozess mit mittlerer Priorit&auml;t, der die fragliche Ressource nicht verwendet, kann dieser mittel priorisierte Prozess den niedrig priorisierten verdr&auml;ngen, d.h. der mittel priorisierte Prozess wird anstelle des niedrig priorisierten Prozesses ausgef&uuml;hrt. Der niedrig priorisierte Prozess kann die Ressource nun nicht mehr freigeben, so dass der hoch priorisierte Prozess nicht zur Ausf&uuml;hrung kommt. Damit hindert der mittel priorisierte Prozess indirekt auch den hoch priorisierten Prozess an der Ausf&uuml;hrung, was er nach dem Prinzip des Priorit&auml;ts-Schedulings nicht darf. Die Priorit&auml;t des hoch priorisierten Prozesses und des mittel priorisierten Prozesses sind somit in einer zweiten Form der Priorit&auml;tsinversion vertauscht.</p> <h3 id=aushungern>Aushungern</h3> <p>Zur Aushungerung von Prozssen (engl. Starvation) kommt es, wenn niederpriore Prozesse nie zur Ausf&uuml;hrung kommen, da immer h&ouml;her priore Prozesse an die Reihe kommen. Ein Mittel zur Vermeidung von Aushungerung ist das <em>Priority Aging</em>. Dabei wird die Priorit&auml;t eines Prozess w&auml;hrend der Laufzeit erh&ouml;ht, wenn er nicht zur Ausf&uuml;hrung kommt. Irgendwann ist diese dynamische Priorit&auml;t h&ouml;her als die der anderen Prozesse und der Prozess kommt zur Ausf&uuml;hrung. <em>Priority Aging</em> ist auch eine m&ouml;gliche L&ouml;sung zur Priorit&auml;tsinversion.</p> </div> <div class=col-md-4 role=complementary> <nav class="well well-sm" data-spy=affix data-offset-top=0 id=sidebar> <ul class=nav><li><a href=#allgemeines>Allgemeines</a></li><li><a href=#kriterien>Kriterien</a></li><li><a href=#praemptiv-und-nicht-praemptiv>Pr&auml;emptiv und Nicht-Pr&auml;emptiv</a></li><li><a href=#scheduling-strategien>Scheduling Strategien</a><ul class=nav><li><a href=#first-in-first-out-fifo-first-come-first-served-fcfs>First In &ndash; First Out (FIFO), First-Come First-Served (FCFS)</a></li><li><a href=#shortest-job-next-sjn-shortest-job-first-sjf-shortest-processing-time-spt>Shortest-Job-Next (SJN), Shortest Job First (SJF), Shortest Processing Time (SPT)</a></li><li><a href=#earliest-due-date-edd>Earliest Due Date (EDD)</a></li><li><a href=#round-robin-zeitscheibenverfahren>Round Robin, Zeitscheibenverfahren</a></li><li><a href=#lotterie-scheduling>Lotterie-Scheduling</a></li></ul></li><li><a href=#prioritatsscheduling_1>Priorit&auml;tsscheduling</a><ul class=nav><li><a href=#prioritatsinversion>Priorit&auml;tsinversion</a></li><li><a href=#aushungern>Aushungern</a></li></ul></li></ul> </nav> </div> </div> </div> </div> <footer class="footer hidden-print"><div class=container><p class="text-muted credit">Günther Jena 2011 - 2020 | Letztes Update am 20.9.2020 (Rev. <a href=https://github.com/semiversus/semiversus.github.io-source/commit/ffdbb85>ffdbb85</a>) <a href=https://plus.google.com/111972313670421914746/about rel=author class=hidden>Google+</a><a href=https://creativecommons.org/licenses/by-sa/3.0/de/ class=pull-right><img src=https://www.semiversus.com/theme/img/cc_by_sa.svg alt="Licence CC-BY-SA"></a></p></div></footer> <script type=text/javascript>
        var s = document.createElement('script');
        s.type = 'text/javascript';
        s.src = 'https:' == document.location.protocol ? 'https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML' : 'http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; 
        s[(window.opera ? "innerHTML" : "text")] =
            "MathJax.Hub.Config({" + 
            "    config: ['MMLorHTML.js']," + 
            "    jax: ['input/TeX','input/MathML','output/HTML-CSS','output/NativeMML']," +
            "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," + 
            "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
            "    tex2jax: { " +
            "        inlineMath: [ ['%%','%%'] ], " +
            "        processEscapes: false }, " +
            "    'HTML-CSS': { " +
            "        styles: { '.MathJax .mo, .MathJax .mi': {color: 'black ! important'}} " +
            "    } " +
            "}); ";
        (document.body || document.getElementsByTagName('head')[0]).appendChild(s);
    </script> </body> </html>